From dc45e50d5dbaad021b63b921de12388d1aef2037 Mon Sep 17 00:00:00 2001
From: Edmunt Pienkowsky <roed@onet.eu>
Date: Wed, 9 Jun 2021 13:35:58 +0200
Subject: [PATCH 01/13] Remove QLI


diff --git a/builds/cmake/BuildFunctions.cmake b/builds/cmake/BuildFunctions.cmake
index 1be5dcbb72..fcdb5c18d7 100644
--- a/builds/cmake/BuildFunctions.cmake
+++ b/builds/cmake/BuildFunctions.cmake
@@ -88,7 +88,7 @@ function(epp_process type files)
     foreach(F ${${files}})
         set(in  ${CMAKE_CURRENT_SOURCE_DIR}/${F})
         set(out ${CMAKE_CURRENT_BINARY_DIR}/${F}${epp_suffix})
-        
+
         get_filename_component(dir ${out} PATH)
         if (MSVC OR XCODE)
             set(dir ${dir}/$<CONFIG>)
@@ -112,7 +112,6 @@ function(epp_process type files)
                 COMMENT "Calling GPRE master for ${F}"
                 #
                 COMMAND ${CMAKE_COMMAND} -E make_directory ${dir}
-                COMMAND ${CMAKE_COMMAND} -E copy_if_different metadata.fdb ${dir}/yachts.lnk
                 COMMAND ${CMAKE_COMMAND} -E copy_if_different security.fdb ${dir}/security.fdb
                 COMMAND ${CMAKE_COMMAND} -E copy_if_different msg.fdb ${dir}/msg.fdb
                 COMMAND ${CMAKE_COMMAND} -E copy_if_different help.fdb ${dir}/help.fdb
@@ -263,7 +262,7 @@ function(create_command command type out)
     if ("${type}" STREQUAL "boot")
         set(dir ${boot_dir})
     endif()
-    
+
     set_win32(env "PATH=${dir}\;%PATH%")
     set_unix (env "PATH=${dir}/bin:$PATH")
     set(env "${env}"
@@ -288,16 +287,16 @@ function(create_command command type out)
     endif()
     set(cmd_name ${cmd_name}${conf}${ext})
     set(cmd_name ${CMAKE_BINARY_DIR}/src/${cmd_name})
-    
+
     set(content)
     foreach(e ${env})
         set(content "${content}${pre_cmd}${export} ${e}\n")
     endforeach()
-    
+
     set(cmd $<TARGET_FILE:${cmd}>)
     set(content "${content}${pre_cmd}${cmd} ${options}")
     file(GENERATE OUTPUT ${cmd_name} CONTENT "${content}")
-    
+
     if (UNIX)
         set(cmd_name chmod u+x ${cmd_name} COMMAND ${cmd_name})
     endif()
diff --git a/builds/cmake/SourceGroups.cmake b/builds/cmake/SourceGroups.cmake
index b238c6e6a6..58529882e6 100644
--- a/builds/cmake/SourceGroups.cmake
+++ b/builds/cmake/SourceGroups.cmake
@@ -48,7 +48,4 @@ source_group("JRD files\\${GEN_TXT}"        "${BSRC}/jrd/${GEN}")
 source_group("JRD files\\Trace"             "${SSRC}/jrd/trace/${CPP}")
 source_group("Lock"                         "${SSRC}/lock/${CPP}")
 source_group("REMOTE files"                 "${SSRC}/remote/${CPP}")
-source_group("QLI files"                    "${SSRC}/qli/${CPP}")
-source_group("QLI files\\${EPP_TXT}"        "${SSRC}/qli/${EPP}")
-source_group("QLI files\\${GEN_TXT}"        "${BSRC}/qli/${GEN}")
 source_group("UTILITIES files"              "${SSRC}/utilities/${CPP}")
diff --git a/builds/install/arch-specific/aix/classic/makeInstallImage.sh.in b/builds/install/arch-specific/aix/classic/makeInstallImage.sh.in
index 51b55595ea..7eb9e57fac 100644
--- a/builds/install/arch-specific/aix/classic/makeInstallImage.sh.in
+++ b/builds/install/arch-specific/aix/classic/makeInstallImage.sh.in
@@ -137,7 +137,6 @@ copyFiles() {
     cp $BuiltFBDir/bin/gstat $DestDir/bin/gstat
     copyIfExists $BuiltFBDir/bin/isc4.gbak $DestDir/bin/isc4.gbak
     cp $BuiltFBDir/bin/isql $DestDir/bin/isql
-    cp $BuiltFBDir/bin/qli $DestDir/bin/qli
 
 #   Append libraries to scripts
     addLibs $BuiltFBDir/bin changedbapassword.aix.sh $DestDir/bin
@@ -167,9 +166,6 @@ copyFiles() {
         echo "Example files have not been built!"
     fi
 
-    copyIfExists $BuiltFBDir/help/help.gbak $DestDir/help
-    cp $BuiltFBDir/help/help.fdb $DestDir/help
-
     #cp -r $BuildSrcDir/doc $DestDir
     #cp -r $BuiltFBDir/doc $DestDir
 
@@ -194,7 +190,7 @@ copyFiles() {
 #   Copy various upgrade stuff
     cp $BuildRootDir/src/misc/intl.sql                          $DestDir/misc/
     cp $BuildRootDir/src/misc/upgrade/v3.0/security_database*     $DestDir/misc/upgrade/security/
-    
+
 #   Misc config files
     cp $BuildRootDir/gen/install/misc/firebird.conf $DestDir/
     cp $BuildRootDir/gen/install/misc/databases.conf $DestDir/
diff --git a/builds/install/arch-specific/freebsd/install.sh.in b/builds/install/arch-specific/freebsd/install.sh.in
index 6f2b37c3e9..236564ff98 100755
--- a/builds/install/arch-specific/freebsd/install.sh.in
+++ b/builds/install/arch-specific/freebsd/install.sh.in
@@ -137,7 +137,7 @@ copyFiles() {
 
 	#directories
     makeDirs "@FB_BINDIR@ @FB_SBINDIR@ @FB_CONFDIR@ @FB_LIBDIR@ @FB_INCDIR@ @FB_DOCDIR@/sql.extensions @FB_SAMPLEDIR@ \
-			  @FB_SAMPLEDBDIR@ @FB_HELPDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ \
+			  @FB_SAMPLEDBDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ \
 			  @FB_GUARDDIR@ @FB_PLUGDIR@ @FB_TZDATADIR@"
 
 	for i in metadata security; do
@@ -159,7 +159,6 @@ copyFiles() {
     copyIfExists $BuiltFBDir/bin/fbsvcmgr ${TargetDir}@FB_BINDIR@
     copyIfExists $BuiltFBDir/bin/fbtracemgr ${TargetDir}@FB_BINDIR@
     cp $BuiltFBDir/bin/isql ${TargetDir}@FB_BINDIR@/isql
-    cp $BuiltFBDir/bin/qli ${TargetDir}@FB_BINDIR@/qli
 
 	chown root:wheel ${TargetDir}@FB_BINDIR@/*
 	chmod 0755 ${TargetDir}@FB_BINDIR@/*
@@ -219,13 +218,6 @@ copyFiles() {
 		chmod 0444 ${TargetDir}@FB_SAMPLEDBDIR@/*.fdb
     fi
 
-	#QLI help
-    copyIfExists $BuiltFBDir/help/help.gbak ${TargetDir}@FB_HELPDIR@
-    cp $BuiltFBDir/help/help.fdb ${TargetDir}@FB_HELPDIR@
-
-	chown root:wheel ${TargetDir}@FB_HELPDIR@/*.fdb
-	chmod 0444 ${TargetDir}@FB_HELPDIR@/*.fdb
-
 	#message file
     cp $BuiltFBDir/*.msg ${TargetDir}@FB_MSGDIR@
 
@@ -368,9 +360,6 @@ fixFilePermissions() {
     do
 		MakeFileFirebirdWritable $i
     done
-
-    cd @FB_HELPDIR@
-    chmod a=r help.fdb
 }
 
 
diff --git a/builds/install/arch-specific/hpux/classic/makeinstallImage.sh.in b/builds/install/arch-specific/hpux/classic/makeinstallImage.sh.in
index 9cc18e2968..41ad0d15e7 100644
--- a/builds/install/arch-specific/hpux/classic/makeinstallImage.sh.in
+++ b/builds/install/arch-specific/hpux/classic/makeinstallImage.sh.in
@@ -135,7 +135,6 @@ copyFiles() {
     cp $BuiltFBDir/bin/gstat $DestDir/bin/gstat
     copyIfExists $BuiltFBDir/bin/isc4.gbak $DestDir/bin/isc4.gbak
     cp $BuiltFBDir/bin/isql $DestDir/bin/isql
-    cp $BuiltFBDir/bin/qli $DestDir/bin/qli
 
 #   Append libraries to scripts
     addLibs $BuiltFBDir/bin changedbaPassword.sh $DestDir/bin
@@ -166,9 +165,6 @@ copyFiles() {
         echo "Example files have not been built!"
     fi
 
-    copyIfExists $BuiltFBDir/help/help.gbak $DestDir/help
-    cp $BuiltFBDir/help/help.fdb $DestDir/help
-
     #cp -r $BuildSrcDir/doc $DestDir
     #cp -r $BuiltFBDir/doc $DestDir
 
@@ -200,7 +196,7 @@ copyFiles() {
 #   Copy various upgrade stuff
     cp $BuildRootDir/src/misc/intl.sql                          $DestDir/misc/
     cp $BuildRootDir/src/misc/upgrade/v3.0/security_database*     $DestDir/misc/upgrade/security/
-    
+
 #   Misc config files
     cp $BuildRootDir/gen/install/misc/firebird.conf $DestDir/
     cp $BuildRootDir/gen/install/misc/databases.conf $DestDir/
diff --git a/builds/install/arch-specific/hpux/super/makeinstallImage.sh.in b/builds/install/arch-specific/hpux/super/makeinstallImage.sh.in
index 35b65f0395..a6ab74265c 100644
--- a/builds/install/arch-specific/hpux/super/makeinstallImage.sh.in
+++ b/builds/install/arch-specific/hpux/super/makeinstallImage.sh.in
@@ -109,7 +109,6 @@ copyFiles() {
     cp $BuiltFBDir/bin/gstat $DestDir/bin/gstat
     copyIfExists $BuiltFBDir/bin/security.gbak $DestDir/bin/security.gbak
     cp $BuiltFBDir/bin/isql $DestDir/bin/isql
-    cp $BuiltFBDir/bin/qli $DestDir/bin/qli
 
     cp $BuildRootDir/gen/install/bin/SSchangeRunUser.sh $DestDir/bin
     cp $BuildRootDir/gen/install/bin/SSrestoreRootRunUser.sh $DestDir/bin
@@ -134,9 +133,6 @@ copyFiles() {
           done
     fi
 
-    copyIfExists $BuiltFBDir/help/help.gbak $DestDir/help
-    cp $BuiltFBDir/help/help.fdb $DestDir/help
-
     #cp -r $BuildSrcDir/doc $DestDir
     #cp -r $BuiltFBDir/doc $DestDir
 
diff --git a/builds/install/arch-specific/linux/makeInstallImage.sh.in b/builds/install/arch-specific/linux/makeInstallImage.sh.in
index 519662815f..8bec73a8b3 100644
--- a/builds/install/arch-specific/linux/makeInstallImage.sh.in
+++ b/builds/install/arch-specific/linux/makeInstallImage.sh.in
@@ -162,7 +162,7 @@ copyFiles() {
 
 	#directories
     makeDirs "@FB_BINDIR@ @FB_SBINDIR@ @FB_CONFDIR@ @FB_LIBDIR@ @FB_INCDIR@/firebird @FB_DOCDIR@/sql.extensions \
-    		  @FB_SAMPLEDIR@ @FB_SAMPLEDBDIR@ @FB_HELPDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ \
+    		  @FB_SAMPLEDIR@ @FB_SAMPLEDBDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ \
     		  @FB_GUARDDIR@ @FB_PLUGDIR@ @FB_TZDATADIR@"
 
 	for i in udf; do
@@ -182,7 +182,6 @@ copyFiles() {
     copyIfExists $BuiltFBDir/bin/fbsvcmgr ${TargetDir}@FB_BINDIR@
     copyIfExists $BuiltFBDir/bin/fbtracemgr ${TargetDir}@FB_BINDIR@
     cp $BuiltFBDir/bin/isql ${TargetDir}@FB_BINDIR@/isql
-    cp $BuiltFBDir/bin/qli ${TargetDir}@FB_BINDIR@/qli
 
 	chmod 0755 ${TargetDir}@FB_BINDIR@/*
 
@@ -226,12 +225,6 @@ copyFiles() {
 		chmod 0755 ${TargetDir}@FB_SAMPLEDIR@/prebuilt/bin/*
     fi
 
-	#QLI help
-    copyIfExists $BuiltFBDir/help/help.gbak ${TargetDir}@FB_HELPDIR@
-    cp $BuiltFBDir/help/help.fdb ${TargetDir}@FB_HELPDIR@
-
-	chmod 0444 ${TargetDir}@FB_HELPDIR@/*.fdb
-
 	#message file
     cp $BuiltFBDir/*.msg ${TargetDir}@FB_MSGDIR@
 
diff --git a/builds/install/arch-specific/netbsd/install.sh.in b/builds/install/arch-specific/netbsd/install.sh.in
index f820fef0b0..656257a489 100644
--- a/builds/install/arch-specific/netbsd/install.sh.in
+++ b/builds/install/arch-specific/netbsd/install.sh.in
@@ -151,7 +151,6 @@ copyIfExists $BuiltFBDir/bin/gsplit $DestDir/bin/gsplit  || exit
 cp $BuiltFBDir/bin/gstat $DestDir/bin/gstat  || exit
 copyIfExists $BuiltFBDir/bin/isc4.gbak $DestDir/bin/isc4.gbk  || exit
 cp $BuiltFBDir/bin/isql $DestDir/bin/isql  || exit
-cp $BuiltFBDir/bin/qli $DestDir/bin/qli  || exit
 
 # Copy examples only if we have them
 exampleFiles=`find $BuiltFBDir/examples/ -type f -print`
@@ -165,9 +164,6 @@ else
 	done
 fi
 
-copyIfExists $BuiltFBDir/help/help.gbak $DestDir/help  || exit
-cp $BuiltFBDir/help/help.fdb $DestDir/help  || exit
-
 cp $BuiltFBDir/firebird.msg $DestDir/firebird.msg  || exit
 cp $BuiltFBDir/security2.fdb $DestDir/security2.fdb.sample || exit
 
@@ -240,7 +236,7 @@ do
 	chmod ug=rx,o= $i || exit
 done
 
-chmod a=rx isql qli
+chmod a=rx isql
 
 # SUID is needed for running server programs.
 for i in fb_lock_mgr gds_drop fb_smp_server
diff --git a/builds/install/arch-specific/solaris/CS/prototype.in b/builds/install/arch-specific/solaris/CS/prototype.in
index 360c6bc1cf..d5695263d7 100644
--- a/builds/install/arch-specific/solaris/CS/prototype.in
+++ b/builds/install/arch-specific/solaris/CS/prototype.in
@@ -71,7 +71,6 @@ f none @prefix@/bin/gstat=$SRCDIR/bin/gstat 0451 firebird firebird
 #f none @prefix@/bin/fbguard=$SRCDIR/bin/fbguard 0451 firebird firebird
 #f none @prefix@/bin/fbmgr.bin=$SRCDIR/bin/fbmgr.bin 0451 firebird firebird
 f none @prefix@/bin/fb_lock_print=$SRCDIR/bin/fb_lock_print 0451 firebird firebird
-f none @prefix@/bin/qli=$SRCDIR/bin/qli 0555 firebird firebird
 # from 2.0
 f none @prefix@/bin/nbackup=$SRCDIR/bin/nbackup 0451 firebird firebird
 
diff --git a/builds/install/arch-specific/win32/BuildExecutableInstall.bat b/builds/install/arch-specific/win32/BuildExecutableInstall.bat
index e05e94953d..5220bba9e5 100644
--- a/builds/install/arch-specific/win32/BuildExecutableInstall.bat
+++ b/builds/install/arch-specific/win32/BuildExecutableInstall.bat
@@ -431,22 +431,6 @@ copy %FB_ROOT_PATH%\builds\install\misc\databases.conf %FB_OUTPUT_DIR%\databases
 @goto :EOF
 
 
-:MISC
-::==============================================
-:: Make sure that qli's help.fdb is available
-::===============================================
-@if not exist %FB_OUTPUT_DIR%\help\help.fdb (
-    (@echo   Copying help.fdb for qli support)
-    (@copy %FB_GEN_DIR%\dbs\help.fdb %FB_OUTPUT_DIR%\help\help.fdb > nul)
-    (@if %ERRORLEVEL% GEQ 1 ( (call :ERROR Could not copy qli help database ) & (goto :EOF)))
-)
-
-
-::End of MISC
-::-----------------
-@goto :EOF
-
-
 :FB_MSG
 ::=================================================================
 :: firebird.msg is generated as part of the build process
@@ -714,9 +698,6 @@ if defined WIX (
 @echo   Writing databases conf
 @(@call :DB_CONF ) || (@echo Error calling DB_CONF && @goto :END)
 @echo.
-@echo   Copying miscellany such as the QLI help database
-@(@call :MISC ) || (@echo Error calling MISC & @goto :END)
-@echo.
 @echo   Copying firebird.msg
 @(@call :FB_MSG ) || (@echo Error calling FB_MSG && @goto :END)
 @echo.
diff --git a/builds/install/arch-specific/win32/FirebirdInstallEnvironmentChecks.inc b/builds/install/arch-specific/win32/FirebirdInstallEnvironmentChecks.inc
index 7472d1500e..eede7759cc 100644
--- a/builds/install/arch-specific/win32/FirebirdInstallEnvironmentChecks.inc
+++ b/builds/install/arch-specific/win32/FirebirdInstallEnvironmentChecks.inc
@@ -748,7 +748,7 @@ procedure SetupSharedFilesArray;
 //to list them in the order they appear in the setup script
 // Shared Files are defined as either:
 // - Files which are absolutely necessary for a functioning installation.
-//     Hence gbak and gfix are shared files, isql and qli are not
+//     Hence gbak and gfix are shared files, isql is not
 // - Libraries
 // - License files
 begin
@@ -803,7 +803,7 @@ SharedFileArray[34].Filename := ExpandConstant('{app}')+'fbtracemgr.exe';
 SharedFileArray[35].Filename := ExpandConstant('{app}')+'zlib1.dll';
 SharedFileArray[36].Filename := ExpandConstant('{app}')+'replication.conf';
 
-// FIXME 
+// FIXME
 // Add in WOW64 here.
 
 end;
@@ -1135,7 +1135,7 @@ begin
 
   //If existing install of the same majorver.minorver is
   //found then we can upgrade it.
-//// **** FIX ME **** Don't use hardcoded constants here. They get overlooked.	
+//// **** FIX ME **** Don't use hardcoded constants here. They get overlooked.
   if ( (ProductsInstalledCount = 1) AND
 #if PlatformTarget == "x64"
     ((ProductsInstalled AND FB30_x64 ) = FB30_x64 ) ) then begin
diff --git a/builds/install/posix-common/fb_config.in b/builds/install/posix-common/fb_config.in
index 6619bb0325..9f95c53d7e 100644
--- a/builds/install/posix-common/fb_config.in
+++ b/builds/install/posix-common/fb_config.in
@@ -33,7 +33,6 @@ fb_confdir=@FB_CONFDIR@
 fb_docdir=@FB_DOCDIR@
 fb_sampledir=@FB_SAMPLEDIR@
 fb_sampledbdir=@FB_SAMPLEDBDIR@
-fb_helpdir=@FB_HELPDIR@
 fb_intldir=@FB_INTLDIR@
 fb_miscdir=@FB_MISCDIR@
 fb_securedbdir=@FB_SECDBDIR@
@@ -71,7 +70,6 @@ Where Options are:
      --docdir
      --sampledir
      --sampledbdir
-     --helpdir
      --intldir
      --miscdir
      --securedbdir
@@ -100,7 +98,6 @@ while test $# -gt 0
         --confdir) echo $fb_confdir ;;
         --docdir) echo $fb_docdir ;;
         --sampledir) echo $fb_sampledir ;;
-        --helpdir) echo $fb_helpdir ;;
         --intldir) echo $fb_intldir ;;
         --miscdir) echo $fb_miscdir ;;
         --securedbdir) echo $fb_securedbdir ;;
diff --git a/builds/install/posix-common/posixLibrary.sh.in b/builds/install/posix-common/posixLibrary.sh.in
index f499f93e5a..12298f1e25 100644
--- a/builds/install/posix-common/posixLibrary.sh.in
+++ b/builds/install/posix-common/posixLibrary.sh.in
@@ -830,7 +830,7 @@ removeEmptyDirs() {
         dirContentChanged=''
 
 		for rootDir in @FB_BINDIR@ @FB_SBINDIR@ @FB_LIBDIR@ @FB_INCDIR@ @FB_DOCDIR@ @FB_SAMPLEDIR@ @FB_SAMPLEDBDIR@ \
-					   @FB_HELPDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ @FB_GUARDDIR@ @FB_PLUGDIR@ \
+					   @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ @FB_GUARDDIR@ @FB_PLUGDIR@ \
 					   @FB_TZDATADIR@ @FB_CONFDIR@; do
 
 			if [ -d $rootDir ]; then
@@ -878,7 +878,7 @@ fixFilePermissions() {
 	# First of all set owneship of all files to root
 	# Build list of interesting directories all over the FS
 	dirs="@FB_BINDIR@ @FB_SBINDIR@ @FB_CONFDIR@ @FB_LIBDIR@ @FB_INCDIR@/firebird @FB_DOCDIR@/sql.extensions \
-		@FB_SAMPLEDIR@ @FB_SAMPLEDBDIR@ @FB_HELPDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ \
+		@FB_SAMPLEDIR@ @FB_SAMPLEDBDIR@ @FB_INTLDIR@ @FB_MISCDIR@ @FB_SECDBDIR@ @FB_MSGDIR@ @FB_LOGDIR@ \
 		@FB_GUARDDIR@ @FB_PLUGDIR@ @FB_TZDATADIR@"
 	dirs2=`for i in $dirs; do echo $i; done|sort|uniq`
 
@@ -947,10 +947,6 @@ fixFilePermissions() {
     do
 		MakeFileFirebirdWritable $i
     done
-
-    # Fix QLI help
-	cd @FB_HELPDIR@
-    chmod a=r help.fdb
 }
 
 
diff --git a/builds/mac_os_x/CS/Helpers.make b/builds/mac_os_x/CS/Helpers.make
index f55971223a..aa64840fdc 100644
--- a/builds/mac_os_x/CS/Helpers.make
+++ b/builds/mac_os_x/CS/Helpers.make
@@ -22,7 +22,6 @@ LOCK_MGR=	$(BUILD_DIR)/gds_lock_mgr
 GFIX=		$(BUILD_DIR)/gfix
 ISQL=		$(BUILD_DIR)/isql
 GSEC=		$(BUILD_DIR)/gsec
-QLI=		$(BUILD_DIR)/qli
 CHECK_MSGS=	$(BUILD_DIR)/check_msgs
 BUILD_MSGS=	$(BUILD_DIR)/build_file
 SEC_AUTH=	$(VAR)/auth/security_db.auth
@@ -30,7 +29,6 @@ LOCAL_USER_AUTH=	$(VAR)/auth/current_euid.auth
 
 EMPTY_DB=	$(DB_ROOT)/empty.gdb
 MSG_DB=		$(DB_ROOT)/msg.gdb
-HELP_DB=	$(DB_ROOT)/help.gdb
 META_DB=	$(DB_ROOT)/metadata.gdb
 ISC_DB=		$(FIREBIRD)/isc4.gdb
 ISC_GBAK=	$(FIREBIRD)/isc.gbak
@@ -75,9 +73,6 @@ SECURITY_GEN_FILES=	$(SECURITY_EPP_FILES:%.epp=$(GEN_ROOT)/utilities/%.cpp)
 MSG_EPP_FILES=	build_file.epp change_msgs.epp check_msgs.epp enter_msgs.epp load.epp modify_msgs.epp
 MSG_GEN_FILES=	$(MSG_EPP_FILES:%.epp=$(GEN_ROOT)/msgs/%.cpp)
 
-QLI_EPP_FILES=	help.epp meta.epp proc.epp show.epp
-QLI_GEN_FILES=	$(QLI_EPP_FILES:%.epp=$(GEN_ROOT)/qli/%.cpp)
-
 GPRE_FLAGS= -r -m -z -n
 
 all:
@@ -119,9 +114,6 @@ $(GEN_ROOT)/utilities/%.cpp: $(SRC_ROOT)/utilities/%.epp $(GPRE)
 $(GEN_ROOT)/msgs/%.cpp: $(SRC_ROOT)/msgs/%.epp $(GPRE)
 	$(GPRE) $(GPRE_FLAGS) $< $@
 
-$(GEN_ROOT)/qli/%.cpp: $(SRC_ROOT)/qli/%.epp $(GPRE)
-	$(GPRE) $(GPRE_FLAGS) $< $@
-
 gds_lock_mgr: $(LOCK_MGR)
 $(LOCK_MGR): $(PROJ_ROOT)/build/gds_lock_mgr
 	cp $< $@
@@ -205,13 +197,6 @@ gfix_preprocess_%:
 gfix_preprocess_:
 	./gpre_wrapper.sh gfix_preprocess alice
 
-qli_preprocess_clean:
-	rm -f $(QLI_GEN_FILES)
-qli_preprocess: $(QLI_GEN_FILES)
-qli_preprocess_%:
-qli_preprocess_:
-	./gpre_wrapper.sh qli_preprocess qli
-
 security_preprocess_clean:
 	rm -f $(SECURITY_GEN_FILES)
 security_preprocess: $(SECURITY_GEN_FILES)
@@ -237,10 +222,6 @@ empty_db_:	$(EMPTY_DB)
 $(EMPTY_DB):
 	rm -f $(EMPTY_DB)
 	$(CREATE_DB) $(EMPTY_DB)
-	ln -fs $(EMPTY_DB) $(GEN_ROOT)/burp/yachts.lnk
-	ln -fs $(EMPTY_DB) $(GEN_ROOT)/alice/yachts.lnk
-	ln -fs $(EMPTY_DB) $(GEN_ROOT)/isql/yachts.lnk
-	ln -fs $(EMPTY_DB) $(GEN_ROOT)/utilities/yachts.lnk
 empty_db_%:
 
 $(FULL_FW_FLAG):
@@ -262,24 +243,11 @@ $(PS_FW_FLAG): $(FULL_FW_FLAG) $(UPG_FW_FLAG)
 	touch $(PS_FW_FLAG)
 darwin_pseudo_fw_clean:
 
-build_dbs_: $(MSG_DB) $(HELP_DB) $(META_DB)
-build_dbs_clean:
-	rm -f $(MSG_DB) $(HELP_DB) $(META_DB)
-build_dbs_%:
-
 $(MSG_DB): $(SRC_ROOT)/msgs/msg.gbak
 	$(GBAK) -MODE read_only -R $(SRC_ROOT)/msgs/msg.gbak $@
 	ln -fs $(MSG_DB) $(GEN_ROOT)/msgs/msg.gdb
 	ln -fs $(MSG_DB) $(GEN_ROOT)/msgs/master_msg_db
 
-$(HELP_DB): $(SRC_ROOT)/misc/help.gbak
-	$(GBAK) -MODE read_only -R $(SRC_ROOT)/misc/help.gbak $@
-	ln -fs $(HELP_DB) $(GEN_ROOT)/qli/help.gdb
-
-$(META_DB): $(SRC_ROOT)/misc/metadata.gbak
-	$(GBAK) -MODE read_only -R $(SRC_ROOT)/misc/metadata.gbak $@
-	ln -fs $(META_DB) $(GEN_ROOT)/qli/yachts.lnk
-
 isc4.gdb_: $(ISC_DB) sysdba_user
 $(ISC_DB) : $(SRC_ROOT)/utilities/isc4.sql $(SRC_ROOT)/utilities/isc4.gdl
 	( cd $(FIREBIRD); $(ISQL) -z -i $(SRC_ROOT)/utilities/isc4.sql)
@@ -334,7 +302,7 @@ fw_files_:
 	mkdir -p $(VAR)/auth
 	mkdir -p $(FB_FW)/Resources/bin
 	cp $(FIREBIRD)/interbase.msg $(VAR)/interbase.msg
-	-cp $(GPRE) $(GBAK) $(ISQL) $(QLI) $(GSEC) $(GFIX) $(FB_FW)/Resources/bin
+	-cp $(GPRE) $(GBAK) $(ISQL) $(GSEC) $(GFIX) $(FB_FW)/Resources/bin
 	cp $(FIREBIRD)/isc.gbak $(VAR)
 	cp build/gdsintl $(VAR)/intl
 	chmod a+x $(VAR)/intl/*
diff --git a/builds/misc/help.gbak b/builds/misc/help.gbak
deleted file mode 100644
index 524fd36eae61a392408be897ac369ae9802c27cb..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 102912
zcmeFaTX5Xho#)q*sSDbYY|E0Zu|4+Ruq}`h0A6&bL`opgBw>R94S<$7SQ^s+nq-d}
z-54}LiWW7sN#!A`RPvBYZEdCUl2j@WsU(}EQmNEdDi5hV<RK5KtyEr;2PQQ$p4r*C
zcy{)dtdo4czu!6M|L^WUE)-fD&z4yd33Q+P`Q2})^60V0E0xNzV~_CnWA^vs$0}K+
z@}&Lz#FMuht*yyh8*7ieu)N#Iez@DpPM^w7zj5}|TW3$5$<CZQb-MD*Gog3onEGY&
zmC956RH;0YdRHE)Jo?CE%L`X$r=Ot7GkjS+_8tBnv4&r?ziIOL)v3kW{PMnSp1e3U
zJv%qMd_8ZaE%c4_#ii>@%e5=37w4uf<qfsVzJ|w^YaiHzkMU*o*pq!No;r4wPgvTs
zKc1WY{?)~W>DtV-#oFrp)RkI3Zr0c9g=3F;ucv!@sl$HLgl=DW<Z(Nyr6;RPKc4%(
z|NPYB>}ck~ROQ$sw&X|c@28LH==K`*Yj!a&*y)bi&-6~`_h|a*X<Kf*m;TfIntj_h
zieKiV{?F4kL+sywuU|X%7;Eh7A8z{5@bA;My1hrx1brhEZ}`#TFHax)f}M#&S^t%P
z&A#m!Yvc=$JkxVeOHbIA3rAjZ`;V4<*1L_2WfY;U^dNg7<k8+=<HeK%P096+JlVgM
z%43gwwP$myv-2~x4<5Ax|AJjy!2Xi`JYnBg9)IN6ID7fZu~Yp0=p$GEkL;I~NB)(+
zsyy)p8|Cq1=lT4xV^8q+6OUKc8n>G5>h~%ejrCT2yOC}2S9@o*yR+SF-^%XPx9{oS
zl~+#PsAiSkFVAH!P4;|JtyZ=hTaEfo_S&iH4=NddZg#e_oz7Nsy_?-_?%ejDv&Qez
z)jqDCuZ(Ol)sBBN9_G(>Za3Q5W@n>$^Io>w)e?NB>|E~(tH&yh_C}RGYqw#~hHSrY
z+h*&J{?mNxv|;P|`-$EzU!0p=T3&VJ{gc@9SfS_p)>E+h#H4oF*$zwYW?g=6Y-DTq
z!tOflY|QsOxl!L4tG-|H9d<u#Ze?f2L#zAQSa#eub(SCR#|`rN34JwjVmwoi@oc>#
zI!?dFM?3lF*_rAWwf9wDOch`Xga{xyHaqjd=|>HDBGhQpk0m1VSU}~+0-aBw^8wAi
za_lyLKg!wt&3|6`0`U0D?6C)*^6&3w#~#=}k3Gm9e0uUPD*ycdO;B}F;~yL0?<Zy|
zKW;U%<3HYQY~Rb~>g`**^;?Z>w!PEX-r8>P_ld08)fH!4d}F)5zSF$Z$T+Kd#@E};
z#+`aA12XFEjcl{tZf@<i>N`!2)tcX|uQxbDYrj_SHo9uV1a<>9$pt>0tiEfj=<aUm
zuDGS<t#<QfbG;6%b$8dg4L<AK%r4DbnH$fb+~b+1yEId~IM%hXtKS4EZZ_LZo4OUZ
zaeQWG?!;vEkxF%@a=o*gF<`dY{3u)N2)x;oMzpaQR0z~$Mn>E<gu2(+-OhfO(_!6R
zwlrD2Sh?J}+ql!%9?$qv!?im*z<eX??$mc0n_y$thFkA!veAuhc5}P4na>nvV4OOe
zWMg?RwpZ8I@{uO9rRHW6L~q?2n9iG4Pgl|i86(zv#?*<`eTS*lq_9r_QvjP^R*s!D
zxOw8irx$9MX6OHKAILdpkn^k{=Uio(6EvDM0c__B&u(pZcDK42gXSN01rQxA5dzU_
zWUQS-+Uo4~^jxpES^!7AFzi~Zv;N_v=#%d8TxH@2e>B1uD;g`aomPLtf8lrTc_Kfi
z$;s-7e^r~G8P2>fR5*|G97qSsy$+y)3`Q+k(e%Rn`4Ok?FZeGbw73TW9b39x-}tcE
zYK>LD8oser>Z|$dV{E|sj%;-j;+>Q5c<NO3x$srJwbR_$-DuF|^c!r;Is`&I2nss}
z3eN!w3k!3#srl8~2UizsOG~p0^Z#%kxR^4y_?qD2-O3aQ)@e2B?TN-m5D`P3OoU<=
zB!QT8vYqYS#&~wK-s<uXY-h7cqxP-IY<4HBPJzqa_3h@G+5%$hx9g%ijqPT4N6g9K
zI)IS|ZDfUMj*E*iMB}6S=2nZ*>v3@Ko3<x3okrbmIHBs^hSIM!cJ4OdVmo&`-YkP8
z<)d~p8#aykk!a$rZMbJcgF#j9od86I51s7|K4Xd1_h2QB^~Oe{4Gq+)!U>2$CeXj&
z2UXYsh|<mG7naAf>eH2}`5C8m3yYK0M=M&@5x{@KaR{I<xu3IV&t=u)4)h;qD_TN!
zgN3#?jHuRI#ml^3eLG^#9xYh;XYahQnC;d16JeuH;x{XMHL;z%7I!kea0T6Gc4=XL
z0?414T?UdfSU415`Tbh0_tR?VmSs!JQ;W;9^Ot%%F~aiH?0o;{)syiwu1qaYU+(`p
zgG)@LbJE<^6S2e8{Pn^V*XCz`e63daAhZ1*k?NJw{J&#}{_KNK;i9wiwbi77{bC<9
zzhr3sb)oqMBmdqxOP#qB<9tr%j3qUGch^t=oDfIoY#~L6O?R{ErAiZ=18XEtNIn3G
z)W(RUBmdTR2OQdkW`?Glo$e0EyAH2y-P368#s<(BM;Om`+bu|rG3ejjt+ynVYKnXy
z6K?Bi&gzpDFnFVd7y@Vw1Hs<V<qn)owi4Gk5$3y*)-=(sZ^9Fw3s8~HXmWBgt3Inw
z;Y0ZqWz{e6nFDKTn`Hw0>|<kP@fz;iZ)qNbz4yW_j9UED!vSfi-_bK9-S{sbHtyYp
zyaAFn`}w1hB17UII8)3_cq`t~dVQ<8(`l_X+c!JH7Gql3$(OQj{f^key)BW^x`7+Q
zCLo6R`qIg)dNwo_!IjJbEE&^T-|heu>-r=x-wtw|f9vW_h8kqkjAY%($Yfud9P=O7
zI~$ELlkJc-Q?sy4SnK+vacro*FEywUld*+Vh}$Nk6<9SWA#GxPvhZ2;c^e_iq%Y(b
zS1!2yu_5s{9()?<&g!)#s87ZkoYMWX?CTGNQG?w4pP(lUC<Y6L-;>V9#m?fmnU9+j
zv6f_V3Blp&Ojz#RZF82bjrIEW2K(qX>f7tLbN<~0z3tlHI}+%?0jp;!BWY>I*NfcA
z*E+^xceXn%#5#%dW5Vu}m66_04QEzh)J`gzjqMvNxh65eUDE-I)<X8Uv9bm2$s20G
zZ%HN2JNs}GOULiOymb7A8cbG3^6~8JctGd!&nJ?IQyr~DoGh**eGfsfVZYA2#l`r<
zC+xeUpDycOF!J8Bw_s;rciBd>TVI3Bq5?_zX|%ft33nv20@9+k19wuLkF<WXzO#PY
zgdig>lO{HmO~es`1bfV*v;A&mWG2`8rlXjcjVweSW6;K>zZ(xV{5x_*i(vir_PwZ)
zq%*co->ZzQ+!z`03Dhuy7D7STUvI<l%E(K!yCVCCWO{aTr`g#>i_Dh>EwbKct78?~
zjx-Uf){QLvtg+oO0a#i=XMKHl8<Wm@qibt;sWS2&t(PTeIyY>~tdQoH&ev*6D{oo*
z6P1zQqkZk8^%nBJ_qf?<wK{k0xYPM`wyQ7LItI7o6A%6JuT=Jei^$a<1}LiEz?f1F
z7skWiGuX{{9^`i5RP>005pxJ!0O@@P!i-I0bf?oE#Xz*#n82QK_jV)69L?=a{MjKj
zk)1#hokQAXGxF%mqudJQX|IbF0F?pVSpoE`l@W;bd0$_FRhh&RI7~vHv6or!%VSyf
zJCzafoM3w!d->eEFO30)=-b-lJ=2>@MZiBX?(z78Pir5{F8{$kV&4^G3ttjj_>rBh
zIwVmKMkV|Zn+cW@cDP|*Hv`-{Tw{gXuD83gAz@9)vg(zJ4W!n_Kf3q2SW&R)Fyut%
z=ETh=mV)E&)D|wDKT!mGZiYKumjDRuZ9;621}CdETU)VjLKPNBCm(-e1H)$<y$lPT
zrq-43G&i|DWS#Aa>Qm^Sp}~o8Eg~Be*>qqizvZ^lpG<vl@+Vi8#<MF;qzn5=!%baX
zn44S3s^72l_L}it*XEWNXFsqLTDmr`TR)<7&j?R2l}=Kl4MQw@Du`uvI|Gu(lYbKr
z)TqJElMg;cd6-?g{PTUF$8Ffp3wlo54SAOwem>f2HGx!abG_A(kuVp|4WEyGKx36G
zOp0dPCx)Y$1qPqp7@lP7JI!fO6v*QaTP@RF(qg)2jf6iFPF}Xm?roQr-r0kk!4@{e
zab&cJd+K79Z)`)~Hf8IUPVs6*-}TsL-J}p!(rLqZoN1>)d@ZkrwP>Du*~#7R_Q~e0
z&h|+)6J~Z#)_35Ea$=hGQNKtpHxh=5re2%%t<->@v+Co971$yB{(Y`@<2Ev_`>d4)
zdVj+}4{K#@acZfypS7}<(=DeB*29H<8EaYOCTc*zOdF5Dgc!6;^c@aztFbQTzL8a5
ztjKkMfaBjm@LCNcX9Ww6D4S_WM~B;Q>XdxZ0PfV>T()qLPqq=dOw=0&vcC~d9x;Mp
zF~FLP;|5A&JO$<C9h@8bBasCz98{g$_89DV4!2YBN^@?z-*|;-(lBnr%tit`<KWvI
z?u1V~k~MGQn;QGD(b&qGJMWG`QQA9oFbCCetUZ?bj>>`Prv^m0N-i!e?&m6*HW2!r
zh}XMLyf99gN@xI-TQ%hm5xA6sgpvE|G$zHy`mSuCeWrRAku~b*O2J~G9r$nn)AiuF
zXg9EYR4-K2xYg-kVV7s6+1+Z@?=j$Qlo!c2CWA-N<>+bjI~~NVWbl+lq3-%{1o!UH
zY##=(TA=}HuT5b%)D<2#T7aye-{+1!*VmD>i;8$q!*SEe91#Aw-RXeRjQ7^yc)?!a
zXizW}<ny>}b+UIF<gGMEG`vHSa}3dRW5ww{Y_1}jKsgOJeDN6fFU}#^Jsk!QfK1od
z3thL&nt@w#XBF<U1tEu`<?Gv8pG0A4Y_7pq!$_I?RkG+d2x!&Q@-3Sal#`GQUbW@y
zM2vIPokZQ(Ty5`eu3<dEzl%_srbg;DIdmkVYw=qSA@oI()-MRC*u{hM!>k>46|aO1
zI{T<^NqsqMyhpHl5*`A7i!8@~%kXv=c}^KuI$1b3GYfg6LEs6NpZ){;UbqR<9CRpQ
zAwi3<!-)j3Xg^wy<DK>a;?V>P)2j3eyvAlc(!WJWalcSFno>^qw~UA(gk4#fnZ0;@
zKOyX0qhsI5>6mvZkh0w^PS{8jtgf{o5^q2FaYgFJr}&Tpc^Q&)b`mZZmV@~++gP)C
z3l^P%h-MbdH^mn7Kdy-(gUD|zvYdPJvg{KWr<kVmOnDB@SFG#cG;TyOE`pvtVcuG-
z9FzD#d_``h1r3K`C62aFjG9`TV9H}C3@DAe$e?*VKyLW503b3&6xeh^Y9mbY4>s<?
zJGMWBko;z)ChvWAb>Zr@xhc6o&Srs?!^}<cWLJ@_<|`7o_b%r|0g;NcmrVLnz?t6A
zken3ak2GPTu!4UPn=Qqpza3@DtBbSq%lpZcvxZ1736Wf;v>t_13LF`sQfL%p%gB$p
z<y=tMfyiwt_#txmbw1c3V4@&jS{ng}KJ1?g^}5lzS^ai}YtqQ=tb=p`-WIQIXsrFK
zm8BgN+<HqY15;p$IO{C^OeHK0T=Op`I$Kim3y6Dz?`8<xnVp}OV-ep^j=&(jP(Zld
zZ#XQBuo8^WSp%13u<9ZPzgQS(<+!^7CT^pBa1bYMWI}!oF2?&xYP!Pb^I0}#dJN+I
zm`%RCkY!y0Gh03@$~@zXWK5@yz5C0~o;wH0nqHX8+N^%*N3&Nm|LN+~bj^QUp1PnP
zKCyw$<pcGu)Cc<A-45YNVQ&QjsFRs+U*K1g{MUO2Pus|nyll5G#fcnd_B+?%h-Esa
zNF0Lm!#yv#L}HZ0Se}!d-sYprxAA=QA7H$@BQOS-w+R-S9QEcCf%N$3FHMf##dfD?
z95)_u<-~bm_iPe!Ko{;iYOsa%1dbc{Zm?L}!Z2o=kEnVo&@Cdmf@oHd{}eFRy}jGL
zy^0Tg(}Ko&SC?=vj#oMi)}f+!nxD+LnHmuV%yOqgeXnQRQK$^ozT5oi*ViH`o@%XO
zX@vS~l-Zt9uyt<K?~R5*?jC>h#HbON(T$B!LZjd;qnpQ1pW)L$dG2wz+33CFub%MX
z-s~ApGxkWi9tQZc@t^%n|G!mOVYxQ;KO6bQ68Yn6`&%MC&g3ak-ziha)FHPdm0Kd~
z-46k*o93>%tC%uWA{;|4<i@r7`iHjjJuH*}(b2W|C%{FmQy_U%jh!LB7|z~?JYJdU
z3~bDHWfoNopzT|Y?z`D_py2!EhyV8??^~=*&0OD)_qqH3yE*T(9_je&J3HvGCPGHV
z5@be_#G1+l?1*4x^>y4EcmfUEiG+)WvCUnyTbw6~n8}FG1FiExtdC%krMelucV<k#
z_1&Eg90|Wl3xx-SlG0KyTAaCOZ2b@z1?@p!Hk)ne#|8ldJI$7zAxufjVWs@XS_LHf
zQRg|SxwAcHX(MVCY}*<8GL=9~+k7_KN{<b$ATZdn+*0U18$wpD0M#r2O??q-@`b7C
zAH`Fi9F}eAWpM~UMno0Nd9XovG@58S_z<Yzwx(goyg)DZ3t9DpO${%Yg@On&WQ;@l
ziMQT$w~UT3H=|0r2tvm&)`M#hyS?av{yBc9Sto8|y4~10adxDQ$KT>I&Yn%jBfoR#
z5bXGe=yNLdX(JJtpFltO0EKye8mA#PawH7D=gN$a<tsx?7@0C<S)1{n&W?<nJehWJ
zlF@bO5WSHpz`8-~9W4smOw*h3^2o<4uJiRks)9D3%*EC5o-eR4H0!s|u59hD;Rz5^
zt>4(XjhN}S<HW~(n8RA4qj=%HHtWq6X0=s$@^kxveU@>pAoqEsP%~P`<!p4?>&*{4
zcWgm+IyZ9L0#bLe&%p4dwD!>|eSVptu`kxH)~1&C)7a-s(fEpp?ToQH?-J=imLf2M
zQ4wN?xvfA~Hg}2qBnC1w=hh@5z-%uMY_`o&OvgOVL}~<7L5qtsjpL3pXMsqeeP5lc
zSp4h+QAzoPm?{@Ux9>JBs<RClHsoz?L)lHjF{PFf^l?6=*%OqCfECg}ZwNec0^$~S
z!IF0xw{Yy`@tl3(zQJ67)M*9qxh2YTE7-R@`?(A#86fJ}Aprvub}*<RcgeoiMP~bY
z6hiy^YnEs_h#4Hgtamm)Q~aCd-jhdX3<94P1THNvUYlMf>FOWs<Gph*G>OZ7zlDB<
zTTRfo-r2fmG~8p~r7K3uvq)1N<}2O~2q7ArgzQ_0yqZPAUuXtMvD`kcYaVbpZCt;W
zgaJKaUOB@|e+)|Z9&-;(A(oCc;7**p5x46>edm()ITVT-P1O>)$^0>k9noiQ2XX}_
zd|FUi+&uXm11Xq3e+p)#^JD;-Pp6z>{hq-~6?h4P$RF<mEbef#^Z+-G#7>cx$g|%s
zmgxdX1L#O_gfRt?6=?}UkjPGeM)V><2a(@OD&eC-C}@xLWx`)$V;I&+qelwXO&b}w
z@PdUR_>YgMF$lw_jpFBWPYhw{b?)xAbJwKKr&q#6)UtFPhYg)FhlXzLN38=4M@_mC
z8m)=NceiPc^NDZCTOsuFnTi_5!*|E<o?QJ)98}@YWcA<=z8twIqPD3m<xu$F7!=~J
zTU@H`=dSbolrM{EzHLV+W5{v0zLk3Bh%503o_LZbf)iRBf){mc8;ur8PXw6aU-W2r
z2#g7==I~2-P{RN?*u$hwapmId;?nZO^xV|7rP>X6+4REV%*4{dwMFboEAP)PUyk2Z
zEzo3Tk@Q(oXyd2Z%F@E(a{jycj+i2U{4^%Iq&I;`3L5@6k?1_)_mkM%`t<zuv0F;w
z2=?74njl!W5&;ZHt0`9Gn=M+^v)TC@`LwdfXoRyB8_ft=9ADl0hn!wqSX%1ci7((N
z=@I3i_je=cE!CFy13g!cEmiZ9fgbG>*~{6ZDde!JZ3_}?wC^;xJLa??kM1Ty5TWiC
zWyq`sPe+wXI8^h=W?ByHs@=i*N=99<(CXBV%$Ukd>W}`Vof|ftrOONN?-yM*V}kCJ
zxuB~K>Ex0*U7_HzIioLT^)+mR2&$6T6_*j|lbIW!S&BQu4`h^YNLWb}zOAc!yK}d2
zc1OLQ(xdw;J31m<mX;S5_l<CIx1J?roOPg6kAhs*Y!lOFmJrz}0wD~kcoC`WgpLdZ
z0Fos>WVYxWW6fz6ZTF=<x*>*LMb<PRcE1ojU@9+w?`yHqAUbJrx1CkL9KKn;epTPh
zXVvG!C)3nI;FC++9U?7di*Y9!sX@zXd1XrBOkCA@w~6jKcXZ=hhF?a^xS4)O%+jkw
zzAGJ~-m<GO7X<&9=BFG7<?M~k^P!7wIM$<Wcc%H#9kK!&*?fmUW-U34X~Lg%yG*}l
za*@w9g0S2&sQbcrMA+rawfX%J)&u&gLfF>~=+vPAbBWk>W9|<l=ihs<$q|Jl6U;na
ztvARdv&C5Uik*e&oWs#8C72y1cH<|@9R0WbMnZ^%NnXJbY8P9|Yrb&Pu7IShpG?hN
zs}*uD_e;uhq1$90Ps-}|p_x;K;MdJHveS`ULLfidrhgXHrMtJA0;QT@g#5dDYhAhA
zlFD7HatkOivTmh>Phnt?X<rgzLAfS$8f<wh1Um(3GQWPA5PYh>ehTfVZx01JphfRg
z27F#7>qx%%I3pu)`SO+8^6d0Pp5SVthg@x+sP~?KKF($?T%4`V%?xy<%OQHZWY<5f
zO?Qai^VhD_7FjlhS_llBE3V-Xy?=adK|&##zmgPt)^Ld4qI`1UPWR5Mr5~dA@qV~G
zVS7Gg?}@?dOx<;3T=@}6N-0siZ5WBc&W-Z>8SLCQHQ~BPu;HuXz#37NNt^-wi2ak^
zF2ZC9&ztoRL8++r*0CX><xxI>?=AK!qF5Aif>`*z&`h)hz0Or+ng1{WZEo$1XJLN1
zQ{&t=S(v6eWqMuFXHgJE$7NhJJ<yCbM8Gy0?qp4?q>#tEmDmbblQoIonnxpawcHBR
z<@*%*AeY%TG=P!CxNH)N(Eg*bD4kb!yfJxeQp(pj4!sF(TxRTX4mH&wIAK=MLZD?B
zGL12rO@-5;d-@dBS+`JhnkkYxT!Xa0`W-CD$~w_;v$+Y*umQPJ&bk>d<W}+%@L~2i
z+{qZwNqen;qkX7zQ@#><n^uajP@IG_s8glFFyVR#8ddscI#eK`{X4sD4_HnPDx7Xu
zyfIQnsKn*W7IU*Q0p=51Brmd1^Nz7)MH8uXN1tgf9y=p+cVQ+Ddzg)lC$w?yb-R?Q
z8PC>sfl*wt%ALbszmY0jXo<?&1G>Z>`llA33CRM~$KdFUhtT7mY2=hDP@yZa7{a0S
z-H*YE#l}sNd30!(b^$9pp?8jwf~X@tUdiIY4jKUmZ9+%Y6C`^u>v@y62JJ$w2npFE
zm5?f=P*lv%`q(9Z?!{RzcRk=Ab;l~12WX<WO5$xhw-0bOfy65f%<^KMcWKg{Cdo5`
zEDFtxl`fLy8xd?o_Wk%*2>1{F)<DX&#XYmPd@H_@5R|AeXksM{Dve$#h#ChumR|&P
z{n3bNoo17#%v!P3h96P3EelUDsFDF>fvi4mD48M4Wx3Gy?;DGF>cOW|l*za>e}y`0
zf3lB_)Y-(holPtQqPb2)^ijmY@M$t=gOI`A9sDPls6x!7h?DDFsW)jL(8OR1r)vyl
z9F}nPEKXd-h)$)D%ixrKy~3FfMpjOo_Uv>5z50a!6CEI>^xOB3g1*e$J{TQ(28)IX
z09cO(=iVc#Gn?#<>NJJo`N~h^iWHF_*xE}KtuLOW8}~Cbt&%Odx^YBtL>M2FY5LV!
zkFQDb;X$#C#bBbAI68%?7qBK6YCu06y)wneDdXLg^mEzh)%x~_cxRRbhS^2Yjvboy
z>!hRed>G2s2rqi|;7P}SBgn;sdt*2ui;<}=kiV>qORNSS3e^)Q+7k+`^!kFw;-&2L
zBv@R1%qA*F%Kt6OZ8NpG+H!3_xy@}TPYWSE#lyQ4aM9xLvC2UcL90!9^m@opZb;Fk
z4TIFbT_F%b3(qbtE?kk#7FA3EmBE@qLOOvOim816at(%u+y{avr<h=kVL4I187>n0
zH<iHLQRkkfi3}&E-x{2q<0#xt%n^Fqts>D)UK}Jb1;#nvGfsfRu?tNyS?(%7W2r^>
zP<M>c%H;E7&)Gd=WxQOQySksz!fT#Ar(1T{lsXve5dB1KzJq80r-Y(GMkOp@^I`DV
zgs*6qQ`pJCs8q)@BYCu|x@ji(s#6-z1aPlm7UlTuD2`B-40|SZjbONes*mQ9l_ZyI
z81G1jb+KiXsx(33QKBlJ-;y|kuSm`a6SeU6b5Y%Uq(LF%t^1N22(kLbt14}o0Tr#i
zxVLelX!EVXQOzd;7tx+`)!y01OpGJg=$Oxl@H)eFJ5U*C<B_?oA*edzHes^na(Z>7
z3@SR|ZDKWw<;-jZomdpL@&AUHg~3UPvEp2Rhx9v}J((1MMux!5onNKTy+dHH*Q~H>
zqJ`ZZ#<k*<HkdUCqX&WdNR9=B5IGTTe=A;DMM<X|t`z591J;o6SClB`@%ldX$+H2a
z?GxuJ<#;u3cqJ3`)v5RQEeZD?DD~Jevj)28W<3%N0Fi#^QJ=5?>-cprJ(;8q+F%<k
zsG-6@MO%5=Ho!M5!uA4pk@+&Sv5oZ<?mae~8FbL0+#7Ljb&8@8GTgbVeP9?YC1d}(
z9rqU>e2NA$gMDSW_V@P@A>Cv0RnamJ4a%v1aJd1|(1?vlR*XnT-(IlT1^yx+MEtsT
zb%sd`^vzH|H1#akVgL;?r8`XT1zR58!pIV(OY*(U9yf1-o-89I%_b5vB%BJ~!hH8u
z0g1bni7z>8?f2qeW~&N)i=W4zi+xqcEFVAExenQvSo~sFw~_7JcYa~Hw@X}-{xuQT
z1Z@45Z?Cv%RDCJH#R_6RZR)4K{eM0#D~5Kcesi-w>Ya?C?RXEEZ?>oIny=?D{isN=
zw7k@_y+h4+JYB?z;^sduv*EG--tc+E@L3n~NBdy2+wTk59IY4$T`>9FLMspEDaEtF
z&>@asS<s(FK&e4emqi{6e!(gP3$;+|e6VPwG26*ai_UZF4%kk>bTsx*7tIGB60(~9
z6t{L5lgSYDr|$)J=OzjdFkX!olGW1|2U>{PQ^f+xjn-SKjknl;m^0oeH*MHYUkXzL
zcxGM07Y9rbV;XKOxeiPD!9O?n`6}!eTl>^v!4veC`#_RMznF~c)mgjjg~W|qf;-q1
zWNZWf2Lfrr8B9PxT672jB&Njg=?@}`L-1Ib)y#hmcL(@`sDW4LH(ZyHliro=Wk|+^
zq9E*a$n#VU(G?VbjJhhP7r)3Cazkb$vfT8ir<Z8&$J7=n^9J3AVuwD~vG|vA#^!OS
z%rEylVfO2DJj|Uh%&D1?v2Rywg2Fa@acr0Ueu6`?xPbWc$4V^Q|NEB?`2OSp-$U0w
zKL^cYuN$V|pjkp+p58a2+6k=%OSlT?U2>rZ6Pv;l1-vfI9Pd&u)*YNt1MevZVrZh~
z7Q`B4FIOH=*Sn$g<SlHA6e6_hQ#s!r23a+M_}vO)s|-mo?b(EaLAedOYZYq2!YB@U
zhNJj(|2OV0CGM=Ym|eII<Wrn`f+~;&>$c^V)#w|)OLo4grD?$hW(@uCi6pXQo2Ian
ztcUtq%#7e{0f@xrBhq}Z^u<7CeeY%pOBERkR*F;~!f(!FB;A%_oYLYlret=|vSMEH
z0fS=B2zmZRV~Ly}h{VNV{ir1t(<KyYE-p1p8}k?Av?XN%*qfIa2#Jl17b{;BceWnR
z0O$?Np<ztWjztR2#j*0`#Y&i^TFYZwiAx#oJrtLEQrgR#=FS)d)1F|=h&j?!VkjoH
z|B?Xwxdvl~?Bb6zrxhW*638{XTm1F&k|Q76wiA{bj_qJ>zude*HC#PR+R(v0oEm<r
zUk&%7X5*QsCAnRQ@@2zU&A$OHA<#}sm)2a!#U7$^9*a%6DPjzPklL>0ApRdm_Tmci
z!FJ>q1lMjy?$@ace%??a(;_{KX64}HA!HNzD|+pu#p`D`0ed0vVHlZJ{XVQQjqV0!
zWMZy?i%`s{>}a8`hGbW(g{taL)}qt^Et2_`f1h`DZW4v>zycsSE`;SGjZ@rV>@Q|@
zd1VvPS7nG0`%0ccs)?U|oS+<q&kYxev3$K<3&eH5QBH}f2iHmu@#h|ok4{gGj%TCq
zPmP{<J3Dy3*MfO`uldXu5{SEn{Y{N&_E?*%kM;0mz#ee^pBS8DN7s`W``OW_f$ztT
z{idLNs$%bF$a-q5y*K?Jy~1JEY0Kc1?4KLBAxqe<XO<RcB~WZ3Fv;&00Yt@uWdcu+
zf_TX+E)RjsUjpfR<};>bh1n3Pw&Q^p^%iC75ay|YC-EXYT0%P7T7$L7uf3s_SlZjI
zZI$5Q#!0Lx&SpZLiVs=sR4uA^cS)V5a38(N@tp7)7$YOGBv-VD86Qr#Oz@pm{U8l<
zBBNZx$VjOAG0=k2!4vM-RmE6^@sdj%V|Z<AdQT%K3*T3J_X&>#xXoS0VKI|H2Cb~5
z94mFlPWq0Gyjz(SdT_Mq;CqiEN7UTJ*moEdO`ga|)F8XmhYs>7CW}dB&`xCi;f*5&
z<q~EU=5RF=yYCz7Gg!iUgd4|Kt3rwK6!e-ymwWc-96)2%FyabcVc~Y+uN}10f)ORM
z(e5}&HN>uDw<tSL*<E1DyqYStXdVoT09&ld4lW^H!?8>nV3R6bjg1Wqp#oe3m>2Dg
zlyE;XqWt)PLTiet$q{A}Rhq2_tI0?-q1%n@X}Gb)HmQgDw)%ST&xq=#C)`Sm$l|iX
zb2mM?@{_7X%O!@KuMs5;9i|r$G+nu9?x>9hwfOX!3plvl+1T}{BMb>zJywROSQ!m5
zw>t4|;5Ocnas1Vai&D!`p=EG@m9yyo%t+TW3elUVyv#MLZ}g}8m`S{Z&x;~qrUyb2
zWV7z7mI$u6yY+i!@G$EdhPF1=f!wDRD(5Lc#)43o+%EK7<@AZ{s%0hIzPF{=JRDlu
zfc)b@hqR~~#k$2R6bg3I_%_0Gq57{^D+!L)RNdF$tf0W057m=IeWt~0gQF}s<#fQ*
z1hkd7xW-!8B*ePW?(E*OA|Ls#b~-*tfG~HMQK_6faW7d&Vk!h#H=ABT(dIA_QLsU9
zZYB8fXtI(P?-t4GuLgk_@>`%XG9`69H&{{cwk=U&RfFT0^mYT8%8Y^<-PRtNHodw;
z#Fz&4a{n964f8+7G-iDhkNzfPUrpf+3>B$^N8FG4(ZYqfyX<af7gf}v6!Wzz4>7FQ
zvuEJk8a{{+aXh0VZ&%Ko$Sy$CLm`pi*b6;2n;WntHioyeb4%4JNWe>HiHDBmg%dR(
zpfES9I<Er(9m0G%BoS_T+>5UEA`D#6NV8fdSFEz^zP)vAuRW#^MLat9_?ElUcuJtr
zmK5R<;1k0!WAxi85H32({PxIFE>h%4F%ZRzS=0WV+%+JP3}d1qpbr*sj~Mc{JM2jT
z3R_g8B>E4*i$ws4qK~TPj40StlpcYBUGzJ~xU<_5nT;`*nC9vPfl=3UyR&U)KU#U^
zgq-BI6A7zJwJWn!W1_ZGn7;?JBt%gWvB@iKowg9iHY_Me0h|%sRiis@fhiM*3)Mn6
z50=X7Rlr%76cQGTd=iJYNuTbyNn&;U`us|Xp7CGpYQHjYwHV+1`}3)z6-#@&oCN;o
z?7<#>;{~z(a@4$#w^6=}6}>ig7}+gCJD?kdvsA?;qlR~n+*Fj(n81KX6z`A{8d013
z3286)PA2%xV<CH9Pb-LJuDKslEHj~Nc7Cb0xO{k_%ay2ugf4fumI+;N9VCjF{8@NV
zAV8*X(%Age9O(cVwZ`TUyEecztRjW_bAWJtL&fO)GjU;|RTo3QWCY5<;QYk{Jau6T
zxy>cgDAt=yA{&CT>f9F}d)sM+-uC)slx7tz1LNOleB{!McW^N|v=3{|=du;i&nNPg
z;#OvTGm8sX^VNkDv?=5WgR4cjL~o7F!*X22&6gv78U~DqWkRqvYYQOeE;jhdZ0-Fh
zB<uS-&Bk3(jbX^hJOqJo-)}Z6k(XbwhW%ck0|aL3+L+Ynp#<5;9+L9sC@32V{FhhA
zrHYYI3VY<?gj~_4qsX{_U<4k2U~urSA`18mKYy7$^FSOd1&;h#*~31boNS&!ubT!1
zky{eYJEXLS@UX)?x<|N(TW#Rm2!NP}@J08&kcYPHPx@g>&f2?(Q>KKa*Y}XiB3l`F
zfNx;z(&zW8&sKV0;LCXFQ--HuB(k2b;H?<6O!=WTyToD2PiVr(V5{uD7q=YzrmX*Q
zgpu9N_QZe@9M|6csuk%P94MPzQY^H>MQ)I?dQH|+cc7pOl+EI<z;oEGf2zOUk?-ZF
z@8~D}dS1Wjuk1YW%s$X}G*J1<%*R9co$Q11xv`Q$WzWIY$^a6*O)G8?i@#C`)ClTP
zqU$mnBNRpnu9BBZ954mt39(1nIs!~wEv%r-3IF)FBhrPZ0zVtleNlSmC3AEHyF>x$
zaz}^pOX@Lo^}a68q!3Mt)?ip;+Nf2%8IJ9j{mR`JnPxD>MsNz79Rz=Z_@fh9QBec;
zJaNX3^5`zSSmP$Ty{x*VN#H$2CX4<pw{uQVJHvD&#POn@6zxIb@dAk$XRPQ=`Mpao
z{AKp#2cIgsDZlhTKNO|)XmSgO^oKiI%@2!YHdZe}P_}o;TmzOQd-pbvrixxdn2F*!
zSuw5A<RFIw6s~33nV~Z%d5{f%duw>F7oOf5G;|(=_dcZZSwLke4%@{?uVs8rPluX~
z{lIeIf3R0@_~X~@BC!n3&ga+or-!;mXPA~$?YP@iG2_T96}T*kPzoit<fu^KhJ43M
zV7xeJCT&OJ;c+K!XaM;VH<+Ezj%!_dKgnBlvlAZI`aJ!5zYtrf#%k&o_Q+{dKOGhl
z{5-r)xEB|2K0#Q?o-G*OIoKf?MX{FieoSLnJmZqb3JlVj67FGOC{NsRJ-j?lU4|d(
z@9E{S6Xi<z<NvlnAIbb4w3tKSFAfEPKQu>+)&KLXzs5&`x&jo65V-SO<iozUEJx9e
z9V}^eS$4=-AysVPU6G8;0dyy*OCFtTK_uAy*UY{q6Yzz`x;+4z#xG8fiP2+aBuKVt
z(rx~Xw^(N?K`O8lv+@gW@1y9hzZfseWN-|~mXymY+1BnhSku7Fev%q4G_veaW!{*j
z-Cvf>j=yxm6<NSJJip_}b%Cd+Q_vdYrq^K1#MF0sP*6QXtt?b+FQ9VuhX|(q&;G>l
zWt*)S1|3X~pnLJWeSpb~qlnoH8yo(nvu4Uy*t>*ah9)l|uD~LRs$Z*g3&BMB^$bhc
zJqf{&%wNxl5n!7^L&7a)gnt=#jUrnhCP!!Ur83w56p_Ya>IxAhzsSC3dd@&V<UcOc
zcf3T26{0(1qL;DJ;?<=r9MSP83OQJXM1!O6P(JV#ZnKcPHHnlhJA(Py^^0Y4P2Pwr
z2*TL#5)q;kd>_FWlcc>h?-_Y`hy__^oi+v(D@apjxwRMNDH8x->TP*`>a=h9GxK<#
z<9oe>5?bk0{b5drkoTBm&jhq+6%XG0bG;jhZ><!=rh3SIF;t3aLg}68#}DthC?nB1
zLa7M(#N!6W&zn!m!aNI*{8tYJ$)4+B*@;neZ#$DNDBlp0Bu_&9iM^Y}rrqR5f(sm)
zBaaLQI0TbAijO_u1M#(A^MWwmlX?Vlnyb3Ouvo1eLm!(vUZq&Wg!eHztT&M~@(*sd
zI`#Cp1K5F2pc%jYWH?xXp!r#lf^MH5pqA0XC*Ct4`ce#SUG-vsfA&z|bHSttdwkK0
z134Xt#M}j0aV596hQuA9Wp|s0)y*1f+|i2#R-c7CIyIA`B0^>mazs*TVXUtLA(83q
zZ%`<Rr|u`Bqo>K5(5Mo+#U`R=;~Jblsewf!#l7@p)eZ&bZBM|=L@)Wl$B4&Q&Mr%_
zHVT>2VfP68JRCiYFG{#7TyE@e(tbpW_)Z8(@`)lH%!5azUiai{%hVFhfqNNSp7@yo
zJGz<$Rt8xA(}#j}udMKl>@7|zd*qhf)Y9+aM7}gBbWINeV9T_qJd)lA+6@iXpRHse
zaXSfvPTP)%NS~QT{WSreQZo5pMaZ$jS_yKVe8A@lL;9mK0nyDg_N1`~Yg!^yP8Nw^
zaOEb-;%I)xVhP?7krYu3T$DH)c{o!(B+hl{X5@9AC4;8XR(3wj7sv8V3rXv!&<YN?
zEyC($L5Fc`RE4a;BQf?|YbzQ;F>MxJZ{PZIWINJAkkWwhwlz`2hdci*dE4FpPRMze
znnDX06*oGYQMnkJkSkaw1BPm~ap^;Q{xli_r6qcz+8L*t_#rtoS6!9XPK=F$4~(Yz
ztB&tFk@7GK``jNMx}WjX(_KkD8(gtPsrY4HYug>P2|GqApTMUtOX5gjNRX=({{Cx&
zzpp%?qWYZ09t9Bm3+nvu2ZDt#Bqvvi9mOQxsG>V0QnKe3_NLg%cr)@730{B|<VyOk
z-iMDRN@BwF(P;|RD9~fV_~~6dtKd6O4!ghp`7qKt#KDgM3$uY?eO6#7z(D^>ECkHH
zFFf}I9uzA67wWJF^K^Oy^26q&3SJN-!B0|+_^FW1;oLgDh$$pE#B>%=MbMH#Zyb)u
zU`=5Q%|6pAVg^h&!}K&3Wk+_2024_Jqw9#?4MLBZcS3HB$f7r)sOj<tV+OwkF{MXJ
zh*d#+IzO7cZLWg$>Z;{ORIEW$xQxEnzSiw*nMpC?c8KdS`6XBOB-$j6kne*!%MbOf
z<_^_0twCg_G|1PC&#gx&LUIjPlqgx4kMbKnFn(5V5>BB6M6f_Ah6fs;Bq|G;!z!7t
zr$?3lYjr%Km{Eby$LmO;^+nio*zVc-#h%kEB9=}qSO-B{zw*70u$1U~L3#z9suKAj
zg$}Pl^8*Q}<7SoeI_H7h<5A{@2wJcEgU#+@hARzC3CHW_h0_xgi2@IAr2d5XA-9r=
zCKVK@8wN!0h|M3mx>o<2siqALBd5djnr*R>ODd(qOWasMwrs|DT(C%sDAlt<t$fvH
zGMg%GTp05mi(t!8o>;5le?9*)6rxl}^>WmeU1_vu%P4hW5scx*n=a?4A=ju9nZ|@0
zpRX(+;Dz^bB-L4Gm)jb}b@JklGDfjX+YmuDCo&0E&tqgN?4j&`R$^1x_XZ?ICV2>6
zQJ{vOi7EVQu%>9K{A)$teog)NWsbk%)c?;+<R?NPyt)zS|DPWq@w+k3-coX7T;O1l
z3Kuv4;nG&xDlvg^C<y@rjXP3w%pZmzA`(D2IsUpBDIz2YgllMQg9k~%KG6brBlkuL
zA1Lq(V;6FL9G+X;$QjRY0)ixj9$sWE<?w%DcP#7cf*w){SNvxOT(K*4nOJ<Vx0-kt
zZ`e}oU7aHUe@j(xT}2PE^ZaIS%0&JCWF=R0b=e^v2vb2ZYgBDA67$_$e^fSWy!v~U
z%=gWelly<e<gl{j|0ymyCI2g)U`6f+9)_d9IEu8=|HCg-E1a6YK0UQm<MY}FQ`5`#
z^9>xFrLb~TI2xMF(XaG9q$y&^>gTTryTf*6%1+F4-B;O}_!pq<$e5;^`s;Z<F=01H
z_o(hn97f;K=7*v0Xq-}N=&$+kY@o#HKnwrD0kqK79jkQgl>sGIM@pER;}u3#r`)Gh
zGJjsH&mJ$!=$_{Ip-{VTL4iyFN8lz1uih?33dm(~bQ{{QhOGQ+!wfdvY+qXSFMw2G
zDEd_*RS##k`qdWApFD12+t;bao}PFq#9sX4?0K`v_a~tLqrH7Z7JA{2Yguir&4!BU
z7J@H`U&C{V)zE~q!Z&jEU@!a{YCD9_`^CJ0;YC)QulU3TlBII%ABQq$_X*&-pPl4?
zihvEaJTtVIiWnRr4Wwvt4UdwVQCvQ6ysP9{M{Dt0Jx03H;2gPZuyJ+?FQU6;l*&az
z+^Sng*C$gAkC(Djldqh5^-aDWBLiO%EP5-Bh<aEI5s`Nqtx4jWAn0XG?#VTSo#!5W
z8Xov50M0*r7{Kv5d<DRX(Oto!Q~;hr7+P;52au!l9R&F@=gnll%5}t<OxXTw1Ok#2
z_X2}|&%l7dU3VzwuO$8AVSvCNPPPbgH(I)fxp4Q<+S{x1iDooJN`kvsWt{U)LsRNi
zk2<(*2dM(|Bh;P8sa&-OMrn;|SDQn78*I-D3_8str(Wq+E}DroAw#!wbLXz?o_TFP
z*S|_an%ySq$61}LxDt&cohV#0mb%j%TGHT+B%Ey)Vys9fQEE>s$DEQo-FLUPFzND@
z-1N3}w>dLp@u_o-J-FWd4yBVAZzz)JGa`uU8Qr$Q{U3mVrQIaGoJWjbxAVZqTYPQJ
z;X@v4c9TbIxn;rTA`71pIW=BiFU+ede>SZ(3PB4B0uQV43l7^Xr;`7xp~tr#d>Wo2
zTMbW<6{zL^oqgTd>|o87e^SP1JzCf3rRU5LSwUI+^@$d-T$JP}uAg$MoCVf>`AI_f
zV2Z?e-NPG0cp>`_F_3Q0$H;Hh?@@AMN2^6Jv``2uvAJU9MM=wp#ZkoJ)(WmE{X4{m
z8U7m4**$3N$d?U>zVYBwf01t0U!*I5&_8<^T3d*6e8te^cXvC83L$W`2tJ_8V5BU#
zl83yiutSR^gbfv^)MHz>$jUlCW~r+iom~~9I6lfNW6WUDV$_A&{t#~cor(v~nzL5-
zT^JJjb+&4pnBrX5c;|3i6*`FhrtmV!Y0Y(BE1H^^_^m88n(N#xYgC_@_*q6-BcO|s
z=7lB{Yohn5iHW!LTDpI+v_)JkV4g4GZ1&ykz3hA0_p={lKh0i5C_J8>$W|HTWxZkZ
z+u83yq|~|m&k7d6kC7kWAy@S6>@3pNC=Df7zMD;E<3l0-fXdSqMjds0;bj;;8462b
z9RB;40Be3|Sn~ol>HH<e0?z!ChryZ4*r*>nW@X1+yHRk4qEo3+Q^XhmtnVSv+yz<J
zixSRBJ_iv6clF1nC&X1HXUKpA0zbY;ogZ)t#o#$X(e%Q#d5Ratk3;M@2vXc;KA<N^
zPvHcgx+MGbm8lQ(H`#Read|9H&4sk+p}^y1<po9evL9c_Br-m1pA@eEq7~z3-M`~P
z!nor3&7U2G22X1)j%5-?xIqggc-JZy#Ep*IMv13E=+tJBiCk6+BZ7*GGxQ=ImMMmO
zrZIKYEGr07`o#AUq?p1X7ZhUk2pgFsIqD*!h@Y*dw+q{2{@$5(pu8=Ob;{GeLWp&U
zl2K6}OUiU*(^!9sJ0f+jRHzx5Gt8o3zv`ut-n?JI{vR3USaOjv&d~quDVL3gO7z=&
zIuGiY!AjEe?vlGKrj#(uu3qOM&e&o@t3Rp~nu%!pcrYrYUh=V)$C1<LXO}J$(s@n4
zQLSa>`glgYBmS~dsX9NsPCiM<&~iS3$(B5(*gK?Ggd2}l<^1wvr8lzHAeA+?WoKsT
zdw{?OZvoxKia~0gHi8g_%Sm~8!C~cF$@|#itCwMk@kzXK-k7*FJAV>q(0F*;YTWA(
zvb}}H@obL7Gr)0SX7(bRyUGK#w$-b(spWAhg7LB=emHF&QQ_M3^0md9jzIMX_*bu<
z`$oJL&t!IWyF*;su3{q%MMAt!Ms0?)Ge2UhcF5OyaukPbNP);3A?+`7pDci-<Xfa*
z8u2EbyWvS8W$oGff`}I`Go%r8V)bl|mjymdfT@G!&~(_BT;U0c0g~xszIuc#U2i@b
zfZyEI`ID(@A_~O^Gr*Sx1zmzm^5-`#2E-=DenJfLI?4_^ba6PpkbLmBxwE{sAvSue
z>XlySRE%DrF6<~S4>5`DHExk2tzvgJpKtB5;s6nIs33+z+h5ocZp_rkWm&9I2Xb*%
zC5t4F6M*INlt`St!eCVCR;#mCZ-FE!tkv&1Phz?Wuq;g1W`KyeB+rT!LP`*`?J|FW
zhjC8a=v{4jN+pl7SmZV09brQVPO8A5wWf2^-RXm<>iHJS3`ryZno$$t19;45c{MHX
z&-W=x=n3amEW+RPQCFRsuR87w6^4v|K~yZ9WNVbXhY#HzGV=~>GN^Q$JhUe?1>(?V
z)t`286XQjNH>lLM%QQ1#M+yjwKodJsGOxYSqU?ZKevaye0S#Uf*S1Y(D{+#EFv*Ry
z8jHFb&YUtf{DuIOM>*_uNvf-^riseg#D8ZO%R5aHz-oHxbH8_*oKb|A*?-L_EUnt}
zArdtkBBKy{fKD8hLF7wgFtOl+`NQ>4;LchGHjocPu~Vo}_4$f0HE@wYI)BXo4$S~A
z^)rB2t~F8DNFw(o{*&c+{Z9?Ac}2v<jQz^IdzRTZ6yf8k<+@W~FE4r7Y~ShVF>%J^
zkw%x5Tzc}Vl}FYgpq8hBbDLFyIMKWF<gMJK+^*c}@{SOu)l)s+4YZa9xuP`7<*+W#
ziaA%JP~Gqn@1eEV_~^=3fI0LA@7qDG!*^Z_H-4k~G5Q8sX_>NpC}8n?R$Qu6$tsi8
zG4H{d7|c>Xy~~A#<z*f`Jxs5Y0~2lO4Nm4Z;c;*pD@ot8vcv{M+I{HRyS&Ls#r>vD
z<tt2F%A(h@Jv)C@oqflNDv*MVB)l4qru+iSZt#e18X#vXu)F}5#f*nSwn8x*qY#rK
zol1`zhSUYpk#fLz<2Cs@^KT+pyvFCz&8I3GK5+!RvFU6!Tju{-M%jt%LdHWg{Ir}+
z@qZ0x-S@(fl-StmY$XBO57Z@By&Kb$DPgHJ`EHOHL&5*@k_FXgtvg~sdt)`6OF5nR
zzl=^$CSTgher57K_Qi5hU7S;gT+WVlkyAxZO9XbM+l2O1A;mTDNz`uA0af)#T*Lu9
z0h23FePcRGhr#f;nqeoSu&mrpb;^SS3rB~h6BXN7zsaHy4vN$)8l~rExY@%)`jM%m
z<h!p1U^hx*=S8ZVzKDS^`4^<!coGlLg2tNw&9vMx>ub-#O@j7&yrNJ&W8i@mVfNyx
zJSqEG5uA^FOMJxB|7I^vnD-@JD<B?UB~~)P1UHX{)#5O7odg-5Iqfo!Due4-zFWy=
zFO~&CadFF+Yx59mv##|&TFYy8<{RAO+o9+PS|14xm{n3;pjhFYmqu|E8EUw55Za2`
zE(234uC4B0s>r^Tn<`ai*%a3i@;ygJFxlWTfW%2VFZtw&%7_%)30@x8HB|ZCdY3dE
z9PV-NEVSdllL0VU&P}QiMrt^UU7bbeA4R)g^(#FT4xW?~TLTHVe%a?`DrvQ4povpE
z=-#VQ_x{B`O6jy&x_(12>JfZVagVBhdR8bTq7EqTP$8;*Td84xr&{SQ0cf)*H|w+1
z&P*Ed60l@AJ?01L>~OE7p<zB*_E(;7$pGQ@M@#vMW1-wKvIu5whtk9K>5hkjH{9kA
z^jy1}G~^xk9eaY1*IC@Tw*}ucG%)!{qJw?r@1<eqhUs0F6uDxx-N?VPEN%%g_p7gn
za+dv}(D|jZ9<)V5EbGB%7v~m`&E&n|b+(0TGQapQRuz(;2mef8o?6US+FDE|qs?^%
zcgNqO+i9?yYBp=|J^y^dIypXzMWB)D)uo+>li^$_eq75|CT<{ks`XLn97B8~U|)pV
zTNt0VtcFp}GW@f1+3Tm@uxa<}6CVhTeO{Uzb8wU`%RYo-{AQ)5a`6FB(>FNpUOi3e
z%u=lVk0RDC*5;?K)N)hOepu_C9g{sSn{ClMBQ^Ay$%2{7qXx{#1GA2`(quVHxHgGh
zkfm@$oe%SpbLng0tk7&<Q&X@sVO&=3TdA$dA7}{X$tYe&OB2GO66!Qhr?sI{Mi2zO
zh?6fPX5)qBSaw_-#&DgxKcdWIIDEDukRCYJWVc$4b}JSd$Uw-P5g3dNwqqOKP5?d>
z$tQX{Da|MAU4BME%2{o;Z&LX{@4Aw@%#*kJy&MQ17!ZCf7N4G7S}2s${6`NL>fz<A
ztURjA#c&ep2U<;Ktk)s_TQwcFn}@1J{ka53?GaNM^Fwivy5|t=c62Uy>n6Zu$r?i-
zQ$Gk~DtNXEx#`Bi?7go&99q@?(=LrzMl6+!Jd1NFuRr+@AMVP$5T#kBe`w@{$<ZeC
zf@r$1-cpnvq2mv_AgYRz99O_YUaj_oiX%#+1DQ>PvbU0;KK+UWQrs+WZRlf*hXY`X
zRU5%(7x?l>2MO-|qY$I9LxO>33y-nds)oh>%fThqRE!tk2?qU38zQ*8*#j;HBEcVN
zKf8<>FVF4yWAlx>dnhws{APrpD^ttUmyZrX1!dT-<FF9KGejHf^=+Qd3h_MS6zNPs
zJnr0sY039h4}?E<DFna}@gjclE&#O*7*HFP2(#{o8D6tglDQ3wig_tKShQ<3d2-0Y
z1$rA3n}HE2mxM~-t5fuk!UNMF(fybD*^D^tgd_4=8z$&Mw_@eyAy5mL(g1LsMmqE=
z@$nKrSArF_nn8kPl``VBXJaqzblNWgcp{XsLYj9P09(gh(U7tEclUzT<(x&$FHhku
zFVee*WKkYWW?8zP?jIoQu<#lv9zkVJ^a@vf0vNpKb<=><sI%nyXg{?>-6;^fFt9+#
zVI4nS0C>Cjf?}(I+*=7~`j?PJ(Z77MLNvy>eHCI%89xST_yrwNVnU+9e7X;4V!8`=
zHrQ%-%=B~*bu5}a4L0*j&c>{)_+Fs)ZyBhO7fdp1&Qt&F;dpAnJm~Sxz{Q^IbnnW}
zg&1h~X^a9AWJOWMqcyx_BMLLLkL&G)fgXN(F^&STDe@;LhoJ~E1=RpL9x6aaD=&L2
z$YV7U@_BP8uY0`btn#t(f1&Vkfa>a(dRH?Petk@`JBGnT8M#Lf9UF#nDT4M!fHbLi
zW`8ZxG<#S~Xd57~m<$t>Km#S5EU@iT$^47|qroCZoon;6KfYFYtKb(82acY#UeFl5
zsKDVMGL}A3MtTt-FNMoH80vb1&H6!3!9M^U2-?M8ggI8p?}}uwiY;;~JGC1CIC=zq
z0+=@_M~lVa1{nn0MCSAwECNKV{$i>30rq;=#7%lf5X)L&j|&(gd{R2WP=FI!Nj7}s
z*?z0T15QSdcJETy45cI}6(#^pWl4JywjLHnpL*0_l&6bIUQv0dECB~n%M!R`ddT2&
zDz1jWV0FcV%;a>|Szq5JCoBe70a`nEd5<!0UZ9Pb90!=z851H0K7Ivj>`B%nI15sq
z(MWsDB{1GKrE}D`@A;qvj1NOe)EF2a2NsmeeepRL)(71iY<VWrV=e;&yfQQ;_MHMX
zEOOo4J(sRy;C+_-8SNxdsz#oy!#z*Ilv2m1jv3@V_2AQF_*(jteT>}>UltHOtu^O1
z6OR)#YGE$8O?w2^DF^lVw<+ZjpMxztDt(b4%A(mtaeZ)Rf9A#ZAU6Zs3GdEAV~8WY
z=i9URK#R2mMy(oDiYwe9xS%bPr!WJ_#WrUQ6VrPQFdZv?Wp$~xP<s#*&3b;O65hAu
zcN*PPyW4d__8OF%l0BNhFy7N!SD+YzCx>8E4gXY!wc&i^T`$s*np<c=X$OT(t~Kl-
zRXZfsn~r82!W+^mG$q8P?$L)6IBH_Rpvxxq=<J7$#uhN?cJyL!Al|!LMfSl!r9G(9
zoTqhOUM8%T^N1Y_!MJ7#G(%YE$bz;Tw|24na{m5;nNG-N&)>Z8yUH(-GqE#mtnXST
zDuAH~`2K)TJG2Xx_w5zn!tp>JJT_!Qxo4skl<VZf_0E>3U`g0VMu$e}MGdKy!O;Sg
zsFqn_CAYDj6j@?~qI4}?WH83YxTahdZLWCtsd<A2a_Z;(LiMrmI;-LcZINN+etBWX
zcb)m#M#X;ZUE`i*cH*qMIF((E>M^_q*l%!^Q0hFU)PjU_sL*UWk$mH<Cw~YNA`qUj
z%^PT)l-iYU&KWma0C@?x5j#Iq0pnC)4P1&3o%BsFW!=!0^lrQG?X@P)f^Rp$j}2gy
zQN}A;9~Ze@1nB}CA=a`uJYbv9{4yi|Q|}m^sy_I1d2#mArP|`sA7>*EM1U01{l{eq
zb8g|cz(RPs7aCIIERFzZgrM|hcdKO&TC+-wUbm<d=>~j%<2YyrSV443_Uv(eL%<l#
z=5WEzwuR;Ef?YO)I51kCOouaT4f7s2<#ul=9R(Fcc*iJ`*(7$TZ&XiAJk|$llTS*9
zQ)uX)$L7Ohn!H@vdtfUBp{F-S)9yn6>J6UI5%<)e-frr(5)1#{Nc###|6ynpT<~*&
zg?4Xu?xssj^{sk7wG)naryPV;p23Ljslk?p^{e)<X(?#lG0-I5HL=jYe-LbXGH2ld
zG&``=zZ^29eM9j~xF@n(z<{4NA@%U0j4cMtR<x3qL}99T;*kZ<&H2e2@1)tyaC&}t
zLC0C~I@2uKTJzSb3rOW;;v>5Yl)a_e^fiiGV11awuU%XE#o?~RELxt5ZU@jm%;3#*
z;d3N?@Dg^b-j!H^Q^SZas2VXj9-MI)BMWOPTo-sR22;1YlSYlMMJhW3b=LI`IH}FU
zl7M-uGW;pu*ia?{55HBsxOh0L;c$fOr8wk|b6e!aTy6P~K3q=+Ff6)c%8tJtUE;%y
zFC6DoGzTdYjP!*Zvv|D`?Z7hW&b?Ux!^1Cf_J}GVEeFScLNLO<BA9&c5&ho|cjU)X
z5FB(WtEbDa=)W}7B41;A;p+9=$$oIYhM7$Kg4DIJ<;Z|dwv*hG-%3G#?QxhRA@$vh
z2fc&{7%(i<C<vwqoXhSoFT7rlg#=z6nJ3P1(NY+@a=7jxrpSVVymK91F3~1>;TdXN
zzI4+#Boje><CP({3?+UG{4nU~JE(&|gD7I&ddhv~dqL2nm674BQ&cH>&$+#Og_|>e
zI_Z!k1xdf3p5)vtZ=@Wy{={JGG3+06i@zT#rV)Q#`YOe=#akKHPaD=NP@8^(q*+LP
zf%i(VC(Mzmw5!PH#aJ4_rQgm?&Rgy5IX@H^NH*C^E)Ysj(syq2H@=&i4v#QDgOtS%
zR^}IOXdA<#!_P!IOf>OYYrFj1|J2T16}oXR%+6o4ry2hAP#0jFGQWW00O=+`%2s_H
zo~UC}@G;-;pkf<0wNwva1fw8D0W6rsign)9GacJm=PtHi9;uKDHN2Dlrk`}rQez_h
zu#WvZg=6p8?C2HJFVBx+y5!8srZVHAj5IC<fWFpX#HCH6Na~NbR$w@a4|=rp4xj$M
z-67%Dwdu<Xe{iU~>q8!OOm`MwAEmfItquZ>f}HEXm`BJBD-vx~X_%+!{lmMpFBR}Z
zD;?HNeW`F$4S=oubYHa7CFuo5edX%%&ks1?f?qUfoS?RMO()!g6$T8B2p(-vM1$%x
zmCpwgp7%2i3mY~LyihpVu(i?4ySLvJ@ax|};189)9~$<5YPX|Q!`hYE=><YP|Na3N
z<gry|74X<9(caWM-4THa<hI82BxPyzk}fmiH9O=g4NE?Mt^np~Jwq8CnIb92FasU}
zXp)f9X+v@h`ua(cqqs-H;0qDm9_c4VMhfDC9?F9$HZa%lC<KIOny^yX0QuE=>cHE`
zAtMr+;$KCe!5oxUS^jYF)4y#ukKH;|`M_@d<O4qCHp>ME_a__ebAPg3eJm2Pl<q!J
z!0tT^TDW(i(ujo3bqJt^(7TNgvRoa3{Dp^rhXn@#HBB7I_ckm*c)oy|`M%0Y-`}<)
zMkt$_oBREP)MwAsumCvE)G#fRo`c6KVL)kk(Qh6Mkzy{vG^U6(na9daZ7!0zQO-p7
z5clrmHVAtitB8L(zmkM5tGyfa8g*3d;ake8Ag@e|>~~l<mDrQ)S)4@q9sRp@N3bV*
z3V7+~2VIksKf9(NyJ^|pdGMxm0hYJ7*HL00j)&<MWT{X^%c$u}Jyy-!a~*pQkA{9X
zTtnE8nJeQgW^MFmT80ou_H4u>-Hsm-LCahQlAT!)!?ER3Uitm~J-a^`n2Ic1n8HwX
zpzZL7x&Gs!rUrSb|KKeijBl)x*Rb|Px#3+989%+N9Tv7Ex~BU`N_qL2|1WmtxDw)-
z9q3AMucvX2SywrQHL?3=J@FS!@r;X&)DW{_h$3=gIK0FEPT%3Da|+giVckVc0x>*D
z+vCtzPnBNCGf&xtC?jxwruIQ?>5m?QiUlD~_YryzUWWj?hwz&|YAP0S2e^|7A#CCR
z{)o@<7~aMOXU^VW#`VCzfY6~%&L+Z5NSm^r<K*X<Z#0BeFr%a*_X^etnYH&vtm*JB
z^jqOVKTcb}ub*b8YfGUL*AOUO%nr5Nv<)=6<=6O3;TpAu&wh=zgJ>K~;@GdRapE)m
zvCORgYiwecDZj>xc8%D1lWBTYX;puI5K<0U<Big%K_)cFAa3r#oID;#e(c~k4R6b<
zd2X1%-q78_V252+$fqwYTp&afrG~>pIZ5ZDHEC!QD~3fmzh0Ce(iD3b<e#~07u6TK
zbAVHPAhoFXlFIMLg=r2oEh%}&i4pA=`Gy#^^_6hi35b@4b<)uaXH+fURyjueO*?3!
znWGQe5aQ218$!e}_QeO37}snJu7v}x!r)yK6%?R<o^rHo5rXm_*?Cw;-y=Hj<I8>K
zU$tX@LdQ-mzdt<axChmHZNd7MgZ2J8DCdmrqErPP9yxg`9JH-+SO@%-A{8;8RykPz
zT{~a-%C9d`r;9o({xtK!zVbmAjE>re;l#r*<)@yAi2<=$ScuMykk+H6_o|Y^JN4fP
zrydrZLQ|GLANA19Nac6%-`X9Z|HVoJ2kU<|)Bi?PZ=jYdBdPxZryjDoH}U|$;hk&L
z?$TO@1<^g)U5Z>RKheLk6GfSzOzqO_!u)|!=zF<7?e!as^o8DorwODsh~vWC0fiu0
zOOC8Mamzay6Jt`1f=GQG35)P~!mK+A9+ek|u+t$%bjWciybDVm)?xQZiqypEvcvMD
z{>OII7zk%(Fc2Plz^}hw7K!JtJbYIW>p{a^9u2VCsETyF)ut*Ves(O=yKAa_6r?wC
zJpu@M(tw;^4!IRvxRY43ugNi}15Z^q&nmR!bY)~Bn^6}<;YQJM+zm9UlHo=}mljQz
ziCw7Cap*3uYnCgWjpj`PcG4`;+RbaAmBqTn@aj0JN#Qe<%hW9AP}91lC8_`idy%s|
zylx5GxA>D#?NcCzMLYx=5khF;H0Y%st7t|x#itRpa8bJMNA*pjkAvRYQ2|yh%1rPU
zGwsJpsL?kog$)RD^N2({(C<}7SlId4KAvbcx^){rRd@2%#@cB0+r5p_hIyc14e-Ig
zJ7O*XOG0+H0yun6OIkU7>c+SRum%KB?eu^D8sC2-d{1;#eRaLFfiLDZG07{h@ZHzK
zcebGL`I|Rz8u+3F6&EX46qenktgF1sxI1(rI&mt`4Z3#lWbm-CK+eKCId@ONCS)Wz
zC9*CqYb?nojH%Kx;X)*IZ#375^2D;8+(Vv7oA;w!V(7ZlXi*7S*Desy)yv-s#mH;M
zQlz;_4QEoj+v}>>Y%lfXo)L?n4%n(irdhP<%aw&T$>rLwg`3Bav_0=TK_rW(O06kY
zx}u<iDVE-x^Z8-`(hzIoDZh@ZbO8i64L#H!0$3N^jAPW-Y7|iu0G{KwTBcFc=Mb#M
zC?`pzelN({X6Gt8FEv+WcpTZ$PUe2p!49~hX)F>S5o0q%g?m9~EiG1Y#^@6#_ON&r
zvEm+C+_qu$WVWm%DDD_kBBUL(1;qhEDi1lyC+)yOsI=4w_AbGsm_A^R9(-$sJ%hTc
zWo&GBwzkwUSdX8r1mhDAF<GX`9+A+`cp1j8s7MhduWPGULW$nL*oOjpEVLOgFW4C#
ziURutkp*^*eTmEgT$lK6oa_o<@&eqDo7{_BXUE|VCp5?wKA&yis6f2I%?J|?pg?~j
zGNMQ6R09zYuAX3ra{NOXs#Ytpn*qvE?Ot-`5&awvAPzktvOuJ#|Ks7yD<0w99ggT&
z7907clK}lMGrMq$jXcbSdw}s1V!8fsK?paD5Wn5nB&pH^b8<~GZZzvyeCqHdL#T9E
zfR9XR5E0m+h%BXNb~>J!*Ghi~Br(DIA&|r;_*{|Xy@VuARu796@j8cz5@EY>=>MNk
z;<jCHj|=Cy2jUHVH1V&>#L;(6;J5g-cTIr`Xg=W2iPgggXp$6D!yU2)2yBFD#K#}v
zxfo?~6<~N+^gZH+`_~#C@rh+^hnA7}U9pK0!EdcoCpgyRKBSCS_Goo-x4V7v)<*Ya
z5JkHu>pMty-mes4{{y>Gj6LSN{lo0=*Xho=uZz@ODqg1z6!8)X_P}aM+@v$(jBAx-
zhqe&&uA~G-54S53hE#Y1JBk)X0F>WxcdLaagC^k&+<_o!ACbXn9Qm3|c7%5s|IZL5
zLK;_Od9YiF2Qrfc_mLA#IOtNt3#{C3w6<)V02Sr|Q?U?@ZK;@pT56Kg0uQx)aFxSg
zndemEPeO@D6!_MhPYN-tnBR)U%eXf_TammMD%K2#gR+yCdw|l9cZU~?dGiB_7>h3t
z!CMu*Y~qYW<q!=Y?#J7&wRX4HlytdfdfVG2Lz0KOdy_{>P%C(70EI-#j7I~x5;JBk
z#`c;54<gIC*#e=|<i(OHNIOI!GBwI)c<n~1CjO=WFw(<leEZ{vMxYZyAP?OMcNoV?
zIF!@F2&2H_RN_V^+5^WZP%1(oJwD_tk_pqqq>b>Fa7^SAU#nzeKloIpC5}B#MHGpE
z-ZiySAy2Ok<MN^GiFu|?>^wZ8`*x-OIN}@**tWb0Cod+{<Yj%|*1dkcGBVIa4=Ks=
zF!FIap-^1=zD_9p>~-lj!tb99MO<P@A-Adr;LSMTKz8N^Wr&N^-`4NugFf~A3;-Dt
z=XyrNtgjq?Q}S2Th*?8oP-qtq(TDAl^puAQj>kf-wkVr&obs{OKsEp?LOC8QY+EB@
z#W#HQuVNJVrnimpiORd&K)F*nk$d|rB{(C#7<$uqyl-8hbax>wpE$}}<5;A8aiM~C
zSYU{16~EY_6wK;I<JNWq!66>ZD>q_v<cJYPKU|t`$R-j@BBAdlQS*uwH$uY=g|N!L
zj+=uWrFfA~<{eM()p30s)1}YIhW1=;C~Dp_EA3hDclvwxFL;lxtaza7VV2CS>*ciY
ze~*%cal?m^B;2w-DnjU%^&YkwRVN2vMZ^^td2Tm@Bwm;OVHXNWvQhx|{Cg}3vM895
zLbebms=cE%cNirp*BSAQ_1&G0jLj5(McUjXD?ph6EP@EV$jGzd2!GOjCz9^#B85#6
z6kf7<`*L_?;Tu`WJ`SZ=?q@UCuFlO)Q`dH7>Bc9N=LI3H!PNBf>`(M^-0ZynXkUij
zybMX90~O6>fLi>879yd6hKktd^mSPDaDU2_hbY@mdo&KTqpvY!?|2U>b<xl1T65#0
z(<Z&yuU&%uM`CdqWTl1(RWBXx>wKornR?q}j)CMmQQ-k2QgN(M55x$J#w}aaHl4Ot
z)1vIxF7{QU3gT~+^)^G7+G&teB|D>+cGEY^YS`ho!eB{Gwn@U`O0oINUyIn>qZjmP
z^`&aww5fTf&U>h9P+fcV0yEhMLr8rGgZi40S!9<wMTzySmJ1-m6DTNz*|QRt4g}d|
z`f?$;C>Li%k$GfTK>xbmUa%-Qiw|XP5#CleNxlkMan6=T?UV8xq%Xe^Z>fjo9_E%j
zAf-_DGMtUmok(+ww>0X2jr*ZH3fbJqMjhb&168cB`pkwbBBO4#wyGN#m{n~pSYM-L
z>6K9eHFq;O6)TK@hXh&aV2*s6kKgp9U!d&J>Y-eT$S#iQp6%P5Mt0=`fy53{SW(v(
z?7IQt3gsL|QUaKMq6b#|Bp?*4rwb~tUjnSaB*y?&dDAn29+hMHj}3n8Wy!f~SLO*F
z+&`7WO*n?zZo*M22l+qrP1*`B5w~w{)<0@)?rxG^wLxiY!)&jVB;U{QE-xhTgjK+x
z8<Y_l)(sRBc>Fb)>`Zwy?U$D#F3zEdFa6;GCt0XO;e|YPlGbzZAcH2#3Hq}&OoY#+
z%LB_@q(>{~Qs>=fTyx0U!Wq2csy(yOxPz)Yyp#Saj_<U}As=+`r<vE!clr7r=X}l1
z85?BOlXIQB$4p<!oPK1?DU+z_<>!NWJdTwPKN{)_0wm;1&fd)FR`Qn&?|c!+`j->c
zH77<xA}cc$Ny-v}1D%!EJI-VRvZyw`H(-c#etC*w!@L=leaw>3<%Lh>PTE5s1csXR
z%w6DKx=wyQ{8YGEZ*5bw)4=r>Zd0bm4Yk{riw?=g{I`wmZF2kal1BpO{v(OJskw;(
zLd7~-_mKBX?n^ww<aFp!@B=!R!4$Pipr5><6zf7o3-ySqZ-PvaDr#)WOTs#qncv;k
zlE6Ycd~U>|U~P;?)-|7fGH3OCm)+XkxWxf=VQm1eEW5qmw>$0CMuYMXpfFGBG&bxZ
zAIW(aE4eD7f~Ral@P`9-7Z<qIF-t2jy(N=b%#Xf%4@Jdoos461Y6k|t?Ar<ShmCtG
zl9ff^XOI*ovDWZPW7Gi_%yUYNV}4qFvc0p5fEH)>DH~SfOmsd?7dji9FoFl;V5wpS
zmTl1wJ3JA`ZD6sad}U{g@+{m>gi<ZPfQ&XK4$(BM#`IGNZ^Wu1HUdKr^lC3eZ2(r=
zx_+un1z5n_u5f_l@CQ1rwt|($3gtDuOiV0SK?QEh5NE9Bc7$$x$CvU@6EB5fMe{Iy
z?ryREhy}KMJlgoVF^>9mIAjnZW{V_ZLC_yN+^jeCfU|Z)U;^^8I`Ke)yLUM!fg{!o
zv|k%r@g@qT@ZSi_(5Pl}{(%|m_l9aUbcjycN-xCbRv0WRsuO-Mw`}#c1n^_kprpR_
zwm=bCy|Y^`oV;&@o&@`!%+}ujgJf9!HIY9k8zF=|{hG-Cn#eb@UlaLX6Zt{W<yVHt
z{~Jc+@jv%iFkI$K(Ifka@?VlD?;2DP6niZgNiIxQV~XFvh-1LO@T7N)2t6w(7!f{C
zx!qNLNjZB8?Q!caGZ6`S1d+X0UZ)U46xrRpxm+eN2bniF-J84|lCFY0oGccvmJ0*_
zW`vU-d*or@#G|0UCpd9?WVoeXdt`!>9_yp)dJ?WaPk8Z_<o3v687~I)JU6|$On8^D
zO}C|)3%K4JLV&XCUKqsws2@ZHXmU_Zu*Gx1I9QVJ*-G0c9ici`5s;dB&!0sKH?Pxm
zGpH%ny$QpN;US%|&aXZ0Krp}OgYPZH#z^p>tjA@T;gT8K`OOw$7!59iq}mtq75$~b
z<ESW7|41It;A0&LJM!I_?cKgbmwV4tZreOhO%ScpRHehvKCZRwHsaY6Clb|EFNTuh
zSUDNnWZa^att}p!X+}f=U*t|xh`I%$q5!*kq{w~G<Mg#(m|a}Hyh>nJjq5Z`{X(U7
z<?7tR^%^<OaV8uH${axJu)2-;#bY*5FW0kDYal6^aY=`1s`7V;!M2*(=6&lWAU-(Z
z8h%o)C!zHf;3aDKc;$8!Xd)^TY{l%#+;(<6MI;Wzm+iWH4X1IjdN!fexrf)d`h0Mn
z=*HL3d~ZuZZ^R-#{a~^|fG2hiDX)8W4FxNDprtS};4)j8>DbvAoY`)PZx-i@3&haU
zHg#DSD73RMd!z6=cWKLJk>Rj58WhyrP?WXQM3hz0GF0W6-biSfJ!BaO8fVZPy|enV
zD7tS->y$Fe0Nhm`rftqu+mdVQw&-z>2hZ2$XiS8OE?$6XkYZ}ARV@#_`V%aiP+2}o
zd7bJn{}09=O00s1afZAHb9n67b7B#miWIy75&0tFGn<+FL<+VDj9XH}DWVM?sOUB(
z5Wg}{cxh4cJ9x7!8UQ1Wp7&B=qv1&(XDDMgGkfuRGUg;mard#m35Z3Y;Kl{e-c(i3
zknN)An2)omnVG>TGTY8X!B2PJ93wM}3s(ml-<KOZI#l|3TOjp?p*~SDD!JE&=3)zl
zFf0Yr-n>{%QIIhjrXOvC8#z1$FK3l)IlG5do!2KxA|P=Jv`@h<#eg%uAFrNuGLd(c
zLvgipbM=<2n{9&)3nDq)6RgI!DQ+f5_AIxtl#4_EPZEa~7O&uJI3WGpy$$BK3El=J
zun|#kWhudSs`uc$1AN|ehF-q|y30H}JZPn6s-@8R3anmG6tGfN^C1b%Jz2T7snQd*
zX1~m^Hfc=<m2-4In3Z$N{b1^tPBRcwu1N$loGnB{E3o*1I^_vx=a<J}>`Tj(sI+9V
zfWsy_2x4T=lt<ip^;XigK_JM)6hxjdo@u%~T96`Yf?Bd?)PH!lr>a}{fwbRYiK?mU
z7LEZew)~F#xt@Myahfb{N>|79j8bLMlhnU03jdDTKfRL|aB)G-Fw{k`TvM@A&dttd
zK)p~o$N+cX_jYVV?dnfh$%^}!srQ}&a_;BhI5)yd3rgjLcVC$Aqx8p}SX*F&iHt3H
z%?X=v7%PWq_z4D|xCck4U~F`X6lD^kv5^IVQy4wb*Stk^-p;=eshz%rx;o!<ErHZ8
z4>_2O!2~;iGEyW6W#vae3>(JvnP`~zI@0cwz)MP=tKDqQ=ggFDH|b%w>AX#H%+EYL
zB7ym63u%?4Q!NyKiN&S|wFEC14vL_>;^EkBwm@2NwjEv%@gmku^@#&fr_EOfu+@37
z2IU}(3f#qTpUIG}r8)C45(x;kOc9|ZZNYH!wJ9Ig-)9d8&pRU&z0ZMs60Kc;r$2bk
zmgC)cId0QY($Q!2O(OpCaJNt$Ba9qrwjHJu!dxRuL=5pr-Yez#;_R9T@lle}!;f}+
z<HTW6@R_4l6jke<3FqS>#Wf7z=lsz}A4wjy@w<Aw*WQRe@wOs+A%GM+_UVeFXCK}B
zS+SFKri+O{I)QxMK}9Oi(LxZGufQc~$|ua#<}WQ@4zfZxltn`A7IP)Z_Hnj%Wdj2$
zniW@wR%oGFY^&91-`cs&63fyyzVfE=|EE<Wa=EscQNwPo_78%K<S-KNv`M`7o|NBP
zVVoRNELjqu3>yr(w5QslOd{*>W%b#L%SxbSJ+m)|MkcwQmn+4k+3<Tyv=?%57HRfl
z$+87%C~);Kula@LZ2sEZ+zmn=CBx>8J`qSvADzO-*GYR}tAG>rmXcg-KhO<)iyIc@
zC$xyFef3E{S@*{AHoHN0p<~1W`l63oGB-F~5Im_5OM=AlS5Bab(1sxtRY;qFGzy8f
z7H3`q(ufwd88YxaEiMb9G3L$C*TmFZKs6*P1=6zyq$Sy6hvC?sI{TaA*dD17_+-i!
zOJ`ZcRBl*N=SInus~k$n`Y{_=UOM{S8haO<j92;>mGZ$>u1;O5EzSN`?OX_yu~__J
zPVSm&NiiLZZuS!9#<ED8Zt>LC&TSJ3gr#noffKit)F0?pyTNmV+aFG57YAy@dTzB$
zq)_ol^i_o1QryLQa`Ne-CWrG{<tJztOs9YDG-Y3$W{$IBJK>L}H)KA0HXdBw?b_V(
z;_L@yJ<Gbi8fO!WVMbD3_#uqp)1_`dO_RM|2`vVe8JC!yJem5PO#NQ1OmU`WU`Y-8
zen`FYtrghrn<)e*FspQ`1jrDAvZXf@y3L<qkHMO7`qY_M#|b=p^-X2-zk2Ge*WI%4
z=IOW2Ks(4!n9M|I>Kk_m+)-CLk*-nSCKN6o3lW4cO|ubUhru+~A((_$^Ar}}y=}i|
zzx~^Unl#47AT8UwmSh#-!&u*BR-=+H_8Vt}YrE?oBC#XdC<MqBZHXCr5l%mZ*;O+D
zG0E41$mHFa8)A2}ahFytigOU(5J1rfzm3!+@^mlBe-=9=nA4l)S~YuVXRn<aKXvL9
zQn07`Glo_1U_plV12I2!cuG27os<qXL%Ua0h>a+S4#Jty3>T7e7~hxlggwM}^8C%h
z&bA9QV|{`^q*r5DVY;1myU|jv=GY!we>)P?i`V7}>0g*Xu!8Da#^+5@eaj?0SGz;^
zq^(Lt;5sa+K?qzdufr>X&vRbe*sJVG!kfEoL^Q&qL;>IW%+yr9;YYpeiDP@X+mXkI
zXBk7YYIAXHN=S4^G<zw}+OZ@4#)D6<Of64e)>G}*mU<p+|7Q>Pda*xD@S50|3tDm9
z%*N#g;yb_u#&iqjc>U-Pasc%kl)u>E8oHRHi2V}FHY=i@%h6We{mj?ks;b5~LlAV>
zv#V7Tg-5Y{v16(>zujqt%u!3RJXx_K_4%in?1(GW5=m;yjTKX?&3ro{DI=++H&(WI
z{3&m!bx>Wk*x84hSUP_H<)!1sL@5xFk7r-U6FQfFK9SA{$taTM;yTjzlarG+EZHtS
zi}8t1*muJ?Uw@aPXKT<{sc&q~^k+<L3V%a<=~`S>^N!N_AW))5Xu1<{?A=E3S^}*B
zU)Rm#?~0!@gOZsbn;arhZnEa>J5|{<KuGyS#VgEC7&owt%zDdc1b3Q+yrx+Zt!(=8
z)FM&ywZ)NztF=XY`$iX!1pDp?hGT7p)rp8pyQQp8x+^vN9`7yPpxunsn-T-Fs!Tek
zo_6StFKIYc#8I>y=W(am*$qxluWf}AW1Y{E#Y5W>7>^~Ace9^0wt0IwWOLig%pR$y
z6}(g#d5^}+9+RodY3s4nG`kAow3<lJ^_H5SsEqs`&1)Zphw0TJ=OuYB3Lh$?U}R))
zKV6OUUS+CetGdSUdatOs)=a{+ivVeCcjiDQ<SmNk3_ND|;0(CBpdjpY4XOe^hpJp;
znB*(ef^AGn_pF?nc<Y8HvB_3Woj&u*tFOKO#+!VIO#%fTtEJ!FMw5KT#JUYLkx&3(
z-=2v%FP_tQQxm^cpZM90V6xd1E0knV91qS^Z*ASKPayvg4v+t2JwNXt{rI>!2@piA
z{GP2>;)ksYBZK5Z8=~IA|6=F5+;bz*0N}(H$blmUElA>l3RRQlHM-Mjk0R%g7{{JG
zGuqJ+51S-y$HGKX1G#t0jGsm~8-1Bnnl6a77r1E;Wr$!_g|`BGv-L@Ka#hVG$n{Bn
zQ_5l>4P!5};FrhTVnn(~q=}}~jlF#C-IvBd5tJ2;V%fT-{LvrX!~|<5hnVGg7=_L=
zj?Rb^Iw=gglMPg~IV8M}c5RarrOheBU3s~{SkjH%tUV;lCMVjns<;BTI0VaT4q>@3
z?Sug7)k>Cf&SUvJF~i)tV9Jy9bDkLq76|V+l57*^g<HD9ixzkX?(=_*S9kBr6@OoJ
z^LS7vPuwRDa3o%$|4aSH-X>^Vvy8N2RTpl!&(51(oLiV$zR$ZomooeD6Hxm=tMvg5
zv=g_e=G4t3aC@1dn~@-s_Ag}ID5ToP?SqkzRkXzF_mK_hAa#HF`qi2~(_t*?v4-?1
z!i2sU>24ys3U<RED>hN(1*>pcBO}sAkT+uk=4-^C^{;*}d@aIR{93=m#NtQ6Y7&2y
z6-8zB3Iiy<fi<NTHvPBL09Jh>eaX8_R*fP@N;UTnz0pQz7mgjAEmKfNlGPEx-C|qR
z_X#pbm3`&3Q_De0ISvolpbnp&7RNG<o$>p!4RIH{nCG{<s8A5R<EtkMF+S*uW)w#2
zA&eb1WTYFWV-$I<fnt!;VjHX9eB86%uD|CjrlMPyxn`1T7KS7Tn4t4EU965l_=$t#
zS^xk&#4BP~FyR-x6PmUyg9tQzvx$3vgLWqZOxyek%?%Qt{UZ@p%Mh`NeS&vG5lju#
zLo0Hnus3Pk-zN9a6(AZ7JXMtJBIuBQ>eIkj3|kV*Ojh%P8Y?a>9;ECW330?8@KPCi
ztFDl`M>rBBGTn0?C4~-}&bv_L#5o@`2Ili{lh+Xk03QWoxT}P53RsyI>Z}#WiiZs?
z-iGnLRWYBq0fY`j7#o&tb3_G`Jwds7qsEnS0zcqDYJ6#NYJS-kzgYXp!jDp+dgsh9
zo64F~lXS!}axGtvF+@}c)AxFoV4Z+z9Hj+}vmfm%gWcn2PGB(FG0+&_tEDI87EGq9
z`p`cnH&llgTNdJYfo8;ZHm8-%5X~8<{!IKP{##<3-OCN|k!h=xF^&d-gUcAZ>)J{Z
z2G_NP0tAb|QoJ#f?;L28;w-7gY&3!^uAAB*dJ{IGv0vKJ3K~raiDN<Iv@3l$gmEc{
zH)s#Q7*Hzd{HJ!ded#BM5p-PTe^G)?kFQy2ECo5ofmB2%_tPsZTOywb<0Qd3@5c<L
z0MQ|#3U`4!{u)$z-B27Ixa8uqjX=*_NRd7!(DoM_<YE%07D%s_;7_fNXVo`MMTj)P
zYbhHEEDX4Fd%LrH>$YB)6&bz7S3!_IKted^Yh5!^O(3gwUfPdKUn>R2c0usEfmvi^
zY6+EDUQR3%V3i!c8f!Q*&D)jvI#pF-#ZV*H;UZ-CjH+&QQrr8fFd2?~rvsf<q$LD7
zI?;qg<Jm1#CB?r53{#aR=Y6WBYVKye=H(m?Yiqv?*LXlsBGG;>gk(KkY=K82{BKF$
z;=0;AJa{WqF@cP$p=*mb!@=dg_rO-el$tyqsS|IP1%gXll)yl)I4v-Nk_A_X!{7=x
zozoAYcY)(dW!ux=Y$Ni{MWQ<Dtho%<yt?KRk9kio7mzBRou8}kL4wjcPsO7&S|kl3
zP_z|u6v!%h;Hu+>O%gel&`~o((n+^7^^E~y=%VTeVO((B+v`NR2G&zJb<TxRi$~@n
zK-izz@>57as-k53ueWw(-De5<b#dmx_btM1_3FZs8&`bPaEbap1~IN$LlDJl|4(rU
zE=9VcIsjsU2FT=BXE@4ofc1pHrtktn03{!FwkFJapVe<sX6cp*rglYR2Xb#6v^zIn
z?B(1BQg|e8u5Kc`gd9R?%2*psVGXO5sv63eAjQTiQ0Aw0U05b&>);A{YH~h1^V+FX
zZ&%SWiV}m(8~ATwRxFM^vzltnypx6+CKilm>yvSGjcV-+3(3~QI>B$Hac(z^(%IY0
zK1_Bl4ruaF(BJi8SkT^%*1uz{s>IQHnEZ%BEZduQW9AVrakIu4Y(zxpYZC&Nn23n&
zyOq@={m~fMzj|j+9ygodApWuc_nP39KA4QQp13z5Ro~`JvW&^y3IdP2&hldH<r2hy
zF?cP{KHxKpIY{wpe_2*5^-c5JSgq6}UCNuERjb!w;XWz94RfCyY3R>-50pqSe6<*a
zvWsBZrPAEb?Jn%WPDRZ8{Gf>0_v`{pOfEXkW-Z(%W@3ooBR#<b2kU(bl4Na!-7Bn3
z0Tsg&lDHXnocVfu_~bNu@3UTd#Gi2acGB)Uv-M}~?as}cdx*<_YzLgjW*!#O->`$W
zLPW3S<fk`@FJdQ@CwQR?ifi?Cgk8%jk6+VBvX%bfBQKDXur{gJc!4(vB<vK*sUrqc
zR@5xTp~5~2PZxiBPsrRGpYeEgsyLYprF?(3nRIPO8Ta@BbS)l@5wn<oB4XyQcH?7R
zleFH(%2a;E&nmq5msxK6J?s^`6WTI0-^j1n?Y<F}(iL+DQ7kE5vNRgM<kaAh*ZkH)
zTywVEQx635MvF*>v^GO@qF9qHC9eTuJX@A}lW8*KR<pFE5)X*FhW<yQnh|>Z=*+^B
zpyx;f_ZwOQTa=kahwd7pUyDHyRk4gX7#Vg;&kpYDW_PnZa^cxg104!YT{Mby@Ees*
z7L5KnSt!uEej|klu$2sUI_QQjYJ*xB$e@AZD0oJ#z~VxL(r<i5xkr7eU1jH3AhHx%
zDPv&I{+69!GDjR1_neOzd38Q!<i}L&LDUoMN*h3}jb9o9kld000TB1RJ_qzZC>PiB
zre4Rybih<pM&CyCmWGDOlX<XELag<jiQh7DnnBX)$;5}7&V5Fr>nu%YjhP_dyJkwL
zbM&!aJc#_-)(mxiBa{IW@wNR@R;<%Thul-VfA(+K)kAm9TKb3C(<VeN)uyj4&Msg7
z(=z#S+PJFOpw8Laa${?}Su^N>+HgwMuj#Q86QGQDK(<}<f5UG`02XGub2upXCeAA2
zNU|e-7oOVHFuKJ0S`+6t(ej;)cmu0}TQ`43K8Ni65e||C8=zD7{4E$v7mQ)f)?`tS
z)9v!Q7b?AFwm2Zg@ql06^ikzq_3vGeuQgwX*61sD1>V1p2ZVrN#)+r_YcR8Pd$W-E
z;3fg1?L)9oqG`HGJT1~qT@z+o=+E`Iudsy#%GvUQ-@?lKvjnC4I15)5a$!L%=+0?W
z^D^RN%vQ)k`pN7ZPR6Ah_uZUA+KFoH+}Hb1v-3-}#pV0guF3&PtbM1oyV<tIocKgY
zMKFe4yvDnF?E=+j@9X#GMq$}%H-w|PP>E))g7Hlc2i3Wi_6F|&n2AP#h?pfTJkUac
zBVb^p!R{hslwh~5*T5n)`LS7-bV3SgWN1TCD3vTjkSjudZNGY}8sHH~^h~0u(}V^T
z7y2HAGM@@6K?s#+YMB;=p3&Pf5U_|5(Xc{|nDpi@NyseTN0MNXg=}G#W=ool?*pYV
zGb|_W#0e46$i~3=8X3~&NHn-EF2dH{pVASvWkUcA8D?@d!r(N&NJfNOc;oD}L^^Jf
z)e&gEeP*bc(3sW%t88m(5ywYnR{wz+jGDd@7^rvl1&znHvilL|qiH+Y@9egkj=$o%
zW}YeHu~A=-OUV6Aef!<rLgQ3Pu0$)fNe3Po@Gw435WcofywSQ__uN~OAi|a$b3uIe
zFlLV-$rD-xe=e8X@;kTNd&pKlHTHmN>n^mPABI0%Gyd=c{(d6o54|opypbPrbcNm4
z@75u>UO&a|kWFJ_r<h7&7w*Co76@@BvjrijuG-q)y&bMu0%aOlCTj4D@T?Bc#TlBV
z@0?TE7j_n&q}O3x5)r)Q97{;;HLy*!$x@AVVCroEdg$O<xQi|UTB2PWzm+GYg(c)O
z3C)QwBP)xiXF$_f<4%gD>cd4qfUwxQ31wCobT`z!kB$-@z+Rj~S`6P)dcSW~hJj~4
zyVxVL3&{_cn$}t%%-JA6AqFq!Cl?nNuGnezlJj>y`<gPd9PNc>4sbfGKv~kFvwqOS
zHWf|g)7ZTWMJdjj{z{0R3D)sOol@ll!GOU?f+7A)W!6pq1Gqn){SeG^;?&K4Xhfu(
z?oCv$Rf414I7egy4$*ANeR$!`bbfb=C`zs^7sRIM2=;%8A2e}BjT}VsV}brSL>s~M
ztsg`Z0a_8)Lz2YlitpKYCOkGRW#Ee9ee~tOLB_~8WVV@lyKV%Kcu2b&wiiG?-A=x?
z4O-jPye$`!-GSE(v6Y8wwWT3I?zI*eXWwdE&I{cguZ=6YL(|6l?QUF_=);7fUa<%p
zmotIaq0|6UTPm5}cDW}6hCTK{V5!dc?-*rAYp#8;tcck^+UKc3e?;LcqUfHk5c(9H
zV?~cM@v5?|BLtXxN5oA4mV0@XDuR<r0gfW)(y@ali~=D%6Up;C&fVI$KpQF_6V0*G
zAQQARN^u^4c{51Zc9nszYx2Ut;`qP}#M^Q?sb5J0QrMwsN7vSf(~F0*A{zLPR(PI@
z-c-LpB)*@$lU8y*TNzh?c=ibdTKE_{Y&OmhAu>GkG{F~KCuF<z4b<z_#wwZnN(3Rr
z)KP`_VnzJ>HMFx)wb3GR4s|w1t51h!iaPAx#*N~=d^}#ZN#i{qzIm@_fO3n&-!kY!
zu5cyb=lcNPrT?$JYv*Yg2Er*srR@)34wD<Hl}Z-|29#2SD)ps?B6X@57$Oi<6c)sf
z=lgt@*eNeng^eL;<M?b}eD?W#cRstEu<rGjR@@X2kM^wf0huWy5sCU$*6W^gy+rW9
zOheudu8v8~5+&EAu)4`8Xo3dOEYgO!fa|^wqa48(VxB|rM1`nv6gXC1K&*Lst}1|k
ziJ*D`Y!fLcSsTR(=_H^1?Ir`Bo4E1;B5{SB4Fg`qP@mxk6nLEs=U`_|j!d-v;n~X<
zBgY#qneUvf1Cp#Xwws%R661-I2+YH8Vee;!s`XvAq+t`xsKkDOHmp#2I`wNz(-E$!
z>taraoMwgqv`<ljA-p!N$c%aGzYr^0uHj*nnD|tNfNqPRI#;WzaP?#rNT05{7K6l<
z!sU1=8Um*UgwC{0MQ#iivM}U^iRESiMN%F_r;T-nAmy@a2{Byf<&|<DlR^-i!l56S
zS+et5q!Ea`l%kD0HW5OtMqTnS(k4c2o(v$3wCqNuA<>2NYeMI2Mj71BZdQ-jVK7)b
zu{@bQK6VAl)3_w1&WMpNF_$8*_lJnMeb0~Kce5U@R_bQmIYuElCQbc*uh~k7j5Wa7
zmfCW!hVg=>A9p(4F8_=%vn=4jYH6x|SgEFqwBJki^mo6KhGB&hRo$9JOokWfL0CgV
zEyOJdK7kl)4Kd#uqQ5o7>_-UMiYZ}E48OtrD~RgVWI8x6f2hW$id;7fc2fT@$=m<+
N|CU0l;h*aN-vNvybb0^)

diff --git a/builds/misc/metadata.gbak b/builds/misc/metadata.gbak
deleted file mode 100644
index 8e5473c8f34b4da0a7c05ba21e0522b778fb6ee5..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 2048
zcmds0O;5r=5S`s_p?pd(A>M2Z7d0`U9t=0MHEF^}Z6Se^!D#g24gSBg({9+U6$(c=
zY_`LDZ}+{O0WL}aAOyqJrnMvhI5@N~*S|m3tM}D<b@TcD#?EG68+W+*bo)KGe>b>&
z7~J>W+g`5+&1R|q$aaJ~0jT2+fEfzFfV1|?DCmaK^vU<;k^edwj(r=-$Z8_KD$a4O
z5VuC_B~`9ye@!cDGz^V|Zli~)aELDLB=ounai7qUSPhqpAnra-qw#MR0u2`8Pqz5u
zZmJ8+mZ4#_h3A=8WyP>+vD)?qaf?!RPU4qQS1Z@8*>ns-H^()j4Z%^?5qdyaNUe5+
zh5Iu~_JZ_LDSK<4Ei{swq;Hlr(xDS|&GZ3GW%=}mvMe;{CVzE9htADWu2`&TG=&PQ
zEyFVZQF)nN#LZ9TP)}{!Ry!Q#^f%9`9qZG{`UIPun*Lq`Z_($JltpQ#^PO{xaxzgB
z$LKSZOxrG)c>W?sO792xYD%ZWWG`~LSS(J@twi2qH=2(8xJ>iuB!?Q<-~jCW0IYWa
zHrj_Rh4aTz@U*oj$H*>XPeq|m^Zqc3p;a8k&?=B(Xcb8@v~ro5#QjDK6O`A&1ZB4{
OK{?(<sLFT$55FH%s^iT7

diff --git a/builds/posix/Makefile.in b/builds/posix/Makefile.in
index bb4ceb12fb..1bb9f8e60a 100644
--- a/builds/posix/Makefile.in
+++ b/builds/posix/Makefile.in
@@ -412,33 +412,13 @@ gpre: $(GPRE) databases
 $(GPRE):	$(GPRE_Objects) $(COMMON_LIB)
 	$(EXE_LINK) $(EXE_LINK_OPTIONS) $^ -o $@ $(FIREBIRD_LIBRARY_LINK) $(LINK_LIBS) $(call LINK_DARWIN_RPATH,..)
 
-HELP_FDB = $(FIREBIRD)/help/help.fdb
 SECURITY_FDB = $(FIREBIRD)/security4.fdb
 SECURITY_TMP = security.tmp
 
-databases:		yachts.lnk msg.timestamp $(HELP_FDB) $(SECURITY_FDB)
+databases:		msg.timestamp $(SECURITY_FDB)
 
 export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(FIREBIRD)/lib
 
-yachts.lnk:		metadata.fdb
-	-$(RM) $@
-	$(LN) $^ $@
-
-metadata.fdb:	$(RUN_ISQL) $(SRC_ROOT)/dbs/metadata.sql
-	-$(RM) $@
-	$(RUN_ISQL) -q -i $(SRC_ROOT)/dbs/metadata.sql
-	$(RUN_GFIX) -mode read_only $@
-	$(CHMOD) 0444 $@
-
-$(HELP_FDB):	help.fdb
-	-$(RM) $@
-	$(CP) $^ $@
-	$(CHMOD) 0444 $@
-
-help.fdb:	$(BLD_ROOT)/misc/help.gbak
-	$(RUN_GBAK) -MODE read_only -R $< $@
-	$(CHMOD) 0444 $@
-
 $(SECURITY_FDB):	security.fdb
 	-$(RM) $@
 	$(CP) $^ $@
@@ -474,7 +454,6 @@ $(LIBIBUTIL_SO): $(UTIL_Objects)
 
 #___________________________________________________________________________
 # most of utilities, including network server and UDF support
-# qli is not here cause it needs special database (help.fdb), therefore needs gbak
 #
 
 .PHONY:	firebird_server fb_lock_print fbguard fbsvcmgr fbtracemgr gbak gfix gsec gsplit gstat isql nbackup
@@ -636,22 +615,17 @@ $(CODES):	$(CODES_Objects) $(COMMON_LIB)
 # all the rest we need to build
 #
 
-.PHONY:	qli message_file tzdata gbak_files
+.PHONY:	message_file tzdata gbak_files
 
-FDB_FILES := $(HELP_FDB) $(ROOT)/gen/msg.fdb $(SECURITY_FDB) $(FIREBIRD)/examples/empbuild/employee.fdb
+FDB_FILES := $(ROOT)/gen/msg.fdb $(SECURITY_FDB) $(FIREBIRD)/examples/empbuild/employee.fdb
 GBAK_FILES := $(FDB_FILES:.fdb=.gbak) $(FIREBIRD)/msg.gbak
 GBAK_FILES := $(subst Native,$(TARGET),$(GBAK_FILES))
 
-rest:	qli message_file tzdata
+rest:	message_file tzdata
 
-cross_rest:	qli gbak_files
+cross_rest:	gbak_files
 	$(MAKE) $(BUILD_FILE)
 
-qli:		$(QLI)
-
-$(QLI):		$(QLI_Objects) $(COMMON_LIB)
-	$(EXE_LINK) $(EXE_LINK_OPTIONS) $^ -o $@ $(FIREBIRD_LIBRARY_LINK) $(LINK_LIBS) $(call LINK_DARWIN_RPATH,..)
-
 examples: include_generic
 	$(MAKE) -f Makefile.examples -C $(GEN_ROOT)/examples/
 	$(MAKE) -f Makefile.plugins_examples
@@ -772,7 +746,6 @@ clean_config clean_all: clean clean_makefiles
 
 clean_dbs:
 	$(RM) *.fdb *.FDB msg.timestamp
-	$(RM) yachts.lnk
 
 
 # The examples are a bit different, since the makefile is included in the directory
diff --git a/builds/posix/make.defaults b/builds/posix/make.defaults
index 6dfd3ab118..b779d96ab1 100755
--- a/builds/posix/make.defaults
+++ b/builds/posix/make.defaults
@@ -399,9 +399,6 @@ INSTSVC		= $(BIN)/instsvc$(EXEC_EXT)
 
 SECURITY_FDB	= $(FIREBIRD)/security4.fdb
 
-# From qli
-QLI            = $(BIN)/qli$(EXEC_EXT)
-
 # From isql
 ISQL            = $(BIN)/isql$(EXEC_EXT)
 RUN_ISQL        = $(RBIN)/isql$(EXEC_EXT)
diff --git a/builds/posix/make.shared.targets b/builds/posix/make.shared.targets
index ae5ee5951d..ea500f92a0 100644
--- a/builds/posix/make.shared.targets
+++ b/builds/posix/make.shared.targets
@@ -61,10 +61,6 @@ $(SRC_ROOT)/gpre/gpre_meta.cpp:  $(SRC_ROOT)/gpre/gpre_meta.epp
 	$(GPRE_BOOT) -lang_internal $(GPRE_FLAGS) $< $@
 
 
-# These need to change to $(GEN_SRC) at some stage
-#$(SRC_ROOT)/qli/meta.cpp $(SRC_ROOT)/qli/proc.cpp $(SRC_ROOT)/qli/show.cpp: yachts.lnk
-#$(SRC_ROOT)/qli/help.cpp:        help.fdb
-
 # Explicit dependence on generated header (parser)
 $(OBJ)/dsql/Parser.o $(OBJ)/common/keywords.o $(OBJ)/dsql/dsql.o:	$(SRC_ROOT)/include/gen/parse.h
 
diff --git a/builds/posix/make.shared.variables b/builds/posix/make.shared.variables
index 0ce493fa12..ef514d8263 100644
--- a/builds/posix/make.shared.variables
+++ b/builds/posix/make.shared.variables
@@ -169,12 +169,6 @@ ISQL_Objects:= $(call dirObjects,isql)
 AllObjects += $(ISQL_Objects)
 
 
-# QLI
-QLI_Objects:= $(call dirObjects,qli)
-
-AllObjects += $(QLI_Objects)
-
-
 # Legacy users management in security database
 LEGACY_USERS_MANAGE_Objects:= $(call makeObjects,auth/SecurityDatabase,LegacyManagement.epp)
 
diff --git a/builds/posix/postfix.darwin b/builds/posix/postfix.darwin
index 9c00191f65..b82a66c57b 100644
--- a/builds/posix/postfix.darwin
+++ b/builds/posix/postfix.darwin
@@ -55,7 +55,6 @@ framework:
 	cp -r ../gen/$(TARGET)/firebird/plugins $(FB_FW)/Versions/A/Resources/plugins
 	cp ../gen/$(TARGET)/firebird/security4.fdb $(FB_FW)/Versions/A/Resources/security4.fdb
 	cp ../gen/$(TARGET)/firebird/firebird.msg $(FB_FW)/Versions/A/Resources/firebird.msg
-	cp -r ../gen/$(TARGET)/firebird/help $(FB_FW)/Versions/A/Resources/help
 	cp -r ../gen/$(TARGET)/firebird/tzdata $(FB_FW)/Versions/A/Resources/tzdata
 	mkdir -p $(FB_FW)/Resources/doc
 	cp -r ../doc $(FB_FW)/Resources
@@ -68,7 +67,6 @@ framework:
 	cp ../gen/$(TARGET)/firebird/bin/gbak $(FB_FW)/Versions/A/Resources/bin
 	cp ../gen/$(TARGET)/firebird/bin/isql $(FB_FW)/Versions/A/Resources/bin
 	cp ../gen/$(TARGET)/firebird/bin/gpre $(FB_FW)/Versions/A/Resources/bin
-	cp ../gen/$(TARGET)/firebird/bin/qli $(FB_FW)/Versions/A/Resources/bin
 	cp ../gen/$(TARGET)/firebird/bin/fb_lock_print $(FB_FW)/Versions/A/Resources/bin
 	cp ../gen/$(TARGET)/firebird/bin/gsec $(FB_FW)/Versions/A/Resources/bin
 	cp ../gen/$(TARGET)/firebird/bin/gstat $(FB_FW)/Versions/A/Resources/bin
diff --git a/builds/posix/prefix.mingw b/builds/posix/prefix.mingw
index 5f8dde8c9e..a73256bf9c 100644
--- a/builds/posix/prefix.mingw
+++ b/builds/posix/prefix.mingw
@@ -17,7 +17,7 @@
 # Start of file prefix.mingw:	$(VERSION)	$(PLATFORM)
 #
 # 2003-Sep-27 BRS Removed IPSERVER after XNET is included
-# 
+#
 
 # -Wno-unused-variable is used due to unused gpre generated variables
 PROD_FLAGS=-O2  -DMINGW -Wall -Wshadow -Wundef -Wno-long-long -Wno-unused-variable -Wno-sign-compare -Wno-parentheses -Wno-switch -fmessage-length=0 -Dlint -DWIN32_LEAN_AND_MEAN -MMD -mthreads -Wno-non-virtual-dtor
@@ -42,7 +42,7 @@ LIB_GUI:= -mwindows -lcomctl32 -lgdi32
 
 # Add resources to some files
 FilesToAddVersionInfo=$(LIBFBEMBED_SO) $(LIBFBCLIENT_SO) $(LIBFBINTL_SO) \
- $(GSTAT) $(GSEC) $(GFIX) $(QLI) $(ISQL) $(GBAK) $(GPRE)
+ $(GSTAT) $(GSEC) $(GFIX) $(ISQL) $(GBAK) $(GPRE)
 # TODO: guardians also must be here
 FilesToAddDialog=$(FB_SUPER_SERVER) $(FB_CLASSIC_SERVER)
 FilesToAddDialog2=$(IBGUARD)
@@ -63,7 +63,7 @@ LIB=$(BIN)
 
 # Special options for UDF link
 LINK_UDF = $(LIB_LINK) $(LIB_LINK_OPTIONS) $(call LIB_LINK_SONAME,$(1).$(SHRLIB_EXT)) -L$(LIB) -lib_util
-LINK_UDF_LIBS = 
+LINK_UDF_LIBS =
 
 # Special options for trace plugin link
 LINK_TRACE_LIBS = -L$(LIB) $(SO_LINK_LIBS)
diff --git a/builds/win32/make_boot.bat b/builds/win32/make_boot.bat
index 5c9445ea26..6a85564b93 100644
--- a/builds/win32/make_boot.bat
+++ b/builds/win32/make_boot.bat
@@ -19,7 +19,7 @@ set ERRLEV=0
 @echo.
 @echo Creating directories
 :: Create the directory hierarchy.
-for %%v in ( alice auth burp dsql gpre isql jrd misc msgs qli examples yvalve utilities) do (
+for %%v in ( alice auth burp dsql gpre isql jrd misc msgs examples yvalve utilities) do (
   @mkdir %FB_GEN_DIR%\%%v 2>nul
 )
 
@@ -187,7 +187,7 @@ goto :EOF
 @echo Building re2...
 @mkdir %FB_ROOT_PATH%\extern\re2\builds\%FB_TARGET_PLATFORM% 2>nul
 @pushd %FB_ROOT_PATH%\extern\re2\builds\%FB_TARGET_PLATFORM%
-@cmake -G "Visual Studio %MSVC_VERSION%" -A %FB_TARGET_PLATFORM% -S %FB_ROOT_PATH%\extern\re2 
+@cmake -G "Visual Studio %MSVC_VERSION%" -A %FB_TARGET_PLATFORM% -S %FB_ROOT_PATH%\extern\re2
 if errorlevel 1 call :boot2 re2
 @cmake --build %FB_ROOT_PATH%\extern\re2\builds\%FB_TARGET_PLATFORM% --target ALL_BUILD --config Release > re2_Release_%FB_TARGET_PLATFORM%.log
 @cmake --build %FB_ROOT_PATH%\extern\re2\builds\%FB_TARGET_PLATFORM% --target ALL_BUILD --config Debug > re2_Debug_%FB_TARGET_PLATFORM%.log
@@ -312,14 +312,8 @@ goto :EOF
 @"%FB_BIN_DIR%\isql" -q %FB_GEN_DB_DIR%/dbs/security4.fdb -i %FB_ROOT_PATH%\src\dbs\security.sql
 @copy %FB_GEN_DIR%\dbs\security4.fdb %FB_GEN_DIR%\dbs\security.fdb > nul
 
-@echo Restore metadata.gbak...
-@%FB_BIN_DIR%\gbak -r %FB_ROOT_PATH%\builds\misc\metadata.gbak %FB_GEN_DB_DIR%/dbs/metadata.fdb
-
 @call create_msgs.bat db
 
-@%FB_BIN_DIR%\gbak -r %FB_ROOT_PATH%\builds\misc\help.gbak %FB_GEN_DB_DIR%/dbs/help.fdb
-@copy %FB_GEN_DIR%\dbs\metadata.fdb %FB_GEN_DIR%\dbs\yachts.lnk > nul
-
 @goto :EOF
 
 
diff --git a/builds/win32/msvc12/Firebird.sln b/builds/win32/msvc12/Firebird.sln
index 5a7898f53a..7ee2a5611e 100644
--- a/builds/win32/msvc12/Firebird.sln
+++ b/builds/win32/msvc12/Firebird.sln
@@ -52,8 +52,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "isql", "isql.vcxproj", "{DE
 		{F8798A49-9D20-451E-A7BD-FEB5237103B5} = {F8798A49-9D20-451E-A7BD-FEB5237103B5}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "qli", "qli.vcxproj", "{EBB8361B-49D5-43A5-8771-940DF3E308EF}"
-EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "remote", "remote.vcxproj", "{4BCC693D-1745-45ED-8302-E5E2F979549A}"
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nbackup", "nbackup.vcxproj", "{01A41DFA-8908-4576-A1F1-C8BC7EAE39A1}"
diff --git a/builds/win32/msvc12/qli.vcxproj b/builds/win32/msvc12/qli.vcxproj
deleted file mode 100644
index 1b08787531..0000000000
--- a/builds/win32/msvc12/qli.vcxproj
+++ /dev/null
@@ -1,254 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{EBB8361B-49D5-43A5-8771-940DF3E308EF}</ProjectGuid>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v120_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v120_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v120</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v120</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdRelease.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdDebug.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdRelease.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdDebug.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;DEV_BUILD;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;DEV_BUILD;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\src\qli\all.cpp" />
-    <ClCompile Include="..\..\..\src\qli\command.cpp" />
-    <ClCompile Include="..\..\..\src\qli\compile.cpp" />
-    <ClCompile Include="..\..\..\src\qli\dtr.cpp" />
-    <ClCompile Include="..\..\..\src\qli\err.cpp" />
-    <ClCompile Include="..\..\..\src\qli\eval.cpp" />
-    <ClCompile Include="..\..\..\src\qli\exe.cpp" />
-    <ClCompile Include="..\..\..\src\qli\expand.cpp" />
-    <ClCompile Include="..\..\..\src\qli\format.cpp" />
-    <ClCompile Include="..\..\..\src\qli\gener.cpp" />
-    <ClCompile Include="..\..\..\src\qli\hsh.cpp" />
-    <ClCompile Include="..\..\..\src\qli\lex.cpp" />
-    <ClCompile Include="..\..\..\src\qli\mov.cpp" />
-    <ClCompile Include="..\..\..\src\qli\parse.cpp" />
-    <ClCompile Include="..\..\..\src\qli\picstr.cpp" />
-    <ClCompile Include="..\..\..\src\qli\report.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\help.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\meta.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\proc.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\show.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\src\qli\help.epp" />
-    <None Include="..\..\..\src\qli\meta.epp" />
-    <None Include="..\..\..\src\qli\proc.epp" />
-    <None Include="..\..\..\src\qli\show.epp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="..\..\..\src\jrd\version.rc">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="common.vcxproj">
-      <Project>{15605f44-bffd-444f-ad4c-55dc9d704465}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-    <ProjectReference Include="yvalve.vcxproj">
-      <Project>{4fe03933-98cd-4879-a135-fd9430087a6b}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\src\qli\all_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\blk.h" />
-    <ClInclude Include="..\..\..\src\qli\comma_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\compile.h" />
-    <ClInclude Include="..\..\..\src\qli\compi_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\dtr.h" />
-    <ClInclude Include="..\..\..\src\qli\err_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\eval_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\exe.h" />
-    <ClInclude Include="..\..\..\src\qli\exe_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\expan_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\format.h" />
-    <ClInclude Include="..\..\..\src\qli\forma_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\gener_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\help_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\hsh_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\lex_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\meta_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\mov_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\parse.h" />
-    <ClInclude Include="..\..\..\src\qli\parse_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\picst_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl1.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl2.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl3.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl4.h" />
-    <ClInclude Include="..\..\..\src\qli\proc_ddl.h" />
-    <ClInclude Include="..\..\..\src\qli\proc_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\qliswi.h" />
-    <ClInclude Include="..\..\..\src\qli\report.h" />
-    <ClInclude Include="..\..\..\src\qli\repor_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\reqs.h" />
-    <ClInclude Include="..\..\..\src\qli\show_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\symbols.h" />
-    <ClInclude Include="..\..\..\src\qli\words.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/builds/win32/msvc12/qli.vcxproj.filters b/builds/win32/msvc12/qli.vcxproj.filters
deleted file mode 100644
index ddcc67a905..0000000000
--- a/builds/win32/msvc12/qli.vcxproj.filters
+++ /dev/null
@@ -1,209 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="QLI files">
-      <UniqueIdentifier>{da3cf9eb-a5b6-4478-87a3-3da5fa0c95a8}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Header files">
-      <UniqueIdentifier>{ea691fcc-ce86-44c7-b53b-40b660c82329}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl</Extensions>
-    </Filter>
-    <Filter Include="Resource files">
-      <UniqueIdentifier>{34f2b335-6604-4188-a20b-e9916b80b05c}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="QLI files\GPRE epp">
-      <UniqueIdentifier>{a1a82d81-9dc5-4076-8daa-a05176116840}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="QLI files\GPRE cpp">
-      <UniqueIdentifier>{28befd96-6561-4892-8120-10fe6777523c}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\src\qli\all.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\command.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\compile.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\dtr.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\err.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\eval.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\exe.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\expand.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\format.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\gener.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\hsh.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\lex.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\mov.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\parse.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\picstr.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\report.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\help.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\proc.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\meta.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\show.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\src\qli\help.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\meta.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\proc.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\show.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="..\..\..\src\jrd\version.rc">
-      <Filter>Resource files</Filter>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\src\qli\words.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\all_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\blk.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\comma_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\compi_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\compile.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\dtr.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\err_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\eval_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\exe.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\exe_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\expan_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\forma_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\format.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\gener_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\help_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\hsh_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\lex_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\meta_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\mov_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\parse.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\parse_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\picst_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\proc_ddl.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\proc_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl1.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl2.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl3.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl4.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\qliswi.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\repor_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\report.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\reqs.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\show_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\symbols.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/builds/win32/msvc14/Firebird.sln b/builds/win32/msvc14/Firebird.sln
index 9d4aa1f2ed..6c72197cf3 100644
--- a/builds/win32/msvc14/Firebird.sln
+++ b/builds/win32/msvc14/Firebird.sln
@@ -52,8 +52,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "isql", "isql.vcxproj", "{DE
 		{F8798A49-9D20-451E-A7BD-FEB5237103B5} = {F8798A49-9D20-451E-A7BD-FEB5237103B5}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "qli", "qli.vcxproj", "{EBB8361B-49D5-43A5-8771-940DF3E308EF}"
-EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "remote", "remote.vcxproj", "{4BCC693D-1745-45ED-8302-E5E2F979549A}"
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nbackup", "nbackup.vcxproj", "{01A41DFA-8908-4576-A1F1-C8BC7EAE39A1}"
diff --git a/builds/win32/msvc14/qli.vcxproj b/builds/win32/msvc14/qli.vcxproj
deleted file mode 100644
index 193c547949..0000000000
--- a/builds/win32/msvc14/qli.vcxproj
+++ /dev/null
@@ -1,254 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{EBB8361B-49D5-43A5-8771-940DF3E308EF}</ProjectGuid>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v140_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdRelease.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdDebug.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdRelease.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdDebug.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;DEV_BUILD;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;DEV_BUILD;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\src\qli\all.cpp" />
-    <ClCompile Include="..\..\..\src\qli\command.cpp" />
-    <ClCompile Include="..\..\..\src\qli\compile.cpp" />
-    <ClCompile Include="..\..\..\src\qli\dtr.cpp" />
-    <ClCompile Include="..\..\..\src\qli\err.cpp" />
-    <ClCompile Include="..\..\..\src\qli\eval.cpp" />
-    <ClCompile Include="..\..\..\src\qli\exe.cpp" />
-    <ClCompile Include="..\..\..\src\qli\expand.cpp" />
-    <ClCompile Include="..\..\..\src\qli\format.cpp" />
-    <ClCompile Include="..\..\..\src\qli\gener.cpp" />
-    <ClCompile Include="..\..\..\src\qli\hsh.cpp" />
-    <ClCompile Include="..\..\..\src\qli\lex.cpp" />
-    <ClCompile Include="..\..\..\src\qli\mov.cpp" />
-    <ClCompile Include="..\..\..\src\qli\parse.cpp" />
-    <ClCompile Include="..\..\..\src\qli\picstr.cpp" />
-    <ClCompile Include="..\..\..\src\qli\report.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\help.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\meta.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\proc.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\show.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\src\qli\help.epp" />
-    <None Include="..\..\..\src\qli\meta.epp" />
-    <None Include="..\..\..\src\qli\proc.epp" />
-    <None Include="..\..\..\src\qli\show.epp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="..\..\..\src\jrd\version.rc">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="common.vcxproj">
-      <Project>{15605f44-bffd-444f-ad4c-55dc9d704465}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-    <ProjectReference Include="yvalve.vcxproj">
-      <Project>{4fe03933-98cd-4879-a135-fd9430087a6b}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\src\qli\all_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\blk.h" />
-    <ClInclude Include="..\..\..\src\qli\comma_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\compile.h" />
-    <ClInclude Include="..\..\..\src\qli\compi_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\dtr.h" />
-    <ClInclude Include="..\..\..\src\qli\err_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\eval_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\exe.h" />
-    <ClInclude Include="..\..\..\src\qli\exe_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\expan_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\format.h" />
-    <ClInclude Include="..\..\..\src\qli\forma_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\gener_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\help_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\hsh_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\lex_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\meta_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\mov_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\parse.h" />
-    <ClInclude Include="..\..\..\src\qli\parse_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\picst_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl1.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl2.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl3.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl4.h" />
-    <ClInclude Include="..\..\..\src\qli\proc_ddl.h" />
-    <ClInclude Include="..\..\..\src\qli\proc_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\qliswi.h" />
-    <ClInclude Include="..\..\..\src\qli\report.h" />
-    <ClInclude Include="..\..\..\src\qli\repor_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\reqs.h" />
-    <ClInclude Include="..\..\..\src\qli\show_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\symbols.h" />
-    <ClInclude Include="..\..\..\src\qli\words.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/builds/win32/msvc14/qli.vcxproj.filters b/builds/win32/msvc14/qli.vcxproj.filters
deleted file mode 100644
index ddcc67a905..0000000000
--- a/builds/win32/msvc14/qli.vcxproj.filters
+++ /dev/null
@@ -1,209 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="QLI files">
-      <UniqueIdentifier>{da3cf9eb-a5b6-4478-87a3-3da5fa0c95a8}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Header files">
-      <UniqueIdentifier>{ea691fcc-ce86-44c7-b53b-40b660c82329}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl</Extensions>
-    </Filter>
-    <Filter Include="Resource files">
-      <UniqueIdentifier>{34f2b335-6604-4188-a20b-e9916b80b05c}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="QLI files\GPRE epp">
-      <UniqueIdentifier>{a1a82d81-9dc5-4076-8daa-a05176116840}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="QLI files\GPRE cpp">
-      <UniqueIdentifier>{28befd96-6561-4892-8120-10fe6777523c}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\src\qli\all.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\command.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\compile.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\dtr.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\err.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\eval.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\exe.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\expand.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\format.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\gener.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\hsh.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\lex.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\mov.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\parse.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\picstr.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\report.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\help.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\proc.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\meta.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\show.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\src\qli\help.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\meta.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\proc.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\show.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="..\..\..\src\jrd\version.rc">
-      <Filter>Resource files</Filter>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\src\qli\words.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\all_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\blk.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\comma_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\compi_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\compile.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\dtr.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\err_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\eval_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\exe.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\exe_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\expan_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\forma_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\format.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\gener_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\help_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\hsh_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\lex_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\meta_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\mov_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\parse.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\parse_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\picst_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\proc_ddl.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\proc_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl1.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl2.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl3.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl4.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\qliswi.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\repor_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\report.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\reqs.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\show_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\symbols.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/builds/win32/msvc15/Firebird.sln b/builds/win32/msvc15/Firebird.sln
index b674391175..910519109e 100644
--- a/builds/win32/msvc15/Firebird.sln
+++ b/builds/win32/msvc15/Firebird.sln
@@ -52,8 +52,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "isql", "isql.vcxproj", "{DE
 		{F8798A49-9D20-451E-A7BD-FEB5237103B5} = {F8798A49-9D20-451E-A7BD-FEB5237103B5}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "qli", "qli.vcxproj", "{EBB8361B-49D5-43A5-8771-940DF3E308EF}"
-EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "remote", "remote.vcxproj", "{4BCC693D-1745-45ED-8302-E5E2F979549A}"
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nbackup", "nbackup.vcxproj", "{01A41DFA-8908-4576-A1F1-C8BC7EAE39A1}"
diff --git a/builds/win32/msvc15/qli.vcxproj b/builds/win32/msvc15/qli.vcxproj
deleted file mode 100644
index ddc0915102..0000000000
--- a/builds/win32/msvc15/qli.vcxproj
+++ /dev/null
@@ -1,255 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{EBB8361B-49D5-43A5-8771-940DF3E308EF}</ProjectGuid>
-    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v141_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v141_xp</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v141</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <PlatformToolset>v141</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdRelease.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdDebug.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdRelease.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="FirebirdCommon.props" />
-    <Import Project="FirebirdDebug.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\temp\$(PlatformName)\$(Configuration)\firebird\</OutDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;DEV_BUILD;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;DEV_BUILD;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;SUPERCLIENT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>comctl32.lib;ws2_32.lib;mpr.lib;version.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\src\qli\all.cpp" />
-    <ClCompile Include="..\..\..\src\qli\command.cpp" />
-    <ClCompile Include="..\..\..\src\qli\compile.cpp" />
-    <ClCompile Include="..\..\..\src\qli\dtr.cpp" />
-    <ClCompile Include="..\..\..\src\qli\err.cpp" />
-    <ClCompile Include="..\..\..\src\qli\eval.cpp" />
-    <ClCompile Include="..\..\..\src\qli\exe.cpp" />
-    <ClCompile Include="..\..\..\src\qli\expand.cpp" />
-    <ClCompile Include="..\..\..\src\qli\format.cpp" />
-    <ClCompile Include="..\..\..\src\qli\gener.cpp" />
-    <ClCompile Include="..\..\..\src\qli\hsh.cpp" />
-    <ClCompile Include="..\..\..\src\qli\lex.cpp" />
-    <ClCompile Include="..\..\..\src\qli\mov.cpp" />
-    <ClCompile Include="..\..\..\src\qli\parse.cpp" />
-    <ClCompile Include="..\..\..\src\qli\picstr.cpp" />
-    <ClCompile Include="..\..\..\src\qli\report.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\help.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\meta.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\proc.cpp" />
-    <ClCompile Include="..\..\..\gen\qli\show.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\src\qli\help.epp" />
-    <None Include="..\..\..\src\qli\meta.epp" />
-    <None Include="..\..\..\src\qli\proc.epp" />
-    <None Include="..\..\..\src\qli\show.epp" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="..\..\..\src\jrd\version.rc">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\src\jrd</AdditionalIncludeDirectories>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="common.vcxproj">
-      <Project>{15605f44-bffd-444f-ad4c-55dc9d704465}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-    <ProjectReference Include="yvalve.vcxproj">
-      <Project>{4fe03933-98cd-4879-a135-fd9430087a6b}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\src\qli\all_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\blk.h" />
-    <ClInclude Include="..\..\..\src\qli\comma_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\compile.h" />
-    <ClInclude Include="..\..\..\src\qli\compi_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\dtr.h" />
-    <ClInclude Include="..\..\..\src\qli\err_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\eval_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\exe.h" />
-    <ClInclude Include="..\..\..\src\qli\exe_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\expan_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\format.h" />
-    <ClInclude Include="..\..\..\src\qli\forma_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\gener_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\help_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\hsh_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\lex_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\meta_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\mov_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\parse.h" />
-    <ClInclude Include="..\..\..\src\qli\parse_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\picst_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl1.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl2.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl3.h" />
-    <ClInclude Include="..\..\..\src\qli\procddl4.h" />
-    <ClInclude Include="..\..\..\src\qli\proc_ddl.h" />
-    <ClInclude Include="..\..\..\src\qli\proc_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\qliswi.h" />
-    <ClInclude Include="..\..\..\src\qli\report.h" />
-    <ClInclude Include="..\..\..\src\qli\repor_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\reqs.h" />
-    <ClInclude Include="..\..\..\src\qli\show_proto.h" />
-    <ClInclude Include="..\..\..\src\qli\symbols.h" />
-    <ClInclude Include="..\..\..\src\qli\words.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/builds/win32/msvc15/qli.vcxproj.filters b/builds/win32/msvc15/qli.vcxproj.filters
deleted file mode 100644
index ddcc67a905..0000000000
--- a/builds/win32/msvc15/qli.vcxproj.filters
+++ /dev/null
@@ -1,209 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="QLI files">
-      <UniqueIdentifier>{da3cf9eb-a5b6-4478-87a3-3da5fa0c95a8}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Header files">
-      <UniqueIdentifier>{ea691fcc-ce86-44c7-b53b-40b660c82329}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl</Extensions>
-    </Filter>
-    <Filter Include="Resource files">
-      <UniqueIdentifier>{34f2b335-6604-4188-a20b-e9916b80b05c}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="QLI files\GPRE epp">
-      <UniqueIdentifier>{a1a82d81-9dc5-4076-8daa-a05176116840}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="QLI files\GPRE cpp">
-      <UniqueIdentifier>{28befd96-6561-4892-8120-10fe6777523c}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\src\qli\all.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\command.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\compile.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\dtr.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\err.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\eval.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\exe.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\expand.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\format.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\gener.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\hsh.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\lex.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\mov.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\parse.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\picstr.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\src\qli\report.cpp">
-      <Filter>QLI files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\help.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\proc.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\meta.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gen\qli\show.cpp">
-      <Filter>QLI files\GPRE cpp</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\src\qli\help.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\meta.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\proc.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-    <None Include="..\..\..\src\qli\show.epp">
-      <Filter>QLI files\GPRE epp</Filter>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="..\..\..\src\jrd\version.rc">
-      <Filter>Resource files</Filter>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\src\qli\words.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\all_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\blk.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\comma_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\compi_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\compile.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\dtr.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\err_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\eval_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\exe.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\exe_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\expan_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\forma_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\format.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\gener_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\help_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\hsh_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\lex_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\meta_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\mov_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\parse.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\parse_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\picst_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\proc_ddl.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\proc_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl1.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl2.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl3.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\procddl4.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\qliswi.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\repor_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\report.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\reqs.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\show_proto.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\src\qli\symbols.h">
-      <Filter>Header files</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/builds/win32/preprocess.bat b/builds/win32/preprocess.bat
index 377da3d132..89289cbe84 100644
--- a/builds/win32/preprocess.bat
+++ b/builds/win32/preprocess.bat
@@ -81,7 +81,6 @@ goto :EOF
 @for %%i in (dfw, dpm, dyn_util, fun, grant, ini, met, scl, Function) do @call :PREPROCESS jrd %%i -gds_cxx
 @for %%i in (codes) do @call :PREPROCESS misc %%i
 @for %%i in (build_file) do @call :PREPROCESS msgs %%i
-@for %%i in (help, meta, proc, show) do @call :PREPROCESS qli %%i
 @for %%i in (extract, isql, show) do @call :PREPROCESS isql %%i -ocxx
 @for %%i in (dba) do @call :PREPROCESS utilities/gstat %%i
 @for %%i in (stats) do @call :PREPROCESS utilities %%i
diff --git a/configure.ac b/configure.ac
index 0a3de368ac..16ebcf8099 100644
--- a/configure.ac
+++ b/configure.ac
@@ -673,7 +673,6 @@ XE_CONF_DIR(fbinclude, [C/C++ header files DIR (PREFIX/include)], FB_INCDIR, /in
 XE_CONF_DIR(fbdoc, [documentation root DIR (PREFIX/doc)], FB_DOCDIR, /doc)
 XE_CONF_DIR(fbsample, [examples DIR (PREFIX/examples)], FB_SAMPLEDIR, /examples)
 XE_CONF_DIR(fbsample-db, [examples database DIR (PREFIX/examples/empbuild)], FB_SAMPLEDBDIR, /examples/empbuild)
-XE_CONF_DIR(fbhelp, [QLI help DIR (PREFIX/help)], FB_HELPDIR, /help)
 XE_CONF_DIR(fbintl, [international DIR (PREFIX/intl)], FB_INTLDIR, /intl)
 XE_CONF_DIR(fbmisc, [misc DIR (PREFIX/misc)], FB_MISCDIR, /misc)
 XE_CONF_DIR(fbsecure-db, [security database DIR (PREFIX)], FB_SECDBDIR)
@@ -1241,7 +1240,6 @@ dnl # output
 	mkdir -p gen/\$fb_tgt/firebird/examples/prebuilt/plugins
 	mkdir -p gen/\$fb_tgt/firebird/lib
 	mkdir -p gen/\$fb_tgt/firebird/misc
-	mkdir -p gen/\$fb_tgt/firebird/help
 
 dnl ### TEMP ### directories for generated .cpp, .o and .d by module name
 	for src_dir in `cd src; ls -R -1 * | grep : | tr -d : | tr "\n" " "; cd ..`; do
diff --git a/doc/README.read_password_from_file b/doc/README.read_password_from_file
index 09ea3dbc46..970ad96d01 100644
--- a/doc/README.read_password_from_file
+++ b/doc/README.read_password_from_file
@@ -1,10 +1,10 @@
 Issue:
 ======
- All command-line utilities which support -password parameter are 
- vulnerable to password sniffing, especially when they're run from 
- scripts. Since 2.1, all Firebird utilities replace argv[PASSWORD] 
- with *, but better solution for hiding password from others in 
- process list should be reading it from file or asking for it on 
+All command-line utilities which support -password parameter are
+ vulnerable to password sniffing, especially when they're run from
+ scripts. Since 2.1, all Firebird utilities replace argv[PASSWORD]
+ with *, but better solution for hiding password from others in
+ process list should be reading it from file or asking for it on
  stdin.
 
 Scope:
@@ -19,21 +19,21 @@ Document date:  2008-11-30
 ==============
 
 
- All utilities have new switch 
--fetch_password 
- which may be abbreviated according with utility rules. 
- The exception is QLI, where -F should be used. 
+ All utilities have new switch
+-fetch_password
+ which may be abbreviated according with utility rules.
+ The exception is QLI, where -F should be used.
  
- Switch has required parameter - name of file with password. I.e.: 
-isql -user sysdba -fet passfile server:employee 
- will load password form file "passfile", using its first line 
- as password. 
+ Switch has required parameter - name of file with password. I.e.:
+isql -user sysdba -fet passfile server:employee
+ will load password form file "passfile", using its first line
+ as password.
  
- One can specify "stdin" as file name to make password be read 
+ One can specify "stdin" as file name to make password be read
  from stdin. If stdin is terminal, prompt:
-Enter password: 
- will be printed. 
+Enter password:
+ will be printed.
  
- For posix users - if you specify '-fetch /dev/tty' you will also 
- be promted. This may be useful if you need to restore from stdin: 
-bunzip2 -c emp.fbk.bz2 | gbak -c stdin /db/new.fdb -user sysdba -fetch /dev/tty 
+ For posix users - if you specify '-fetch /dev/tty' you will also
+ be promted. This may be useful if you need to restore from stdin:
+bunzip2 -c emp.fbk.bz2 | gbak -c stdin /db/new.fdb -user sysdba -fetch /dev/tty
diff --git a/doc/Using_OO_API.html b/doc/Using_OO_API.html
index 24bfd723b9..a587414222 100644
--- a/doc/Using_OO_API.html
+++ b/doc/Using_OO_API.html
@@ -2070,8 +2070,6 @@ codes:</font></p>
 - samples</font></p>
 <p style="margin-bottom: 0cm"><font size="4" style="font-size: 14pt">DIR_SAMPLEDB
 – samples database (employee.fdb)</font></p>
-<p style="margin-bottom: 0cm"><font size="4" style="font-size: 14pt">DIR_HELP
-– qli help (help.fdb)</font></p>
 <p style="margin-bottom: 0cm"><font size="4" style="font-size: 14pt">DIR_INTL
 – international libraries (fbintl)</font></p>
 <p style="margin-bottom: 0cm"><font size="4" style="font-size: 14pt">DIR_MISC
@@ -3766,4 +3764,4 @@ release of it.</font></p>
 
 </p>
 </body>
-</html>
\ No newline at end of file
+</html>
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index b890c4ea8b..b828db58ac 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -61,10 +61,6 @@ set(epp_master_files
     auth/SecurityDatabase/LegacyManagement.epp
     msgs/build_file.epp
     misc/codes.epp
-    qli/help.epp
-    qli/meta.epp
-    qli/proc.epp
-    qli/show.epp
 )
 
 if (NOT CMAKE_CROSSCOMPILING)
@@ -124,29 +120,6 @@ add_custom_command(
     COMMAND ${CMAKE_COMMAND} -E copy_if_different security_.fdb security.fdb
     COMMAND ${BOOT_GFIX_CMD} -write sync security.fdb
 )
-add_custom_command(
-    OUTPUT metadata.fdb
-    DEPENDS
-        boot_gbak
-        ${CMAKE_SOURCE_DIR}/builds/misc/metadata.gbak
-    #
-    COMMAND ${CMAKE_COMMAND} -E remove metadata.fdb
-    COMMAND ${CMAKE_COMMAND} -E remove metadata_.fdb
-    COMMAND ${BOOT_GBAK_CMD} -r ${CMAKE_SOURCE_DIR}/builds/misc/metadata.gbak metadata_.fdb
-    COMMAND ${CMAKE_COMMAND} -E copy_if_different metadata_.fdb metadata.fdb
-)
-add_custom_command(
-    OUTPUT help.fdb
-    DEPENDS
-        boot_gbak
-        metadata.fdb
-        ${CMAKE_SOURCE_DIR}/builds/misc/help.gbak
-    #
-    COMMAND ${CMAKE_COMMAND} -E remove help.fdb
-    COMMAND ${CMAKE_COMMAND} -E remove help_.fdb
-    COMMAND ${BOOT_GBAK_CMD} -r ${CMAKE_SOURCE_DIR}/builds/misc/help.gbak help_.fdb
-    COMMAND ${CMAKE_COMMAND} -E copy_if_different help_.fdb help.fdb
-)
 add_custom_target(databases
     DEPENDS
         boot_engine
@@ -870,23 +843,6 @@ add_executable              (isql ${isql_src} ${isql_generated_src_master} ${VER
 target_link_libraries       (isql common yvalve)
 
 
-########################################
-# EXECUTABLE qli
-########################################
-
-file(GLOB qli_src "qli/*.cpp" "qli/*.h")
-set(qli_generated_src
-    qli/help.epp
-    qli/meta.epp
-    qli/proc.epp
-    qli/show.epp
-)
-add_epp_suffix(qli_generated_src master)
-
-add_executable          (qli ${qli_src} ${qli_generated_src_master} ${VERSION_RC})
-target_link_libraries   (qli common yvalve)
-
-
 ################################################################################
 #
 # subdirectories
diff --git a/src/common/utils.cpp b/src/common/utils.cpp
index e0f7ac42b7..7ec3b9b66f 100644
--- a/src/common/utils.cpp
+++ b/src/common/utils.cpp
@@ -1044,7 +1044,7 @@ Firebird::PathName getPrefix(unsigned int prefType, const char* name)
 
 	const char* configDir[] = {
 		FB_BINDIR, FB_SBINDIR, FB_CONFDIR, FB_LIBDIR, FB_INCDIR, FB_DOCDIR, "", FB_SAMPLEDIR,
-		FB_SAMPLEDBDIR, FB_HELPDIR, FB_INTLDIR, FB_MISCDIR, FB_SECDBDIR, FB_MSGDIR, FB_LOGDIR,
+		FB_SAMPLEDBDIR, "", FB_INTLDIR, FB_MISCDIR, FB_SECDBDIR, FB_MSGDIR, FB_LOGDIR,
 		FB_GUARDDIR, FB_PLUGDIR, FB_TZDATADIR
 	};
 
diff --git a/src/dbs/metadata.sql b/src/dbs/metadata.sql
deleted file mode 100644
index 15d08a1468..0000000000
--- a/src/dbs/metadata.sql
+++ /dev/null
@@ -1,34 +0,0 @@
-/* The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-/* This database file is used by GPRE for metadata lookup on behalf of the .e
- * files.
- */
-SET SQL DIALECT 1;
-
-CREATE DATABASE 'metadata.fdb' PAGE_SIZE 1024;
-
-/* Domain definitions */
-CREATE DOMAIN QLI$PROCEDURE_NAME AS CHAR(31);
-CREATE DOMAIN QLI$PROCEDURE AS BLOB SUB_TYPE TEXT SEGMENT SIZE 80;
-
-/* Table: QLI$PROCEDURES, Owner: BUILDER */
-CREATE TABLE QLI$PROCEDURES (QLI$PROCEDURE_NAME QLI$PROCEDURE_NAME,
-        QLI$PROCEDURE QLI$PROCEDURE);
-
-/*  Index definitions for all user tables */
-CREATE UNIQUE INDEX QLI$PROCEDURES_IDX1 ON QLI$PROCEDURES(QLI$PROCEDURE_NAME);
diff --git a/src/include/cross/android.arm64 b/src/include/cross/android.arm64
index fcc517a420..4a4e30160f 100644
--- a/src/include/cross/android.arm64
+++ b/src/include/cross/android.arm64
@@ -40,9 +40,6 @@
 /* guardian lock DIR (PREFIX) */
 #define FB_GUARDDIR ""
 
-/* QLI help DIR (PREFIX/help) */
-#define FB_HELPDIR ""
-
 /* C/C++ header files DIR (PREFIX/include) */
 #define FB_INCDIR ""
 
diff --git a/src/include/cross/android.arme b/src/include/cross/android.arme
index 50ca157f51..70973d5cdf 100644
--- a/src/include/cross/android.arme
+++ b/src/include/cross/android.arme
@@ -46,9 +46,6 @@
 /* guardian lock DIR (PREFIX) */
 #define FB_GUARDDIR ""
 
-/* QLI help DIR (PREFIX/help) */
-#define FB_HELPDIR ""
-
 /* C/C++ header files DIR (PREFIX/include) */
 #define FB_INCDIR ""
 
diff --git a/src/include/cross/android.x86 b/src/include/cross/android.x86
index 14bef1c334..73bb83c51e 100644
--- a/src/include/cross/android.x86
+++ b/src/include/cross/android.x86
@@ -40,9 +40,6 @@
 /* guardian lock DIR (PREFIX) */
 #define FB_GUARDDIR ""
 
-/* QLI help DIR (PREFIX/help) */
-#define FB_HELPDIR ""
-
 /* C/C++ header files DIR (PREFIX/include) */
 #define FB_INCDIR ""
 
diff --git a/src/include/cross/android.x86_64 b/src/include/cross/android.x86_64
index e9f150620b..2910dd421a 100644
--- a/src/include/cross/android.x86_64
+++ b/src/include/cross/android.x86_64
@@ -40,9 +40,6 @@
 /* guardian lock DIR (PREFIX) */
 #define FB_GUARDDIR ""
 
-/* QLI help DIR (PREFIX/help) */
-#define FB_HELPDIR ""
-
 /* C/C++ header files DIR (PREFIX/include) */
 #define FB_INCDIR ""
 
diff --git a/src/include/gen/autoconfig.h.in b/src/include/gen/autoconfig.h.in
index f0e06cbd54..60def23496 100644
--- a/src/include/gen/autoconfig.h.in
+++ b/src/include/gen/autoconfig.h.in
@@ -4,7 +4,7 @@
  *  Autogenerated file.
  *
  ******************************************************************************/
- 
+
 /******************************************************************************
  *
  * CPU
@@ -125,9 +125,6 @@
 /* guardian lock DIR (PREFIX) */
 #define FB_GUARDDIR "@FB_GUARDDIR@"
 
-/* QLI help DIR (PREFIX/help) */
-#define FB_HELPDIR "@FB_HELPDIR@"
-
 /* C/C++ header files DIR (PREFIX/include) */
 #define FB_INCDIR "@FB_INCDIR@"
 
@@ -167,7 +164,7 @@
  * Headers
  *
  ******************************************************************************/
- 
+
 /* Define to 1 if you have the <aio.h> header file. */
 #cmakedefine HAVE_AIO_H 1
 
@@ -390,7 +387,7 @@
  * Functions
  *
  ******************************************************************************/
- 
+
 /* Define to 1 if you have the `accept4' function. */
 #cmakedefine HAVE_ACCEPT4 1
 
@@ -577,13 +574,13 @@
 /* Define to 1 if you have the `vfork' function. */
 #cmakedefine HAVE_VFORK 1
 
- 
+
 /******************************************************************************
  *
  * Types
  *
  ******************************************************************************/
-  
+
 /* Define to 1 if the system has the type `caddr_t'. */
 #cmakedefine HAVE_CADDR_T 1
 
@@ -608,7 +605,7 @@
  * Other/Misc
  *
  ******************************************************************************/
- 
+
 /* Use binary relocation? */
 #cmakedefine ENABLE_BINRELOC /**/
 
diff --git a/src/include/gen/autoconfig_msvc.h b/src/include/gen/autoconfig_msvc.h
index 54dbf2084b..458fd04511 100644
--- a/src/include/gen/autoconfig_msvc.h
+++ b/src/include/gen/autoconfig_msvc.h
@@ -326,7 +326,6 @@
 #define FB_CONFDIR ""
 #define FB_DOCDIR ""
 #define FB_GUARDDIR ""
-#define FB_HELPDIR ""
 #define FB_INCDIR ""
 #define FB_INTLDIR ""
 #define FB_LIBDIR ""
diff --git a/src/msgs/facilities2.sql b/src/msgs/facilities2.sql
index c6b9436ae9..bb220f4343 100644
--- a/src/msgs/facilities2.sql
+++ b/src/msgs/facilities2.sql
@@ -2,7 +2,6 @@
 set bulk_insert INSERT INTO FACILITIES (LAST_CHANGE, FACILITY, FAC_CODE, MAX_NUMBER) VALUES (?, ?, ?, ?);
 --
 ('2021-05-11 14:10:00', 'JRD', 0, 955)
-('2015-03-17 18:33:00', 'QLI', 1, 533)
 ('2018-03-17 12:00:00', 'GFIX', 3, 136)
 ('1996-11-07 13:39:40', 'GPRE', 4, 1)
 ('2017-02-05 20:37:00', 'DSQL', 7, 41)
diff --git a/src/msgs/messages2.sql b/src/msgs/messages2.sql
index 8c72ea3aa9..e6ce1f6a5b 100644
--- a/src/msgs/messages2.sql
+++ b/src/msgs/messages2.sql
@@ -1,7 +1,6 @@
 set bulk_insert INSERT INTO MESSAGES (SYMBOL, ROUTINE, MODULE, TRANS_NOTES, FAC_CODE, NUMBER, FLAGS, TEXT, "ACTION", EXPLANATION) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
 -- JRD
 (NULL, NULL, 'jrd.c', NULL, 0, 0, NULL, '', NULL, NULL);
-('arith_except', NULL, NULL, NULL, 0, 1, NULL, 'arithmetic exception, numeric overflow, or string truncation', NULL, NULL);
 ('bad_dbkey', NULL, NULL, NULL, 0, 2, NULL, 'invalid database key', NULL, NULL);
 ('bad_db_format', NULL, NULL, NULL, 0, 3, NULL, 'file @1 is not a valid database', NULL, NULL);
 ('bad_db_handle', NULL, NULL, NULL, 0, 4, NULL, 'invalid database handle (no active connection)', NULL, NULL);
@@ -1062,615 +1061,6 @@ Data source : @4', NULL, NULL)
 ('ses_reset_failed', NULL, 'Attachment.cpp', NULL, 0, 952, NULL, 'Reset of user session failed. Connection is shut down.', NULL, NULL);
 ('block_size', NULL, 'unix.cpp', NULL, 0, 953, NULL, 'File size is less than expected', NULL, NULL);
 ('tom_key_length', NULL, 'SysFunction.cpp', NULL, 0, 954, NULL, 'Invalid key length @1, need >@2', NULL, NULL);
--- QLI
-(NULL, NULL, NULL, NULL, 1, 0, NULL, 'expected type', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 1, NULL, 'bad block type', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 2, NULL, 'bad block size', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 3, NULL, 'corrupt pool', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 4, NULL, 'bad pool ID', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 5, NULL, 'memory exhausted', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 6, NULL, 'set option not implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 7, NULL, 'show option not implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 8, NULL, 'show_fields: dtype not done', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 9, NULL, 'INTERNAL: @1', NULL, NULL);
-(NULL, 'ERRQ_database_error', 'err.c', NULL, 1, 10, NULL, '** QLI error from database "@1" **', NULL, NULL);
-(NULL, 'ERRQ_database_error', 'err.c', NULL, 1, 11, NULL, '** QLI error from database **', NULL, NULL);
-(NULL, 'ERRQ_error', 'err.c', NULL, 1, 12, NULL, '** QLI error: @1 **', NULL, NULL);
-(NULL, 'ERRQ_syntax', 'err.c', NULL, 1, 13, NULL, 'expected @1, encountered "@2"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 14, NULL, 'integer overflow', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 15, NULL, 'integer division by zero', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 16, NULL, 'floating overflow trap', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 17, NULL, 'floating division by zero', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 18, NULL, 'floating underflow trap', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 19, NULL, 'floating overflow fault', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 20, NULL, 'floating underflow fault', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 21, NULL, 'arithmetic exception', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 22, NULL, 'illegal instruction or address, recovering...', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 23, NULL, 'Please retry, supplying an application script file name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 24, NULL, 'Welcome to QLI
-Query Language Interpreter', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 25, NULL, 'qli version @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 26, NULL, '
-Statistics for database "@1"
-@2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 27, NULL, 'HSH_remove failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 28, NULL, 'EVAL_boolean: not finished', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 29, NULL, 'EVAL_value: not finished', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 30, NULL, 'data type not supported for arithmetic', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 31, NULL, 'user name is supported in RSEs temporarily', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 32, NULL, 'Input value is too long', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 33, NULL, 'EXEC_execute: not implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 34, NULL, 'print_blob: expected field node', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 35, NULL, 'output pipe is not supported on VMS', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 36, NULL, 'could not create pipe', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 37, NULL, 'fdopen failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 38, NULL, 'execution terminated by signal', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 39, NULL, 'field validation error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 40, NULL, 'Request terminated by statement: @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 41, NULL, 'Request terminated by statement', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 42, NULL, 'Cannot open output file "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 43, NULL, 'Could not run "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 44, NULL, 'comparison not done', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 45, NULL, 'conversion not implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 46, NULL, 'conversion not implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 47, NULL, 'MOVQ_move: conversion not done', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 48, NULL, 'BLOB conversion is not supported', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 49, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 50, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 51, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 52, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 53, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 54, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 55, NULL, 'BLOB conversion is not supported', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 56, NULL, 'Error converting string "@1" to date', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 57, NULL, 'overflow during conversion', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 58, NULL, 'gds_$put_segment failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 59, NULL, 'fseek failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 60, NULL, 'unterminated quoted string', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 61, NULL, 'could not open scratch file', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 62, NULL, 'fseek failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 63, NULL, 'unterminated quoted string', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 64, NULL, 'unexpected end of procedure in procedure @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 65, NULL, 'unexpected end of file in file @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 66, NULL, 'unexpected eof', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 67, NULL, 'cannot open command file "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 68, NULL, 'PIC_edit: class not yet implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 69, NULL, 'conversion error', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 70, NULL, 'procedure "@1" is undefined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 71, NULL, 'procedure "@1" is undefined in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 72, NULL, 'procedure "@1" is undefined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 73, NULL, 'Could not create QLI$PROCEDURE_NAME field', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 74, NULL, 'Could not create QLI$PROCEDURE field', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 75, NULL, 'Could not create QLI$PROCEDURES table', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 76, NULL, 'procedure name "@1" in use in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 77, NULL, 'database handle required', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 78, NULL, 'QLI$PROCEDURES table must be created with RDO in Rdb/VMS databases', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 79, NULL, 'procedure name over 31 characters', NULL, NULL);
-(NULL, 'print_topic', 'help.e', NULL, 1, 80, NULL, '	[@1 topics matched @2]', NULL, NULL);
-(NULL, 'print_topic', 'help.e', NULL, 1, 81, NULL, '
-@1Sub-topics available:', NULL, NULL);
-(NULL, 'print_topic', 'help.e', NULL, 1, 82, NULL, '
-No help is available for @1 @2', NULL, NULL);
-(NULL, 'print_topic', 'help.e', NULL, 1, 83, NULL, '
-Sub-topics available for @1 are:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 84, NULL, 'Procedures can not be renamed across databases. Try COPY', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 85, NULL, 'Procedure @1 not found in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 86, NULL, 'substitute prompt string too long', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 87, NULL, 'substitute prompt string too long', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 88, NULL, 'Procedure @1 not found in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 89, NULL, 'Procedure @1 not found in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 90, NULL, 'No security classes defined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 91, NULL, '	Security class @1 is not defined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 92, NULL, '	No views defined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 93, NULL, '	No indexes defined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 94, NULL, '	No indexes defined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 95, NULL, 'No databases are currently ready', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 96, NULL, 'Procedure @1 in database "@2" (@3)', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 97, NULL, 'text, length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 98, NULL, 'varying text, length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 99, NULL, 'null terminated text, length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 100, NULL, 'short binary', NULL, 'no longer in use (1/7/94)');
-(NULL, NULL, NULL, NULL, 1, 101, NULL, 'long binary', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 102, NULL, 'quad', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 103, NULL, 'short floating', NULL, 'no longer in use (1/7/94)');
-(NULL, NULL, NULL, NULL, 1, 104, NULL, 'long floating', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 105, NULL, 'BLOB', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 106, NULL, ', segment length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 107, NULL, ', subtype @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 108, NULL, ', subtype BLR', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 109, NULL, ', subtype ACL', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 110, NULL, 'date', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 111, NULL, ', scale @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 112, NULL, ', subtype fixed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 113, NULL, 'Database "@1" readied as @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 114, NULL, 'Database "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 115, NULL, 'No databases are currently ready', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 116, NULL, '    Page size is @1 bytes.  Current allocation is @2 pages.', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 117, NULL, 'Field @1 does not exist in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 118, NULL, 'Field @1 does not exist in any open database', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 119, NULL, ' (computed expression)', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 120, NULL, 'There are no forms defined for database @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 121, NULL, 'There are no forms defined in any open database', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 122, NULL, 'Global field @1 does not exist in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 123, NULL, 'Global field @1 does not exist in any open database', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 124, NULL, 'There are no fields defined for database @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 125, NULL, 'There are no fields defined in any open database', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 126, NULL, 'Procedure @1 not found in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 127, NULL, 'Procedure @1 not found', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 128, NULL, 'Procedures in database "@1" (@2):', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 129, NULL, 'No triggers are defined for table @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 130, NULL, 'No triggers are defined in database @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 131, NULL, 'No triggers are defined in database @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 132, NULL, 'Variables:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 133, NULL, '    QLI, version "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 134, NULL, '    Version(s) for database "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 135, NULL, 'expand_expression: not yet implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 136, NULL, 'expand_statement: not yet implemented', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 137, NULL, 'variables may not be based on BLOB fields', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 138, NULL, 'cannot perform assignment to computed field @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 139, NULL, 'no context for ERASE', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 140, NULL, 'cannot erase from a join', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 141, NULL, '@1.* cannot be used when a single element is required', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 142, NULL, '"@1" is undefined or used out of context', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 143, NULL, 'no default form name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 144, NULL, 'No database for form @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 145, NULL, 'form @1 is not defined in database "@2"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 146, NULL, 'no context for form ACCEPT statement', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 147, NULL, 'field @1 is not defined in form @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 148, NULL, 'no context for modify', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 149, NULL, 'field list required for modify', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 150, NULL, 'No items in print list', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 151, NULL, 'No items in print list', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 152, NULL, 'invalid ORDER BY ordinal', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 153, NULL, 'asterisk expressions require exactly one qualifying context', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 154, NULL, 'unrecognized context', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 155, NULL, 'field referenced in BASED ON cannot be resolved against readied databases', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 156, NULL, 'expected statement, encountered "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 157, NULL, 'Expected PROCEDURE encountered "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 158, NULL, 'period in qualified name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 159, NULL, 'no databases are ready', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 160, NULL, 'BLOB variables are not supported', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 161, NULL, 'end of statement', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 162, NULL, 'end of command', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 163, NULL, 'quoted edit string', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 164, NULL, 'variable definition clause', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 165, NULL, '@1 is not a database', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 166, NULL, '@1 is not a table in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 167, NULL, 'variable data type', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 168, NULL, 'no data type may be specified for a variable based on a field', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 169, NULL, 'object type for DEFINE', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 170, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 171, NULL, 'comma between field definitions', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 172, NULL, 'FROM', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 173, NULL, 'table or view name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 174, NULL, '[', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 175, NULL, ']', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 176, NULL, 'No statements issued yet', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 177, NULL, 'ON or TO', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 178, NULL, 'quoted edit string', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 179, NULL, 'column definition clause', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 180, NULL, 'global fields may not be based on other fields', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 181, NULL, 'field name or asterisk expression', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 182, NULL, 'FROM RSE clause', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 183, NULL, 'comma', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 184, NULL, 'quoted header segment', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 185, NULL, 'left parenthesis', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 186, NULL, 'comma or terminating right parenthesis', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 187, NULL, 'left parenthesis', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 188, NULL, 'VALUES list or SELECT clause', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 189, NULL, 'the number of values do not match the number of fields', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 190, NULL, 'value expression', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 191, NULL, 'right parenthesis', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 192, NULL, 'quoted string', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 193, NULL, 'ENTREE or END', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 194, NULL, 'quoted string', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 195, NULL, 'index state option', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 196, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 197, NULL, 'ADD, MODIFY, or DROP', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 198, NULL, 'comma between field definitions', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 199, NULL, 'identifier', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 200, NULL, 'positive number', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 201, NULL, 'FORM', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 202, NULL, 'period in qualified table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 203, NULL, '@1 is not a table in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 204, NULL, 'database file name required on READY', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 205, NULL, 'EXISTS (SELECT * <sql rse>)', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 206, NULL, 'relational operator', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 207, NULL, 'a database has not been readied', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 208, NULL, 'expected "table_name", encountered "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 209, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 210, NULL, 'PROCEDURE', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 211, NULL, 'TOP or BOTTOM', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 212, NULL, 'report writer SET option', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 213, NULL, 'report item', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 214, NULL, 'set option', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 215, NULL, 'RELATIONS or TRIGGERS', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 216, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 217, NULL, 'database name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 218, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 219, NULL, 'database name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 220, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 221, NULL, 'database name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 222, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 223, NULL, 'table name', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 224, NULL, 'FROM clause', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 225, NULL, 'AVG, MAX, MIN, SUM, or COUNT', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 226, NULL, 'COUNT (*)', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 227, NULL, 'left parenthesis', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 228, NULL, 'OF', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 229, NULL, 'database handle', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 230, NULL, 'SET', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 231, NULL, 'database block not found for removal', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 232, NULL, 'show_fields: dtype not done', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 233, NULL, 'global field @1 already exists', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 234, NULL, 'Cannot define an index in a view', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 235, NULL, 'Index @1 already exists', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 236, NULL, 'Column @1 does not occur in table @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 237, NULL, 'Table @1 already exists', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 238, NULL, 'Field @1 is in use in the following relations:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 239, NULL, 'Field @1 is in use in database "@2"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 240, NULL, 'Field @1 is not defined in database "@2"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 241, NULL, 'Index @1 is not defined in database "@2"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 242, NULL, 'metadata operation failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 243, NULL, 'no active database for operation', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 244, NULL, 'Interactive metadata updates are not available on Rdb', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 245, NULL, 'global field @1 is not defined', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 246, NULL, 'Index @1 does not exist in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 247, NULL, 'field @1 does not exist', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 248, NULL, 'no active database for operation', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 249, NULL, 'Interactive metadata updates are not available on Rdb', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 250, NULL, 'Unlicensed for database "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 251, NULL, 'Field @1 already exists in relation @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 252, NULL, 'data type cannot be changed locally', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 253, NULL, 'global field @1 does not exist', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 254, NULL, 'field @1 not found in relation @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 255, NULL, 'Data type conflict with existing global field @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 256, NULL, 'No data type specified for field @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 257, NULL, 'database info call failed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 258, NULL, 'do not understand BLR operator @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 259, NULL, 'Operation unlicensed for database "@1"', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 260, NULL, '    Security class for database @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 261, NULL, '    Database description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 262, NULL, '    Database description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 263, NULL, '	File:	@1 starting at page @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 264, NULL, 'Field @1 in @2 @3 of database @4', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 265, NULL, '    Global field @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 266, NULL, '    Field description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 267, NULL, '    Datatype information:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 268, NULL, '    Field is computed from:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 269, NULL, '    Field validation:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 270, NULL, '    Security class @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 271, NULL, '    Query name:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 272, NULL, '    Query name:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 273, NULL, '    Edit string:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 274, NULL, '    Edit string:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 275, NULL, '    Query header:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 276, NULL, 'Global field @1 in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 277, NULL, '    Field description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 278, NULL, '    Datatype information:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 279, NULL, '    Field is computed from:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 280, NULL, '    Field validation:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 281, NULL, '    Query name:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 282, NULL, '    Edit string:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 283, NULL, '    Query header:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 284, NULL, '    @1 is not used in any relations in database @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 285, NULL, 'Forms in database @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 286, NULL, 'Global fields for database @1:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 287, NULL, '    Field description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 288, NULL, '        Index @1@2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 289, NULL, '            index @1 is NOT active', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 290, NULL, '        Index @1@2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 291, NULL, '    Description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 292, NULL, '    Security class @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 293, NULL, '    Stored in external file @1', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 294, NULL, 'OBSOLETE -        An erase trigger is defined for @1', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 295, NULL, 'OBSOLETE -        A modify trigger is defined for @1', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 296, NULL, 'OBSOLETE -        A store trigger is defined for @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 297, NULL, '    Security classes for database @1', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 298, NULL, 'OBSOLETE -	Triggers for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 299, NULL, 'OBSOLETE -    Source for the erase trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 300, NULL, 'OBSOLETE -    Erase trigger for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 301, NULL, 'OBSOLETE -    Source for the modify trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 302, NULL, 'OBSOLETE -    Modify trigger for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 303, NULL, 'OBSOLETE -    Source for the store trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 304, NULL, 'OBSOLETE -    Store trigger for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 305, NULL, 'OBSOLETE -    Triggers for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 306, NULL, 'OBSOLETE -    Source for the erase trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 307, NULL, 'OBSOLETE -    Erase trigger for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 308, NULL, 'OBSOLETE -    Source for the modify trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 309, NULL, 'OBSOLETE -    Modify trigger for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 310, NULL, 'OBSOLETE -    Source for the store trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, NULL, NULL, '
-This message is obsolete for version 4.3 and above.  No
-need to translate.
-
-1996-Aug-06 David Schnepper', 1, 311, NULL, 'OBSOLETE -    Store trigger for relation @1:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 312, NULL, '
-    View source for relation @1 is not available.  View BLR:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 313, NULL, '
-    Relation @1 is a view defined as:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 314, NULL, 'Views in database @1:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 315, NULL, '    @1 comprised of :', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 316, NULL, 'Views in database @1:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 317, NULL, '    @1 comprised of:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 318, NULL, 'BLOB', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 319, NULL, ', segment length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 320, NULL, ', subtype text', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 321, NULL, ', subtype BLR', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 322, NULL, ', subtype ACL', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 323, NULL, ', subtype @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 324, NULL, 'text, length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 325, NULL, 'varying text, length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 326, NULL, 'null terminated text, length @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 327, NULL, 'short binary', NULL, 'no longer in use (1/7/94)');
-(NULL, NULL, NULL, NULL, 1, 328, NULL, 'long binary', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 329, NULL, 'quadword binary', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 330, NULL, 'short floating', NULL, 'no longer in use (1/7/94)');
-(NULL, NULL, NULL, NULL, 1, 331, NULL, 'long floating', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 332, NULL, 'date', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 333, NULL, ', scale @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 334, NULL, ', subtype fixed', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 335, NULL, '    Global field @1 is used in database @2 as :', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 336, NULL, '	@1 in relation @2', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 337, NULL, 'Field @1 in @2 @3 of database @4', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 338, NULL, '    Global field @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 339, NULL, '    Field description:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 340, NULL, '    Datatype information', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 341, NULL, '    Field is computed from:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 342, NULL, '    Field validation:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 343, NULL, '    Query name:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 344, NULL, '    Query name:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 345, NULL, '    Query header:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 346, NULL, '    Edit string:	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 347, NULL, '    Edit string: 	 @1', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 348, NULL, '@1 Based on field @2 of @3@4', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 349, NULL, '@1Base field description for @2:', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 350, NULL, 'END PROCEDURE', NULL, NULL);
-(NULL, 'process_statement', 'dtr.c', NULL, 1, 351, NULL, 'Do you want to roll back your updates?', NULL, NULL);
-(NULL, 'gen_descriptor', 'gener.c', NULL, 1, 352, NULL, 'gen_descriptor: dtype not recognized', NULL, NULL);
-(NULL, 'gen_expression', 'gener.c', NULL, 1, 353, NULL, 'gen_expression: not understood', NULL, NULL);
-(NULL, 'gen_statement', 'gener.c', NULL, 1, 354, NULL, 'gen_statement: not yet implemented', NULL, NULL);
-(NULL, 'gen_statistical', 'gener.c', NULL, 1, 355, NULL, 'gen_statistical: not understood', NULL, NULL);
-(NULL, 'compile_edit', 'compile.c', NULL, 1, 356, NULL, 'EDIT argument must be a BLOB field', NULL, NULL);
-(NULL, 'compile_rse', 'compile.c', NULL, 1, 357, NULL, 'relations from multiple databases in single RSE', NULL, NULL);
-(NULL, 'compile_edit', 'compile.c', NULL, 1, 358, NULL, 'cannot find database for BLOB edit', NULL, NULL);
-(NULL, 'compile_expression', 'compile.c', NULL, 1, 359, NULL, 'compile_expression: not yet implemented', NULL, NULL);
-(NULL, 'compile_statement', 'compile.c', NULL, 1, 360, NULL, 'not yet implemented (compile_statement)', NULL, NULL);
-(NULL, 'computable', 'compile.c', NULL, 1, 361, NULL, 'computable: not yet implemented', NULL, NULL);
-(NULL, 'make_descriptor', 'compile.c', NULL, 1, 362, NULL, 'make_descriptor: not yet implemented', NULL, NULL);
-(NULL, 'make_reference', 'compile.c', NULL, 1, 363, NULL, 'missing message', NULL, NULL);
-(NULL, 'release_message', 'compile.c', NULL, 1, 364, NULL, 'lost message', NULL, NULL);
-(NULL, 'MET_show_trigger', 'meta.e', NULL, 1, 365, NULL, 'Triggers for relation @1:', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 366, NULL, '    @1	@2, Sequence @3, @4', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 367, NULL, 'Pre-store', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 368, NULL, 'Post-store', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 369, NULL, 'Pre-modify', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 370, NULL, 'Post-modify', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 371, NULL, 'Pre-erase', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 372, NULL, 'Post-erase', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 373, NULL, 'Active', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 374, NULL, 'Inactive', NULL, NULL);
-(NULL, 'show_trigger_header', 'meta.e', NULL, 1, 375, NULL, '	Description:', NULL, NULL);
-(NULL, 'MET_show_trigger', 'meta.e', NULL, 1, 376, NULL, '	Source for the trigger:', NULL, NULL);
-(NULL, 'MET_show_trigger', 'meta.e', NULL, 1, 377, NULL, '	Source for the trigger is not available.  Trigger BLR:', NULL, NULL);
-(NULL, 'show_sys_trigs', 'command.c', NULL, 1, 378, NULL, 'No system triggers are defined', NULL, NULL);
-(NULL, 'MET_show_system_triggers', 'meta.e', NULL, 1, 379, NULL, 'System Trigger for relation @1', NULL, NULL);
-(NULL, 'MET_show_rel_detail', 'meta.e', NULL, 1, 380, NULL, '	Triggers defined for this relation:', NULL, NULL);
-(NULL, 'MET_show_triggers', 'meta.e', NULL, 1, 381, NULL, 'Trigger for relation @1:', NULL, NULL);
-(NULL, 'parse_report', 'parse.c', NULL, 1, 382, NULL, 'TOP or BOTTOM', NULL, NULL);
-(NULL, 'parse_report', 'parse.c', NULL, 1, 383, NULL, 'sort field', NULL, NULL);
-(NULL, 'parse_rse', 'parse.c', NULL, 1, 384, NULL, 'Too many WITHs', NULL, NULL);
-(NULL, 'MET_show_dbb_detail', 'META.E', NULL, 1, 385, NULL, '	Shadow @1, File: @2 starting at page @3', NULL, NULL);
-(NULL, 'parse_sql_create', 'parse.c', NULL, 1, 386, NULL, 'DATABASE, TABLE, or INDEX', NULL, NULL);
-(NULL, 'parse_sql_database_create', 'parse.c', NULL, 1, 387, NULL, 'Database filename required in CREATE', NULL, NULL);
-(NULL, 'parse_sql_dtype', 'parse.c', NULL, 1, 388, NULL, 'FLOAT', NULL, NULL);
-(NULL, 'parse_sql_create', 'parse.c', NULL, 1, 389, NULL, 'INDEX', NULL, NULL);
-(NULL, 'parse_sql_database_create', 'parse.c', NULL, 1, 390, NULL, 'Multiple page size specifications', NULL, NULL);
-(NULL, 'parse_sql_rse', 'parse.c', NULL, 1, 391, NULL, 'GROUP BY not allowed in view definition', NULL, NULL);
-(NULL, 'parse_sql_statistical', 'parse.c', NULL, 1, 392, NULL, 'Aggregates not allowed in view definition', NULL, NULL);
-(NULL, 'parse_sql_field', 'parse.c', NULL, 1, 393, NULL, 'NULL', NULL, NULL);
-(NULL, 'parse_sql_view_create', 'parse.c', NULL, 1, 394, NULL, 'AS', NULL, NULL);
-(NULL, 'parse_sql_view_create', 'parse.c', NULL, 1, 395, NULL, 'SELECT', NULL, NULL);
-(NULL, 'parse_sql_database_create', 'parse.c', NULL, 1, 396, NULL, '=', NULL, NULL);
-(NULL, 'parse_sql_index_create', 'parse.c', NULL, 1, 397, NULL, 'ON', NULL, NULL);
-(NULL, 'parse_sql_grant', 'parse.c', NULL, 1, 398, NULL, 'field name', NULL, NULL);
-(NULL, 'parse_sql_grant', 'parse.c', NULL, 1, 399, NULL, 'table name', NULL, NULL);
-(NULL, 'parse_sql_grant', 'parse.c', NULL, 1, 400, NULL, 'user name identifier', NULL, NULL);
-(NULL, 'parse_sql_grant', 'parse.c', NULL, 1, 401, NULL, 'GRANT', NULL, NULL);
-(NULL, 'parse_sql_grant', 'parse.c', NULL, 1, 402, NULL, 'OPTION', NULL, NULL);
-(NULL, 'parse_sql_revoke', 'parse.c', NULL, 1, 403, NULL, 'FROM', NULL, NULL);
-(NULL, 'parse_sql_grant', 'parse.c', NULL, 1, 404, NULL, 'TO', NULL, NULL);
-(NULL, 'parse_sql_alter', 'parse.c', NULL, 1, 405, NULL, 'ADD or DROP', NULL, NULL);
-(NULL, 'MET_define_sql_relation', 'meta.e', NULL, 1, 406, NULL, 'Dynamic DDL buffer exceeded', NULL, NULL);
-(NULL, 'parse_sql_alter', 'parse.c', NULL, 1, 407, NULL, 'TABLE', NULL, NULL);
-(NULL, 'parse_ready', 'parse.c', NULL, 1, 408, NULL, 'Database handle @1 conflicts with an established name', NULL, NULL);
-(NULL, 'create_qli_procedrues', 'PROC.E', NULL, 1, 409, NULL, 'Could not create QLI$PROCEDURES index', NULL, NULL);
-(NULL, NULL, 'MOV', NULL, 1, 410, NULL, 'Cannot convert from @1 to @2', NULL, NULL);
-(NULL, 'MOVQ_decompose', 'MOV', NULL, 1, 411, NULL, 'Cannot convert "@1" to a numeric value', NULL, NULL);
-(NULL, 'expand_function', 'EXPAND.C', NULL, 1, 412, NULL, 'function @1 not found in database @2', NULL, NULL);
-(NULL, 'clone_global_fields', 'META.E', NULL, 1, 413, NULL, 'Incompatible global field @1 already exists in target database', NULL, NULL);
-(NULL, 'MET_sql_alter_table', 'META.E', NULL, 1, 414, NULL, 'Relation @1 is missing or undefined', NULL, NULL);
-(NULL, 'CMD_set', 'command.c', NULL, 1, 415, NULL, 'matching language string too long', NULL, NULL);
-(NULL, 'show_m_funcs', 'SHOW.E', NULL, 1, 416, NULL, 'Functions in database "@1" (@2):', NULL, NULL);
-(NULL, 'show_funcs', 'show.e', NULL, 1, 417, NULL, 'Functions are not supported in database @1.', NULL, NULL);
--- 418 doesn't exist
-(NULL, 'show_funcs', 'show.e', NULL, 1, 419, NULL, 'There are no functions defined in any open database.', NULL, NULL);
-(NULL, 'show_funcs', 'show.e', NULL, 1, 420, NULL, 'Functions are not supported in any open database.', NULL, NULL);
-(NULL, 'show_m_func', 'show.e', NULL, 1, 421, NULL, '    Function description:', NULL, NULL);
-(NULL, 'show_func', 'show.e', NULL, 1, 422, NULL, 'Function @1 is not defined in database @2.', NULL, NULL);
-(NULL, 'show_func', 'show.e', NULL, 1, 423, NULL, 'Function @1 is not defined in any open database.', NULL, NULL);
-(NULL, 'show_m_func', 'show.e', NULL, 1, 424, NULL, 'Function @1 (@2) in database "@3" (@4):', NULL, NULL);
-(NULL, 'show_m_func', 'show.e', NULL, 1, 425, NULL, 'Function @1 in database "@2" (@3):', NULL, NULL);
-(NULL, 'show_m_func', 'show.e', NULL, 1, 426, NULL, '    Function library is @1', NULL, NULL);
-(NULL, 'show_m_func', 'show.e', NULL, 1, 427, NULL, '    Return argument is', NULL, NULL);
-(NULL, 'show_m_func', 'show.e', NULL, 1, 428, NULL, '    Argument @1 is', NULL, NULL);
-(NULL, 'parse_drop', 'PARSE.C', NULL, 1, 429, NULL, 'database file name required on DROP DATABASE', NULL, NULL);
-(NULL, 'MET_delete_database', 'META.E', NULL, 1, 430, NULL, 'Unlicensed for database "@1"', NULL, NULL);
-(NULL, 'MET_delete_database', 'META.E', NULL, 1, 431, NULL, 'Could not drop database file "@1"', NULL, NULL);
-(NULL, 'MET_delete_database', 'META.E', NULL, 1, 432, NULL, 'Operation unlicensed for database "@1"', NULL, NULL);
-(NULL, 'show_datatype', 'SHOW.E', NULL, 1, 433, NULL, ' array', NULL, NULL);
-(NULL, 'ALL_alloc', 'ALL.c', NULL, 1, 434, NULL, 'memory pool free list is incorrect', NULL, NULL);
-(NULL, 'ALL_release', 'ALL.C', NULL, 1, 435, NULL, 'block released twice', NULL, NULL);
-(NULL, 'ALL_release', 'ALL.C', NULL, 1, 436, NULL, 'released block overlaps following free block', NULL, NULL);
-(NULL, 'ALL_release', 'ALL.C', NULL, 1, 437, NULL, 'released block overlaps prior free block', NULL, NULL);
-(NULL, 'check_for_array', 'EXPAND.C', NULL, 1, 438, NULL, 'References to array fields like @1 in relation @2 are not supported', NULL, NULL);
-(NULL, 'show_filter', 'show.e', NULL, 1, 439, NULL, 'Filters are not supported in database @1.', NULL, NULL);
-(NULL, 'show_filter', 'show.e', NULL, 1, 440, NULL, 'Filter @1 is not defined in database @2.', NULL, NULL);
-(NULL, 'show_filter', 'show.e', NULL, 1, 441, NULL, 'Filter @1 is not defined in any open database.', NULL, NULL);
-(NULL, 'show_filter', 'show.e', NULL, 1, 442, NULL, 'Filters are not supported in any open database.', NULL, NULL);
-(NULL, 'show_filters', 'show.e', NULL, 1, 443, NULL, 'There are no filters defined in any open database.', NULL, NULL);
-(NULL, 'show_m_filter', 'show.e', NULL, 1, 444, NULL, 'Filter @1 in database "@2" (@3):', NULL, NULL);
-(NULL, 'show_m_filter', 'show.e', NULL, 1, 445, NULL, '    Filter library is @1', NULL, NULL);
-(NULL, 'show_m_filter', 'show.e', NULL, 1, 446, NULL, '    Input sub-type is @1', NULL, NULL);
-(NULL, 'show_m_filter', 'show.e', NULL, 1, 447, NULL, '    Output sub-type is @1', NULL, NULL);
-(NULL, 'show_m_filter', 'show.e', NULL, 1, 448, NULL, '    Filter description:', NULL, NULL);
-(NULL, 'show_m_filters', 'show.e', NULL, 1, 449, NULL, 'Filters in database @1 (@2):', NULL, NULL);
-(NULL, 'show_m_indices', 'SHOW.E', NULL, 1, 450, NULL, '	Index @1@2@3@4', NULL, NULL);
-(NULL, 'expand_rse', 'EXPAND.C', NULL, 1, 451, NULL, 'simple field reference not allowed in global aggregates', NULL, NULL);
-(NULL, 'expand_values', 'EXPAND.C', NULL, 1, 452, NULL, 'prompting not allowed in select field list', NULL, NULL);
-(NULL, 'EXEC_open_output', 'exe.c', NULL, 1, 453, NULL, 'output pipe is not supported on MPE/XL', NULL, NULL);
-(NULL, 'expand_expression', 'expand.c', NULL, 1, 454, NULL, 'could not resolve context for aggregate expression', NULL, NULL);
-(NULL, 'clone_fields', 'META.E', NULL, 1, 455, NULL, 'source relation @1 does not exist', NULL, NULL);
-(NULL, 'show_trigger_messages', 'show.e', NULL, 1, 456, NULL, 'Messages associated with @1:', NULL, NULL);
-(NULL, 'show_trigger_messages', 'show.e', NULL, 1, 457, NULL, '    message @1:  @2', NULL, NULL);
-(NULL, 'ERRQ_database_error', 'err.c', NULL, 1, 458, NULL, 'Connection to database @1 lost.
-	Please FINISH the database!', NULL, NULL);
-(NULL, 'FORM_lookup_form', 'form', NULL, 1, 459, NULL, 'Unable to create form window', NULL, NULL);
-COMMIT WORK;
-(NULL, 'process_statement', 'DTR', NULL, 1, 460, NULL, 'Do you want to rollback updates for @1?', NULL, NULL);
-(NULL, 'show_funcs', 'show.e', NULL, 1, 461, NULL, 'functions are not supported in database @1', NULL, NULL);
-(NULL, 'show_funcs', 'show.e', NULL, 1, 462, NULL, 'no functions are defined in database @1', NULL, NULL);
-(NULL, 'show_filts', 'show.e', NULL, 1, 463, NULL, 'filters are not supported in database @1', NULL, NULL);
-(NULL, 'show_filts', 'show.e', NULL, 1, 464, NULL, 'no filters are defined for database @1', NULL, NULL);
-(NULL, 'CMD_transaction', 'command.c', NULL, 1, 465, NULL, 'Error during two phase commit on database @1.
-Roll back all databases or commit databases individually', NULL, NULL);
-(NULL, 'expand_expression', 'expand.c', NULL, 1, 466, NULL, 'Only fields may be subscripted', NULL, NULL);
-(NULL, 'expand_field', 'expand.c', NULL, 1, 467, NULL, '"@1" is not a field and so may not be subscripted', NULL, NULL);
-(NULL, 'MET_modify_field', 'meta.e', NULL, 1, 468, NULL, 'Data type of field @1 may not be changed to or from BLOB', NULL, NULL);
-(NULL, 'main', 'dtr.c', NULL, 1, 469, NULL, 'qli: ignoring unknown switch -@1', NULL, 'obsolete, see 529');
-(NULL, 'LEX_token', 'LEX', NULL, 1, 470, NULL, 'literal string  <MAXSYMLEN> characters or longer', NULL, NULL);
-(NULL, 'show_var', 'show.e', NULL, 1, 471, NULL, 'Variable @1', NULL, NULL);
-(NULL, 'show_var', 'show.e', NULL, 1, 472, NULL, '    Query name:	 @1', NULL, NULL);
-(NULL, 'show_var', 'show.e', NULL, 1, 473, NULL, '    Edit string:	 @1', NULL, NULL);
-(NULL, 'show_var', 'show.e', NULL, 1, 474, NULL, 'Variable @1 has not been declared', NULL, NULL);
-(NULL, 'show_var', 'show.e', NULL, 1, 475, NULL, '    Datatype information:', NULL, NULL);
-(NULL, 'LEX_get_line', 'lex.c', NULL, 1, 476, NULL, 'input line too long', NULL, NULL);
-(NULL, 'get_line', 'lex.c', NULL, 1, 477, NULL, 'input line too long', NULL, NULL);
-(NULL, 'parse_print_list', 'parse.c', NULL, 1, 478, NULL, 'number > 0', NULL, NULL);
-(NULL, 'array_dimensions', 'SHOW.E', NULL, 1, 479, NULL, ' (@1)', NULL, NULL);
-(NULL, 'format_value', 'format.c', NULL, 1, 480, NULL, 'cannot format unsubscripted array @1', NULL, NULL);
-(NULL, 'extend_pool', 'ALL.C', NULL, 1, 481, NULL, 'unsuccessful attempt to extend pool beyond 64KB', NULL, NULL);
-(NULL, 'FMT_format', 'FORMAT.C', NULL, 1, 482, NULL, 'field width (@1) * header segments (@2) greater than 60,000 characters', NULL, NULL);
-(NULL, 'define_relation', 'META.E', NULL, 1, 483, NULL, 'Relation @1 does not exist', NULL, NULL);
-(NULL, NULL, NULL, NULL, 1, 484, NULL, 'FORMs not supported', NULL, NULL);
-(NULL, 'show_indices_detail', 'show.e', NULL, 1, 485, NULL, '	Expression index BLR:', NULL, NULL);
-(NULL, 'parse_statistical', 'parse.c', NULL, 1, 487, NULL, 'Invalid argument for UDF', NULL, NULL);
-(NULL, 'parse_relational', 'parse.c', NULL, 1, 488, NULL, 'SINGULAR (SELECT * <sql rse>)', NULL, NULL);
-(NULL, 'parse_join_type', 'parse.c', NULL, 1, 489, NULL, 'JOIN', NULL, NULL);
-(NULL, 'show_field_detail', 'show.e', NULL, 1, 495, NULL, 'Field @1 in view @2 of database @3', NULL, NULL);
-(NULL, 'show_field_detail', 'show.e', NULL, 1, 496, NULL, 'Field @1 in relation @2 of database @3', NULL, NULL);
-(NULL, 'yes_no', 'dtr.c', NULL, 1, 497, NULL, 'YES', NULL, NULL);
-(NULL, 'yes_no', 'dtr.c', NULL, 1, 498, NULL, 'NO', NULL, NULL);
-(NULL, 'EVAL_value', 'eval.c', NULL, 1, 499, NULL, 'Re-enter', NULL, NULL);
-(NULL, 'EVAL_value', 'eval.c', NULL, 1, 500, NULL, 'Enter', NULL, NULL);
-(NULL, 'global', 'format.c', NULL, 1, 501, NULL, 'bad kanji found while formatting output', NULL, NULL);
-(NULL, 'print_more', 'help.e', 'This message should be followed by 1 blank space: "Subtopic? "', 1, 502, NULL, 'Subtopic? ', NULL, NULL);
-(NULL, 'print_topic', 'help.e', 'There should be 1 blank space after the colon: " ... stop: "', 1, 503, NULL, '\ntype <cr> for next topic or <EOF> to stop: ', NULL, NULL);
-(NULL, 'mover_error', 'mov.c', NULL, 1, 504, NULL, 'unknown data type @1', NULL, NULL);
-(NULL, 'process_statement', 'dtr.c', 'This messages should be preceded by 4 blank spaces: "    reads ..."', 1, 505, NULL, '    reads = !r writes = !w fetches = !f marks = !m', NULL, NULL);
-(NULL, 'process_statement', 'dtr.c', 'This message should be preceded by 4 blank spaces: "    elapsed ... "', 1, 506, NULL, '    elapsed = !e cpu = !u system = !s mem = !x buffers = !b', NULL, NULL);
-(NULL, 'view_info', 'show.e', NULL, 1, 507, NULL, '@1 Based on field @2 of relation @3', NULL, NULL);
-(NULL, 'view_info', 'show.e', NULL, 1, 508, NULL, '@1 Based on field @2 of view @3', NULL, NULL);
-(NULL, 'parse_sql_dtype', 'parse.cpp', NULL, 1, 509, NULL, 'PRECISION', NULL, NULL);
-(NULL, 'parse_sql_dtype', 'parse.cpp', NULL, 1, 510, NULL, 'Field scale exceeds allowed range', NULL, NULL);
-(NULL, 'parse_sql_dtype', 'parse.cpp', NULL, 1, 511, NULL, 'Field length exceeds allowed range', NULL, NULL);
-(NULL, 'parse_sql_dtype', 'parse.cpp', NULL, 1, 512, NULL, 'Field length should be greater than zero', NULL, NULL);
--- Do not change the arguments of the previous QLI messages.
--- Write the new QLI messages here.
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 513, NULL, 'Usage: qli [options] ["<command>"]', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 514, NULL, '   <command> may be a single qli command or a series of qli commands\n   separated by semicolons', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 515, NULL, 'Valid options are:', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 516, NULL, '   -a(pp_script)       application script <name>', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 517, NULL, '   -b(uffers)          set page buffers <n>', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 518, NULL, '   -f(etch_password)   fetch password from file', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 519, NULL, '   -i(nit_script)      startup script <name>', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 520, NULL, '   -n(obanner)         do not show the welcome message', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 521, NULL, '   -p(assword)         user''s password', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 522, NULL, '   -tra(ce)            show internal parser''s tokens', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 523, NULL, '   -tru(sted_auth)     use trusted authentication', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 524, NULL, '   -u(ser)             user name', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 525, NULL, '   -v(erify)           echo input', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 526, NULL, '   -z                  show program version', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 527, NULL, '   Options can be abbreviated to the unparenthesized characters', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 528, NULL, 'Start qli without [command] to enter interactive mode', NULL, NULL)
-(NULL, 'main', 'dtr.cpp', NULL, 1, 529, NULL, 'qli: ignoring unknown switch @1', NULL, NULL)
-(NULL, 'install', 'meta.epp', NULL, 1, 530, NULL, 'Warning: cannot issue DDL statements against database "@1"', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 531, NULL, '   -nod(btriggers)     do not run database triggers', NULL, NULL)
-(NULL, 'usage', 'dtr.cpp', NULL, 1, 532, NULL, '   -e(xit)             exit after end of script instead going to command prompt', NULL, NULL)
 -- GFIX
 ('gfix_db_name', 'ALICE_gfix', 'alice.c', NULL, 3, 1, NULL, 'data base file name (@1) already given', NULL, NULL);
 ('gfix_invalid_sw', 'ALICE_gfix', 'alice.c', NULL, 3, 2, NULL, 'invalid switch @1', NULL, NULL);
diff --git a/src/msgs/system_errors2.sql b/src/msgs/system_errors2.sql
index 6a34559c91..164eae3cf1 100644
--- a/src/msgs/system_errors2.sql
+++ b/src/msgs/system_errors2.sql
@@ -1,7 +1,6 @@
 -- Take note the new format uses FAC_CODE, NUMBER in the same order as messages2.sql.
 set bulk_insert INSERT INTO SYSTEM_ERRORS (SQL_CODE, SQL_CLASS, SQL_SUBCLASS, FAC_CODE, NUMBER, GDS_SYMBOL, SEVERITY, SEVERITY_TEXT) VALUES (?, ?, ?, ?, ?, ?, ?, ?);
 -- JRD
-(-802, '22', '000', 0, 1, 'arith_except', NULL, 'ERROR')
 (-901, 'HY', '000', 0, 2, 'bad_dbkey', NULL, 'ERROR')
 (-922, 'HY', '000', 0, 3, 'bad_db_format', NULL, 'ERROR')
 (-904, '08', '003', 0, 4, 'bad_db_handle', NULL, 'ERROR')
diff --git a/src/msgs/transmsgs.de_DE2.sql b/src/msgs/transmsgs.de_DE2.sql
index 7f637833ce..0036ac5fa6 100644
--- a/src/msgs/transmsgs.de_DE2.sql
+++ b/src/msgs/transmsgs.de_DE2.sql
@@ -2,7 +2,6 @@ set bulk_insert INSERT INTO TRANSMSGS (ENG_TEXT, ENG_ACTION, ENG_EXPLANATION, FA
 -- Notice LOCALE is hardcoded as 'de_DE' in the INSERT statement and therefore the rows below have one fields less than the table.
 -- JRD
 ('', NULL, NULL, 0, 0, '', NULL, NULL, 'daves', '1993-07-16 12:15:54')
-('arithmetic exception, numeric overflow, or string truncation', NULL, NULL, 0, 1, 'Arithmetischer Fehler, numerischer berlauf oder Zeichenkette abgeschnitten', NULL, NULL, 'daves', '1993-07-16 12:16:07')
 ('invalid database key', NULL, NULL, 0, 2, 'Datenbankschlssel ungltig', NULL, NULL, 'daves', '1993-07-16 12:16:07')
 ('file @1 is not a valid database', NULL, NULL, 0, 3, 'Die Datei @1 ist keine gltige Datenbank', NULL, NULL, 'daves', '1993-07-16 12:16:07')
 ('invalid database handle (no active connection)', NULL, NULL, 0, 4, 'Datenbank-Handle ungltig (###)', NULL, NULL, 'daves', '1993-07-16 12:16:07')
@@ -739,537 +738,6 @@ segmented) blob.', 'daves', '1993-07-16 12:15:53')
 ('Cannot take a table reservation isc_tpb_lock_write in TPB because the transaction is in read only mode', NULL, NULL, 0, 591, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
 ('value exceeds the range for a valid time', NULL, NULL, 0, 592, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
 ('value exceeds the range for valid timestamps', NULL, NULL, 0, 593, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
--- QLI
-('expected type', NULL, NULL, 1, 0, 'Erwartet: Typ', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('bad block type', NULL, NULL, 1, 1, 'Block-Typ ist ungltig', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('bad block size', NULL, NULL, 1, 2, 'Block-Lnge ist ungltig', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('corrupt pool', NULL, NULL, 1, 3, 'Pool ist fehlerhaft', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('bad pool ID', NULL, NULL, 1, 4, 'Pool-ID ungltig', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('memory exhausted', NULL, NULL, 1, 5, 'Zu wenig Speicherraum', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('set option not implemented', NULL, NULL, 1, 6, 'SET-Option nicht verfgbar', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('show option not implemented', NULL, NULL, 1, 7, 'SHOW-Option nicht verfgbar', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('show_fields: dtype not done', NULL, NULL, 1, 8, 'show_fields: Datentyp noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('INTERNAL: @1', NULL, NULL, 1, 9, 'INTERNAL: @1', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('** QLI error from database "@1" **', NULL, NULL, 1, 10, '** Von der Datenbank "@1" stammender QLI-Fehler **', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('** QLI error from database **', NULL, NULL, 1, 11, '** Von der Datenbank stammender QLI-Fehler **', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('** QLI error: @1 **', NULL, NULL, 1, 12, '** QLI-Fehler: @1 **', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('expected @1, encountered "@2"', NULL, NULL, 1, 13, 'Erwartet: @1, gefunden: "@2"', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('integer overflow', NULL, NULL, 1, 14, 'Ganzzahlen-berlauf', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('integer division by zero', NULL, NULL, 1, 15, 'Integer-Division durch Null', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('floating overflow trap', NULL, NULL, 1, 16, 'FLOAT-berlauf', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('floating division by zero', NULL, NULL, 1, 17, 'FLOAT-Division durch Null', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('floating underflow trap', NULL, NULL, 1, 18, 'FLOAT-Unterlauf', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('floating overflow fault', NULL, NULL, 1, 19, 'FLOAT-berlauf-Versagen', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('floating underflow fault', NULL, NULL, 1, 20, 'FLOAT-Unterlauf-Versagen', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('arithmetic exception', NULL, NULL, 1, 21, 'Arithmetischer Fehler', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('illegal instruction or address, recovering...', NULL, NULL, 1, 22, 'Instruktion oder Adresse unzulssig! Wiederherstellungsverfahren luft ...', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('Please retry, supplying an application script file name', NULL, NULL, 1, 23, 'Bitte nochmals den Namen einer Anwendungs-Skriptdatei eingeben', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('Welcome to QLI
-Query Language Interpreter', NULL, NULL, 1, 24, 'Willkommen bei QLI, dem
-Query Language Interpreter', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('qli version @1', NULL, NULL, 1, 25, 'QLI-Version @1', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('
-Statistics for database "@1"
-@2', NULL, NULL, 1, 26, '
-Statistiken fr die Datenbank "@1"
-@2', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('HSH_remove failed', NULL, NULL, 1, 27, 'Fehler bei HSH_remove', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('EVAL_boolean: not finished', NULL, NULL, 1, 28, 'EVAL_boolean: nicht beendet', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('EVAL_value: not finished', NULL, NULL, 1, 29, 'EVAL_value: nicht beendet', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('data type not supported for arithmetic', NULL, NULL, 1, 30, 'Dieser Datentyp wird fr arithmetische Operationen nicht untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('user name is supported in RSEs temporarily', NULL, NULL, 1, 31, 'Der Benutzername wird in RSEs temporr untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Input value is too long', NULL, NULL, 1, 32, 'Der Eingabewert ist zu lang', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('EXEC_execute: not implemented', NULL, NULL, 1, 33, 'EXEC_execute: nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('print_blob: expected field node', NULL, NULL, 1, 34, 'print_blob: Feldknoten erwartet', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('output pipe is not supported on VMS', NULL, NULL, 1, 35, 'Ausgabe-Pipe wird von VMS nicht untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('could not create pipe', NULL, NULL, 1, 36, 'Die Pipe konnte nicht erstellt werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('fdopen failed', NULL, NULL, 1, 37, 'Fehler bei fdopen', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('execution terminated by signal', NULL, NULL, 1, 38, 'Ausfhrung durch Signal beendet', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('field validation error', NULL, NULL, 1, 39, 'Fehler bei der Feldvalidierung', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Request terminated by statement: @1', NULL, NULL, 1, 40, 'Anforderung (REQUEST) durch Anweisung beendet: @1', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Request terminated by statement', NULL, NULL, 1, 41, 'Anforderung (REQUEST) durch Anweisung beendet', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Cannot open output file "@1"', NULL, NULL, 1, 42, 'Die Ausgabedatei "@1" kann nicht geffnet werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Could not run "@1"', NULL, NULL, 1, 43, '"@1" konnte nicht gestartet werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('comparison not done', NULL, NULL, 1, 44, 'Vergleich noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion not implemented', NULL, NULL, 1, 45, 'Konvertierung nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion not implemented', NULL, NULL, 1, 46, 'Konvertierung nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('MOVQ_move: conversion not done', NULL, NULL, 1, 47, 'MOVQ_move: Konvertierung noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('BLOB conversion is not supported', NULL, NULL, 1, 48, 'BLOB-Konvertierung wird nicht untersttzt', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('conversion error', NULL, NULL, 1, 49, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion error', NULL, NULL, 1, 50, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion error', NULL, NULL, 1, 51, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion error', NULL, NULL, 1, 52, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion error', NULL, NULL, 1, 53, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion error', NULL, NULL, 1, 54, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('BLOB conversion is not supported', NULL, NULL, 1, 55, 'BLOB-Konvertierung ist nicht verfgbar', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Error converting string "@1" to date', NULL, NULL, 1, 56, 'Fehler bei der Konvertierung der Zeichenkette "@1" zu einem Datum', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('overflow during conversion', NULL, NULL, 1, 57, 'berlauf whrend der Konvertierung', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('gds_$put_segment failed', NULL, NULL, 1, 58, 'Fehler bei gds_$put_segment', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('fseek failed', NULL, NULL, 1, 59, 'Fehler bei fseek', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('unterminated quoted string', NULL, NULL, 1, 60, 'Bei der Zeichenkette fehlt das abschlieende Anfhrungszeichen', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('could not open scratch file', NULL, NULL, 1, 61, 'Die Scratch-Datei konnte nicht geffnet werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('fseek failed', NULL, NULL, 1, 62, 'Fehler bei fseek', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('unterminated quoted string', NULL, NULL, 1, 63, 'Bei der Zeichenkette fehlt das abschlieende Anfhrungzeichen', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('unexpected end of procedure in procedure @1', NULL, NULL, 1, 64, 'Unerwartetes Prozedurende in Prozedur @1', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('unexpected end of file in file @1', NULL, NULL, 1, 65, 'Unerwartetes Dateiende in Datei @1', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('unexpected eof', NULL, NULL, 1, 66, 'Unerwartetes Dateiende (EOF)', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('cannot open command file "@1"', NULL, NULL, 1, 67, 'Die Befehlsdatei "@1" kann nicht geffnet werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('PIC_edit: class not yet implemented', NULL, NULL, 1, 68, 'PIC_edit: Klasse noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('conversion error', NULL, NULL, 1, 69, 'Konvertierungsfehler', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('procedure "@1" is undefined', NULL, NULL, 1, 70, 'Die Prozedur "@1" ist nicht definiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('procedure "@1" is undefined in database @2', NULL, NULL, 1, 71, 'Die Prozedur "@1" ist nicht in der Datenbank @2 definiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('procedure "@1" is undefined', NULL, NULL, 1, 72, 'Die Prozedur "@1" ist nicht definiert', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Could not create QLI$PROCEDURE_NAME field', NULL, NULL, 1, 73, 'Das Feld QLI$PROCEDURE_NAME konnte nicht erstellt werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Could not create QLI$PROCEDURE field', NULL, NULL, 1, 74, 'Das Feld QLI$PROCEDURE konnte nicht erstellt werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('Could not create QLI$PROCEDURES table', NULL, NULL, 1, 75, 'Die Tabellen QLI$PROCEDURES konnte nicht erstellt werden', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('procedure name "@1" in use in database @2', NULL, NULL, 1, 76, 'Der Prozedurname "@1" wird bereits in der Datenbank @2 verwendet', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('database handle required', NULL, NULL, 1, 77, 'Datenbank-Handle erforderlich', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('QLI$PROCEDURES table must be created with RDO in Rdb/VMS databases', NULL, NULL, 1, 78, 'Zur Erstellung der Tabellen QLI$PROCEDURES in Rdb/VMS-Datenbanken mu RDO verwendet werden', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('procedure name over 31 characters', NULL, NULL, 1, 79, 'Der Prozedurname hat mehr als 31 Zeichen', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('	[@1 topics matched @2]', NULL, NULL, 1, 80, '	[@1 Themen zu @2 verfgbar]', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('
-@1Sub-topics available:', NULL, NULL, 1, 81, '
-@1Folgende untergeordnete Themen sind verfgbar:', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('
-No help is available for @1 @2', NULL, NULL, 1, 82, '
-Fr @1 @2 ist keine Hilfe verfgbar', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('
-Sub-topics available for @1 are:', NULL, NULL, 1, 83, '
-Fr @1 sind folgende untergeordnete Themen verfgbar:', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Procedures can not be renamed across databases. Try COPY', NULL, NULL, 1, 84, 'Datenbankbergreifende Umbenennung von Prozeduren ist unzulssig. COPY verwenden!', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 85, 'Die Prozedur @1 ist in der Datenbank @2 nicht auffindbar', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('substitute prompt string too long', NULL, NULL, 1, 86, 'Die Ersatz-Promptzeichenkette ist zu lang', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('substitute prompt string too long', NULL, NULL, 1, 87, 'Die Ersatz-Prompt-Zeichenkette ist zu lang', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 88, 'Die Prozedur @1 ist in der Datenbank @2 nicht auffindbar', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 89, 'Die Prozedur @1 ist in der Datenbank @2 nicht auffindbar', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('No security classes defined', NULL, NULL, 1, 90, 'Es wurden keine Sicherheitsklassen definiert', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('	Security class @1 is not defined', NULL, NULL, 1, 91, '    Die Sicherheitsklasse @1 ist nicht definiert', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('	No views defined', NULL, NULL, 1, 92, '	Es wurden keine Views definiert', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('	No indexes defined', NULL, NULL, 1, 93, '	Es wurden keine Indizes definiert', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('	No indexes defined', NULL, NULL, 1, 94, '	Es wurden keine Indizes definiert', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('No databases are currently ready', NULL, NULL, 1, 95, 'Gegenwrtig sind keine Datenbanken geffnet', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Procedure @1 in database "@2" (@3)', NULL, NULL, 1, 96, 'Prozedur @1 in der Datenbank "@2" (@3)', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('text, length @1', NULL, NULL, 1, 97, 'TEXT, Lnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('varying text, length @1', NULL, NULL, 1, 98, 'VARYING TEXT, Lnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('null terminated text, length @1', NULL, NULL, 1, 99, 'Durch Nullzeichen beendeter Text, Lnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('short binary', NULL, NULL, 1, 100, 'SHORT BINARY', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('long binary', NULL, NULL, 1, 101, 'LONG BINARY', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('quad', NULL, NULL, 1, 102, 'QUAD', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('short floating', NULL, NULL, 1, 103, 'SHORT FLOAT', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('long floating', NULL, NULL, 1, 104, 'LONG FLOAT', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('BLOB', NULL, NULL, 1, 105, 'BLOB', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(', segment length @1', NULL, NULL, 1, 106, ', Segmentlnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(', subtype @1', NULL, NULL, 1, 107, ', Subtyp @1', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(', subtype BLR', NULL, NULL, 1, 108, ', Subtyp BLR', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(', subtype ACL', NULL, NULL, 1, 109, ', Subtyp ACL', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('date', NULL, NULL, 1, 110, 'DATE', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(', scale @1', NULL, NULL, 1, 111, ', Skalierungsfaktor (SCALE) @1', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(', subtype fixed', NULL, NULL, 1, 112, ', Subtyp FIXED', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Database "@1" readied as @2', NULL, NULL, 1, 113, 'Die Datenbank "@1" wurde als @2 geffnet', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Database "@1"', NULL, NULL, 1, 114, 'Datenbank "@1"', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('No databases are currently ready', NULL, NULL, 1, 115, 'Gegenwrtig sind keine Datenbanken geffnet', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('    Page size is @1 bytes.  Current allocation is @2 pages.', NULL, NULL, 1, 116, '    Page Size: @1 Bytes. Gegenwrtige Zuteilung: @2 Pages', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Field @1 does not exist in database @2', NULL, NULL, 1, 117, 'Das Feld @1 ist nicht in der Datenbank @2 vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Field @1 does not exist in any open database', NULL, NULL, 1, 118, 'Das Feld @1 ist in keiner der geffneten Datenbanken vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-(' (computed expression)', NULL, NULL, 1, 119, ' (COMPUTED-Ausdruck)', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('There are no forms defined for database @1', NULL, NULL, 1, 120, 'Fr die Datenbank @1 werden keine Masken untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('There are no forms defined in any open database', NULL, NULL, 1, 121, 'In keiner der geffneten Datenbanken sind Masken definiert worden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Global field @1 does not exist in database @2', NULL, NULL, 1, 122, 'Das globale Feld @1 ist nicht in der Datenbank @2 vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Global field @1 does not exist in any open database', NULL, NULL, 1, 123, 'Das globale Feld @1 ist in keiner der geffneten Datenbanken vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('There are no fields defined for database @1', NULL, NULL, 1, 124, 'Fr die Datenbank @1 sind keine Felder definiert worden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('There are no fields defined in any open database', NULL, NULL, 1, 125, 'In keiner der geffneten Datenbanken sind Felder definiert worden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 126, 'Die Prozedur @1 wurde nicht in der Datenbank @2 gefunden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Procedure @1 not found', NULL, NULL, 1, 127, 'Prozedur @1 nicht gefunden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Procedures in database "@1" (@2):', NULL, NULL, 1, 128, 'Prozeduren in der Datenbank "@1" (@2):', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('No triggers are defined for table @1', NULL, NULL, 1, 129, 'Fr die Tabellen @1 sind keine Trigger definiert worden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('No triggers are defined in database @1', NULL, NULL, 1, 130, 'In der Datenbank @1 sind keine Trigger definiert worden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('No triggers are defined in database @1', NULL, NULL, 1, 131, 'In der Datenbank @1 sind keine Trigger definiert worden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Variables:', NULL, NULL, 1, 132, 'Variable:', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('    QLI, version "@1"', NULL, NULL, 1, 133, '    QLI, Version "@1"', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('    Version(s) for database "@1"', NULL, NULL, 1, 134, '    Version(en) fr die Datenbank "@1"', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('expand_expression: not yet implemented', NULL, NULL, 1, 135, 'expand_expression: noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('expand_statement: not yet implemented', NULL, NULL, 1, 136, 'expand_statement: noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('variables may not be based on BLOB fields', NULL, NULL, 1, 137, 'Variable drfen keine BLOB-Felder referenzieren', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('cannot perform assignment to computed field @1', NULL, NULL, 1, 138, 'Zuweisung zum COMPUTED-Feld @1 nicht durchfhrbar', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('no context for ERASE', NULL, NULL, 1, 139, 'Fr ERASE ist kein Kontext vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('cannot erase from a join', NULL, NULL, 1, 140, 'Lschen bei JOIN-Operation nicht mglich', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('@1.* cannot be used when a single element is required', NULL, NULL, 1, 141, '@1.* kann nicht verwendet werden, wenn ein Einzelelement erforderlich ist', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('"@1" is undefined or used out of context', NULL, NULL, 1, 142, '"@1" ist nicht definiert oder wurde ohne Kontext verwendet', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('no default form name', NULL, NULL, 1, 143, 'Kein Standard-Maskenname', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('No database for form @1', NULL, NULL, 1, 144, 'Fr die Maske @1 ist keine Datenbank vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('form @1 is not defined in database "@2"', NULL, NULL, 1, 145, 'Die Maske @1 ist nicht in der Datenbank "@2" definiert', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('no context for form ACCEPT statement', NULL, NULL, 1, 146, 'Fr die Masken-ACCEPT-Anweisung ist kein Kontext vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('field @1 is not defined in form @2', NULL, NULL, 1, 147, 'Das Feld @1 ist nicht in der Maske @2 definiert', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('no context for modify', NULL, NULL, 1, 148, 'Fr MODIFY ist kein Kontext vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('field list required for modify', NULL, NULL, 1, 149, 'Zur Durchfhrung von MODIFY ist eine Feldliste erforderlich', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('No items in print list', NULL, NULL, 1, 150, 'In der Druckliste sind keine Items vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('No items in print list', NULL, NULL, 1, 151, 'In der Druckliste sind keine Items enthalten', NULL, NULL, 'daves', '1993-07-16 12:16:00')
-('invalid ORDER BY ordinal', NULL, NULL, 1, 152, 'ORDER BY unzulssig', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('asterisk expressions require exactly one qualifying context', NULL, NULL, 1, 153, 'Fr Stern-Ausdrcke (*) ist genau ein qualifizierender Kontext erforderlich', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('unrecognized context', NULL, NULL, 1, 154, 'Kontext unbekannt', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('field referenced in BASED ON cannot be resolved against readied databases', NULL, NULL, 1, 155, 'Das in BASED ON referenzierte Feld ist in den geffneten Datenbanken nicht auffindbar', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('expected statement, encountered "@1"', NULL, NULL, 1, 156, 'Erwartet: Anweisung, gefunden: "@1"', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('Expected PROCEDURE encountered "@1"', NULL, NULL, 1, 157, 'Erwartet: PROCEDURE, gefunden: "@1"', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('period in qualified name', NULL, NULL, 1, 158, 'Der qualifizierte Namen enthlt einen Punkt', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('no databases are ready', NULL, NULL, 1, 159, 'Es wurden keine Datenbanken angemeldet', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('BLOB variables are not supported', NULL, NULL, 1, 160, 'BLOB-Variable werden nicht untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('end of statement', NULL, NULL, 1, 161, 'Ende der Anweisung', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('end of command', NULL, NULL, 1, 162, 'Ende des Befehls', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('quoted edit string', NULL, NULL, 1, 163, 'Edit String in Anfhrungszeichen', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('variable definition clause', NULL, NULL, 1, 164, 'Definitionsklausel einer Variablen', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('@1 is not a database', NULL, NULL, 1, 165, '@1 ist keine Datenbank', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('@1 is not a table in database @2', NULL, NULL, 1, 166, '@1 ist keine Tabellen in der Datenbank @2', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('variable data type', NULL, NULL, 1, 167, 'Datentyp einer Variablen', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('no data type may be specified for a variable based on a field', NULL, NULL, 1, 168, 'Fr eine Variable, die auf einem Feld basiert, darf kein Datentyp spezifiziert werden', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('object type for DEFINE', NULL, NULL, 1, 169, 'Objekttyp fr DEFINE', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('table name', NULL, NULL, 1, 170, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('comma between field definitions', NULL, NULL, 1, 171, 'Komma zwischen Felddefinitionen', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('FROM', NULL, NULL, 1, 172, 'FROM', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('table or view name', NULL, NULL, 1, 173, 'Tabellens- oder View-Name', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('[', NULL, NULL, 1, 174, '[', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-(']', NULL, NULL, 1, 175, ']', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('No statements issued yet', NULL, NULL, 1, 176, 'Es wurden noch keine Anweisungen ausgegeben', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('ON or TO', NULL, NULL, 1, 177, 'ON oder TO', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('quoted edit string', NULL, NULL, 1, 178, 'Edit String in Anfhrungszeichen', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('column definition clause', NULL, NULL, 1, 179, '###-Definitionsklausel', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('global fields may not be based on other fields', NULL, NULL, 1, 180, 'Globale Felder drfen nicht auf anderen Feldern basieren (BASED ON)', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('field name or asterisk expression', NULL, NULL, 1, 181, 'Feldname oder Stern-Ausdruck (*)', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('FROM RSE clause', NULL, NULL, 1, 182, 'FROM RSE-Klausel', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('comma', NULL, NULL, 1, 183, 'Komma', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('quoted header segment', NULL, NULL, 1, 184, 'Vorsatzsegment (Header) in Anfhrungszeichen', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('left parenthesis', NULL, NULL, 1, 185, '''Klammer auf''', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('comma or terminating right parenthesis', NULL, NULL, 1, 186, 'Komma oder ''Klammer zu''', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('left parenthesis', NULL, NULL, 1, 187, '''Klammer auf''', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('VALUES list or SELECT clause', NULL, NULL, 1, 188, 'VALUES-Liste oder SELECT-Klausel', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('the number of values do not match the number of fields', NULL, NULL, 1, 189, 'Die Anzahl von Werten stimmt nicht mit der Anzahl von Feldern berein', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('value expression', NULL, NULL, 1, 190, 'Wert-Ausdruck', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('right parenthesis', NULL, NULL, 1, 191, '''Klammer zu''', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('quoted string', NULL, NULL, 1, 192, 'Zeichenkette in Anfhrungszeichen', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-COMMIT WORK;
-('ENTREE or END', NULL, NULL, 1, 193, 'ENTREE oder END', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('quoted string', NULL, NULL, 1, 194, 'Zeichenkette in Anfhrungszeichen', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('index state option', NULL, NULL, 1, 195, 'Index-Status-Option', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('table name', NULL, NULL, 1, 196, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('ADD, MODIFY, or DROP', NULL, NULL, 1, 197, 'ADD, MODIFY oder DROP', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('comma between field definitions', NULL, NULL, 1, 198, 'Komma zwischen Felddefinitionen', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('identifier', NULL, NULL, 1, 199, 'Identifizierer', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('positive number', NULL, NULL, 1, 200, 'Positive Zahl', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('FORM', NULL, NULL, 1, 201, 'Maske', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('period in qualified table name', NULL, NULL, 1, 202, 'Der qualifizierte Tabellensname enthlt einen Punkt', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('@1 is not a table in database @2', NULL, NULL, 1, 203, '@1 ist keine Tabellen in der Datenbank @2', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('database file name required on READY', NULL, NULL, 1, 204, 'Zur Durchfhrung von READY ist der Datenbank-Dateiname erforderlich', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('EXISTS (SELECT * <sql rse>)', NULL, NULL, 1, 205, 'EXISTS (SELECT * <sql rse>)', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('relational operator', NULL, NULL, 1, 206, 'relationaler Operator', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('a database has not been readied', NULL, NULL, 1, 207, 'Es wurde keine Datenbank geffnet (READY)', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('expected "table_name", encountered "@1"', NULL, NULL, 1, 208, 'Erwartet: "Tabellen_Name", gefunden: "@1"', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('table name', NULL, NULL, 1, 209, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('PROCEDURE', NULL, NULL, 1, 210, 'PROCEDURE', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('TOP or BOTTOM', NULL, NULL, 1, 211, 'TOP oder BOTTOM', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('report writer SET option', NULL, NULL, 1, 212, 'Reportwriter SET-Option', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('report item', NULL, NULL, 1, 213, 'Report-Item', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('set option', NULL, NULL, 1, 214, 'SET-Option', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('RELATIONS or TRIGGERS', NULL, NULL, 1, 215, 'RELATIONS oder TRIGGERS', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('table name', NULL, NULL, 1, 216, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('database name', NULL, NULL, 1, 217, 'Datenbankname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('table name', NULL, NULL, 1, 218, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('database name', NULL, NULL, 1, 219, 'Datenbankname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('table name', NULL, NULL, 1, 220, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('database name', NULL, NULL, 1, 221, 'Datenbankname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('table name', NULL, NULL, 1, 222, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('table name', NULL, NULL, 1, 223, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('FROM clause', NULL, NULL, 1, 224, 'FROM-Klausel', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('AVG, MAX, MIN, SUM, or COUNT', NULL, NULL, 1, 225, 'AVG, MAX, MIN, SUM oder COUNT', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('COUNT (*)', NULL, NULL, 1, 226, 'COUNT (*)', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('left parenthesis', NULL, NULL, 1, 227, '''Klammer auf''', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('OF', NULL, NULL, 1, 228, 'OF', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('database handle', NULL, NULL, 1, 229, 'Datenbank###', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('SET', NULL, NULL, 1, 230, 'SET', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('database block not found for removal', NULL, NULL, 1, 231, 'Zu lschender Datenbankblock nicht gefunden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('show_fields: dtype not done', NULL, NULL, 1, 232, 'show_fields: Datentyp noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('global field @1 already exists', NULL, NULL, 1, 233, 'Globales Feld @1 bereits vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Cannot define an index in a view', NULL, NULL, 1, 234, 'In einer View kann kein Index definiert werden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Index @1 already exists', NULL, NULL, 1, 235, 'Der Index @1 ist bereits vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Column @1 does not occur in table @2', NULL, NULL, 1, 236, 'Das ### @1 kommt in der Tabellen @2 nicht vor', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Table @1 already exists', NULL, NULL, 1, 237, 'Die Tabellen @1 ist bereits vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Field @1 is in use in the following relations:', NULL, NULL, 1, 238, 'Das Feld @1 wird bereits in den folgenden Relationen vewendet:', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Field @1 is in use in database "@2"', NULL, NULL, 1, 239, 'Das Feld @1 wird bereits in der Datenbank "@2" verwendet', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Field @1 is not defined in database "@2"', NULL, NULL, 1, 240, 'Das Feld @1 ist nicht in der Datenbank "@2" definiert', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Index @1 is not defined in database "@2"', NULL, NULL, 1, 241, 'Der Index @1 ist nicht in der Datenbank "@2" definiert', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('metadata operation failed', NULL, NULL, 1, 242, 'Fehler bei der Metadaten-Operation', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('no active database for operation', NULL, NULL, 1, 243, 'Fr die Operation ist keine aktive Datenbank vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Interactive metadata updates are not available on Rdb', NULL, NULL, 1, 244, 'Rdb untersttzt keine interaktiven Metadaten-Updates', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('global field @1 is not defined', NULL, NULL, 1, 245, 'Das globale Feld @1 ist nicht definiert', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Index @1 does not exist in database @2', NULL, NULL, 1, 246, 'Der Index @1 ist nicht in der Datenbank @2 vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('field @1 does not exist', NULL, NULL, 1, 247, 'Das Feld @1 existiert nicht', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('no active database for operation', NULL, NULL, 1, 248, 'Fr die Operation ist keine Datenbank vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Interactive metadata updates are not available on Rdb', NULL, NULL, 1, 249, 'Rdb untersttzt keine interaktiven Metadaten-Updates', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Unlicensed for database "@1"', NULL, NULL, 1, 250, 'Fr die Datenbank "@1" nicht lizensiert', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Field @1 already exists in relation @2', NULL, NULL, 1, 251, 'Das Feld @1 ist bereits in der Relation @2 vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('data type cannot be changed locally', NULL, NULL, 1, 252, 'Lokale nderung des Datentyps nicht mglich', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('global field @1 does not exist', NULL, NULL, 1, 253, 'Das globale Feld @1 existiert nicht', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('field @1 not found in relation @2', NULL, NULL, 1, 254, 'Das Feld @1 ist in der Relation @2 nicht auffindbar', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Data type conflict with existing global field @1', NULL, NULL, 1, 255, 'Datentyp-Konflikt mit dem vorhandenen globalen Feld @1', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('No data type specified for field @1', NULL, NULL, 1, 256, 'Fr das Feld @1 ist kein Datentyp spezifiziert', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('database info call failed', NULL, NULL, 1, 257, 'Fehler beim Aufruf von Datenbank-Infos', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('do not understand BLR operator @1', NULL, NULL, 1, 258, 'BLR-Operator @1 unbekannt', NULL, NULL, 'daves', '1993-07-16 12:16:04')
-('Operation unlicensed for database "@1"', NULL, NULL, 1, 259, 'Diese Operation ist fr die Datenbank "@1" nicht lizensiert', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Security class for database @1', NULL, NULL, 1, 260, '    Sicherheitsklasse fr die Datenbank @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Database description:', NULL, NULL, 1, 261, '    Datenbank-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Database description:', NULL, NULL, 1, 262, '    Datenbank-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('	File:	@1 starting at page @2', NULL, NULL, 1, 263, '	Datei:	@1 beginnt auf Page @2', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('Field @1 in @2 @3 of database @4', NULL, NULL, 1, 264, 'Feld @1 in @2 @3 der Datenbank @4', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Global field @1', NULL, NULL, 1, 265, '    Globales Feld @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field description:', NULL, NULL, 1, 266, '    Feld-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Datatype information:', NULL, NULL, 1, 267, '    Datentyp-Information:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field is computed from:', NULL, NULL, 1, 268, '    Feldwert wurde bestimmt durch:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field validation:', NULL, NULL, 1, 269, '    Feld-Validierung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Security class @1', NULL, NULL, 1, 270, '    Sicherheitsklasse @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Query name:	 @1', NULL, NULL, 1, 271, '    Abfrage- (Query-)Name:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Query name:	 @1', NULL, NULL, 1, 272, '    Abfrage- (Query-)Name:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Edit string:	 @1', NULL, NULL, 1, 273, '    Edit String:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Edit string:	 @1', NULL, NULL, 1, 274, '    Edit String:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Query header:', NULL, NULL, 1, 275, '    Abfrage- (Query-)Header:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('Global field @1 in database @2', NULL, NULL, 1, 276, 'Globales Feld @1 in der Datenbank @2', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field description:', NULL, NULL, 1, 277, '    Feld-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Datatype information:', NULL, NULL, 1, 278, '    Datentyp-Information:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field is computed from:', NULL, NULL, 1, 279, '    Feldwert wurde bestimmt durch:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field validation:', NULL, NULL, 1, 280, '    Feld-Validierung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Query name:	 @1', NULL, NULL, 1, 281, '    Abfrage- (Query-)Name:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Edit string:	 @1', NULL, NULL, 1, 282, '    Edit String:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Query header:', NULL, NULL, 1, 283, '    Abfrage- (Query-)Header:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    @1 is not used in any relations in database @2', NULL, NULL, 1, 284, '    @1 wird in keiner Relation der Datenbank @2 verwendet', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('Forms in database @1', NULL, NULL, 1, 285, 'Masken in der Datenbank @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('Global fields for database @1:', NULL, NULL, 1, 286, 'Globale Felder fr die Datenbank @1:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Field description:', NULL, NULL, 1, 287, '    Feld-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('        Index @1@2', NULL, NULL, 1, 288, '        Index @1@2', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('            index @1 is NOT active', NULL, NULL, 1, 289, '            Der Index @1 ist nicht aktiv', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('        Index @1@2', NULL, NULL, 1, 290, '        Index @1@2', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Description:', NULL, NULL, 1, 291, '    Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Security class @1', NULL, NULL, 1, 292, '    Sicherheitsklasse @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Stored in external file @1', NULL, NULL, 1, 293, '    In der externen Datei @1 gespeichert', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -        An erase trigger is defined for @1', NULL, NULL, 1, 294, '### -        Fr @1 wurde ein ERASE-Trigger definiert', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -        A modify trigger is defined for @1', NULL, NULL, 1, 295, '### -        Fr @1 ist ein MODIFY-Trigger definiert', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -        A store trigger is defined for @1', NULL, NULL, 1, 296, '### -        Fr @1 ist ein STORE-Trigger definiert', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('    Security classes for database @1', NULL, NULL, 1, 297, '    Sicherheitsklassen fr die Datenbank @1', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -	Triggers for relation @1:', NULL, NULL, 1, 298, '### -	Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:02')
-('OBSOLETE -    Source for the erase trigger is not available.  Trigger BLR:', NULL, NULL, 1, 299, '### -    Quellcode fr ERASE-Trigger nicht verfgbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('OBSOLETE -    Erase trigger for relation @1:', NULL, NULL, 1, 300, '### -    ERASE-Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:03')
-('OBSOLETE -    Source for the modify trigger is not available.  Trigger BLR:', NULL, NULL, 1, 301, '### -    Quellcode fr MODIFY-Trigger ist nicht verfgbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Modify trigger for relation @1:', NULL, NULL, 1, 302, '### -    MODIFY-Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Source for the store trigger is not available.  Trigger BLR:', NULL, NULL, 1, 303, '### -    Quellcode fr STORE-Trigger ist nicht verfbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Store trigger for relation @1:', NULL, NULL, 1, 304, '### -    STORE-Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Triggers for relation @1:', NULL, NULL, 1, 305, '### -    Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Source for the erase trigger is not available.  Trigger BLR:', NULL, NULL, 1, 306, '### -    Quellcode fr ERASE-Trigger ist nicht verfgbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Erase trigger for relation @1:', NULL, NULL, 1, 307, '### -    ERASE-Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Source for the modify trigger is not available.  Trigger BLR:', NULL, NULL, 1, 308, '### -    Quellcode fr MODIFY-Trigger ist nicht verfgbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Modify trigger for relation @1:', NULL, NULL, 1, 309, '### -    MODIFY-Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Source for the store trigger is not available.  Trigger BLR:', NULL, NULL, 1, 310, '### -    Quellcode fr STORE-Trigger ist nicht verfgbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:05')
-('OBSOLETE -    Store trigger for relation @1:', NULL, NULL, 1, 311, '### -    STORE-Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('
-    View source for relation @1 is not available.  View BLR:', NULL, NULL, 1, 312, '
-    View-Quellcode fr Relation @1 ist nicht verfgbar. View-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('
-    Relation @1 is a view defined as:', NULL, NULL, 1, 313, '
-    Die Relation @1 ist eine View, definiert als:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('Views in database @1:', NULL, NULL, 1, 314, 'Views in der Datenbank @1:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    @1 comprised of :', NULL, NULL, 1, 315, '    @1 besteht aus :', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('Views in database @1:', NULL, NULL, 1, 316, 'Views in der Datenbank @1:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    @1 comprised of:', NULL, NULL, 1, 317, '    @1 besteht aus:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('BLOB', NULL, NULL, 1, 318, 'BLOB', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', segment length @1', NULL, NULL, 1, 319, ', Segmentlnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', subtype text', NULL, NULL, 1, 320, ', Subtyp TEXT', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', subtype BLR', NULL, NULL, 1, 321, ', Subtyp BLR', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', subtype ACL', NULL, NULL, 1, 322, ', Subtyp ACL', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', subtype @1', NULL, NULL, 1, 323, ', Subtyp @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('text, length @1', NULL, NULL, 1, 324, 'TEXT, Lnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('varying text, length @1', NULL, NULL, 1, 325, 'VARYING TEXT, Lnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('null terminated text, length @1', NULL, NULL, 1, 326, 'Durch Nullzeichen beendeter Text, Lnge @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('short binary', NULL, NULL, 1, 327, 'SHORT BINARY', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('long binary', NULL, NULL, 1, 328, 'LONG BINARY', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('quadword binary', NULL, NULL, 1, 329, 'QUADWORD BINARY', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('short floating', NULL, NULL, 1, 330, 'SHORT FLOAT', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('long floating', NULL, NULL, 1, 331, 'LONG FLOAT', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('date', NULL, NULL, 1, 332, 'DATE', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', scale @1', NULL, NULL, 1, 333, ', Skalierungsfaktor (SCALE) @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-(', subtype fixed', NULL, NULL, 1, 334, ', Subtyp FIXED', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Global field @1 is used in database @2 as :', NULL, NULL, 1, 335, '    Das globale Feld @1 wird in der Datenbank @2 verwendet als:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('	@1 in relation @2', NULL, NULL, 1, 336, '	@1 in der Relation @2', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('Field @1 in @2 @3 of database @4', NULL, NULL, 1, 337, '    Feld @1 in @2 @3 der Datenbank @4', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Global field @1', NULL, NULL, 1, 338, '    Globales Feld @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Field description:', NULL, NULL, 1, 339, '    Feld-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Datatype information', NULL, NULL, 1, 340, '    Datentyp-Information', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Field is computed from:', NULL, NULL, 1, 341, '    Feldwert wurde bestimmt durch:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Field validation:', NULL, NULL, 1, 342, '    Feld-Validierung:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Query name:	 @1', NULL, NULL, 1, 343, '    Abfrage- (Query-)Name:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Query name:	 @1', NULL, NULL, 1, 344, '    Abfrage- (Query-)Name:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Query header:', NULL, NULL, 1, 345, '    Abfrage- (Query-)Header:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Edit string:	 @1', NULL, NULL, 1, 346, '    Edit String:	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('    Edit string: 	 @1', NULL, NULL, 1, 347, '    Edit String: 	 @1', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('@1 Based on field @2 of @3@4', NULL, NULL, 1, 348, '@1 BASED ON-Feld @2 der @3@4', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('@1Base field description for @2:', NULL, NULL, 1, 349, '@1Basisfeldbeschreibung fr @2:', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('END PROCEDURE', NULL, NULL, 1, 350, 'END PROCEDURE', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('Do you want to roll back your updates?', NULL, NULL, 1, 351, 'Sollen die Updates zurckgerollt werden (Roll back)?', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('gen_descriptor: dtype not recognized', NULL, NULL, 1, 352, 'gen_descriptor: Datentyp ist nicht bekannt', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('gen_expression: not understood', NULL, NULL, 1, 353, 'gen_expression: unbekannt', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('gen_statement: not yet implemented', NULL, NULL, 1, 354, 'gen_statement: noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('gen_statistical: not understood', NULL, NULL, 1, 355, 'gen_statistical: unbekannt', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('EDIT argument must be a BLOB field', NULL, NULL, 1, 356, 'EDIT-Argument mu ein BLOB-Feld sein', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('relations from multiple databases in single RSE', NULL, NULL, 1, 357, 'Relationen aus mehreren Datenbanken in einer einzigen RSE', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('cannot find database for BLOB edit', NULL, NULL, 1, 358, 'Datenbank fr BLOB-Edit nicht auffindbar', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('compile_expression: not yet implemented', NULL, NULL, 1, 359, 'compile_expression: noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('not yet implemented (compile_statement)', NULL, NULL, 1, 360, 'noch nicht implementiert (compile_statement)', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('computable: not yet implemented', NULL, NULL, 1, 361, 'computable: noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('make_descriptor: not yet implemented', NULL, NULL, 1, 362, 'make_descriptor: noch nicht implementiert', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('missing message', NULL, NULL, 1, 363, 'Mitteilung fehlt', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('lost message', NULL, NULL, 1, 364, 'Mitteilung verloren', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Triggers for relation @1:', NULL, NULL, 1, 365, 'Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('    @1	@2, Sequence @3, @4', NULL, NULL, 1, 366, '    @1	@2, Sequenz @3, @4', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Pre-store', NULL, NULL, 1, 367, 'Pre-store', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Post-store', NULL, NULL, 1, 368, 'Post-store', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Pre-modify', NULL, NULL, 1, 369, 'Pre-modify', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Post-modify', NULL, NULL, 1, 370, 'Post-modify', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Pre-erase', NULL, NULL, 1, 371, 'Pre-erase', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Post-erase', NULL, NULL, 1, 372, 'Post-erase', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Active', NULL, NULL, 1, 373, 'aktiv', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Inactive', NULL, NULL, 1, 374, 'inaktiv', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('	Description:', NULL, NULL, 1, 375, '	Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('	Source for the trigger:', NULL, NULL, 1, 376, '	Quellcode fr Trigger:', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('	Source for the trigger is not available.  Trigger BLR:', NULL, NULL, 1, 377, '	Quellcode fr Trigger ist nicht verfgbar. Trigger-BLR:', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('No system triggers are defined', NULL, NULL, 1, 378, 'Es wurden keine System-Trigger definiert', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('System Trigger for relation @1', NULL, NULL, 1, 379, 'System-Trigger fr die Relation @1', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('	Triggers defined for this relation:', NULL, NULL, 1, 380, '	Definierte Trigger fr diese Relation:', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Trigger for relation @1:', NULL, NULL, 1, 381, 'Trigger fr die Relation @1:', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('TOP or BOTTOM', NULL, NULL, 1, 382, 'TOP oder BOTTOM', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('sort field', NULL, NULL, 1, 383, 'Sortierfeld', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Too many WITHs', NULL, NULL, 1, 384, 'Zu viele WITH-Klauseln', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('	Shadow @1, File: @2 starting at page @3', NULL, NULL, 1, 385, '	Shadow @1, Datei @2: Beginn bei Page @3', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('DATABASE, TABLE, or INDEX', NULL, NULL, 1, 386, 'DATABASE, TABLE oder INDEX', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('Database filename required in CREATE', NULL, NULL, 1, 387, 'Datenbank-Dateiname in CREATE erforderlich', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('FLOAT', NULL, NULL, 1, 388, 'FLOAT', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('INDEX', NULL, NULL, 1, 389, 'INDEX', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('Multiple page size specifications', NULL, NULL, 1, 390, 'Mehrere Page Size-Spezifizierungen', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('GROUP BY not allowed in view definition', NULL, NULL, 1, 391, 'GROUP BY in View-Definition unzulssig', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('Aggregates not allowed in view definition', NULL, NULL, 1, 392, 'Aggregate in View-Definition unzulssig', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('NULL', NULL, NULL, 1, 393, 'NULL', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('AS', NULL, NULL, 1, 394, 'AS', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('SELECT', NULL, NULL, 1, 395, 'SELECT', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('=', NULL, NULL, 1, 396, '=', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('ON', NULL, NULL, 1, 397, 'ON', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('field name', NULL, NULL, 1, 398, 'Feldname', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('table name', NULL, NULL, 1, 399, 'Tabellensname', NULL, NULL, 'daves', '1993-07-16 12:16:13')
-('user name identifier', NULL, NULL, 1, 400, 'Benutzername', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('GRANT', NULL, NULL, 1, 401, 'GRANT', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('OPTION', NULL, NULL, 1, 402, 'OPTION', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('FROM', NULL, NULL, 1, 403, 'FROM', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('TO', NULL, NULL, 1, 404, 'TO', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('ADD or DROP', NULL, NULL, 1, 405, 'ADD oder DROP', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Dynamic DDL buffer exceeded', NULL, NULL, 1, 406, 'Dynamischer DDL-Puffer berschritten', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('TABLE', NULL, NULL, 1, 407, 'TABLE', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Database handle @1 conflicts with an established name', NULL, NULL, 1, 408, 'Datenbank-Handle @1 im Konflikt mit einem bereits vorhanden Namen', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Could not create QLI$PROCEDURES index', NULL, NULL, 1, 409, 'Der Index QLI$PROCEDURES konnte nicht erstellt werden', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Cannot convert from @1 to @2', NULL, NULL, 1, 410, 'Die Konvertierung von @1 zu @2 ist nicht mglich', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('Cannot convert "@1" to a numeric value', NULL, NULL, 1, 411, '"@1" kann nicht zu einem numerischen Wert konvertiert werden', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('function @1 not found in database @2', NULL, NULL, 1, 412, 'Funktion @1 nicht in Datenbank @2 gefunden', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Incompatible global field @1 already exists in target database', NULL, NULL, 1, 413, 'Inkompatibles globales Feld @1 bereits in der Ziel-Datenbank vorhanden', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('Relation @1 is missing or undefined', NULL, NULL, 1, 414, 'Die Relation @1 fehlt oder ist nicht definiert', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('matching language string too long', NULL, NULL, 1, 415, 'Die passende Sprachen-Zeichenkette ist zu lang', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Functions in database "@1" (@2):', NULL, NULL, 1, 416, 'Funktionen in der Datenbank "@1" (@2):', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Functions are not supported in database @1.', NULL, NULL, 1, 417, 'In der Datenbank @1 werden keine Funktionen untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:14')
--- 418 doesn't exist
-('There are no functions defined in any open database.', NULL, NULL, 1, 419, 'In keiner der geffneten Datenbanken sind Funktionen definiert', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Functions are not supported in any open database.', NULL, NULL, 1, 420, 'In keiner der geffneten Datenbanken werden Funktionen untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('    Function description:', NULL, NULL, 1, 421, '    Funktionsbeschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Function @1 is not defined in database @2.', NULL, NULL, 1, 422, 'Die Funktion @1 ist nicht in der Datenbank @2 definiert', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Function @1 is not defined in any open database.', NULL, NULL, 1, 423, 'Die Funktion @1 ist in keiner der geffneten Datenbanken definiert', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Function @1 (@2) in database "@3" (@4):', NULL, NULL, 1, 424, 'Funktion @1 (@2) in Datenbank "@3" (@4):', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Function @1 in database "@2" (@3):', NULL, NULL, 1, 425, 'Funktion @1 in Datenbank "@2" (@3):', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('    Function library is @1', NULL, NULL, 1, 426, '    Die Funktionsbibliothek ist @1', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('    Return argument is', NULL, NULL, 1, 427, '    Das bergabe-Argument ist', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('    Argument @1 is', NULL, NULL, 1, 428, '    Argument @1 ist', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('database file name required on DROP DATABASE', NULL, NULL, 1, 429, 'Datenbank-Dateiname fr DROP DATABASE angeben!', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Unlicensed for database "@1"', NULL, NULL, 1, 430, 'Fr Datenbank "@1" nicht lizensiert', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Could not drop database file "@1"', NULL, NULL, 1, 431, 'Die Datenbankdatei "@1" konnte nicht gelscht werden', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('Operation unlicensed for database "@1"', NULL, NULL, 1, 432, 'Operation fr die Datenbank "@1" nicht lizensiert', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-(' array', NULL, NULL, 1, 433, ' Array', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('memory pool free list is incorrect', NULL, NULL, 1, 434, 'Liste verfgbaren Speicherraums ist fehlerhaft', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('block released twice', NULL, NULL, 1, 435, 'Der Block wurde zweimal freigegeben', NULL, NULL, 'daves', '1993-07-16 12:16:14')
-('released block overlaps following free block', NULL, NULL, 1, 436, 'Freigegebener Block berlagert darauffolgenden freien Block', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('released block overlaps prior free block', NULL, NULL, 1, 437, 'Freigegebener Block berlagert vorhergehenden freien Block', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('References to array fields like @1 in relation @2 are not supported', NULL, NULL, 1, 438, 'Array-Feldreferenzierungen wie @1 in der Relation @2 werden nicht untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('Filters are not supported in database @1.', NULL, NULL, 1, 439, 'In der Datenbank @1 werden keine Filter untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('Filter @1 is not defined in database @2.', NULL, NULL, 1, 440, 'Der Filter @1 ist nicht in der Datenbank @2 definiert', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('Filter @1 is not defined in any open database.', NULL, NULL, 1, 441, 'Der Filter @1 ist in keiner der geffneten Datenbanken definiert', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('Filters are not supported in any open database.', NULL, NULL, 1, 442, 'In keiner der geffneten Datenbanken werden Filter untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('There are no filters defined in any open database.', NULL, NULL, 1, 443, 'In keiner der geffneten Datenbanken sind Filter definiert', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('Filter @1 in database "@2" (@3):', NULL, NULL, 1, 444, 'Filter @1 in der Datenbank "@2" (@3):', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('    Filter library is @1', NULL, NULL, 1, 445, '    Die Filterbibliothek ist @1', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('    Input sub-type is @1', NULL, NULL, 1, 446, '    Der Eingabe-Subtyp ist @1', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('    Output sub-type is @1', NULL, NULL, 1, 447, '    Der Ausgabe-Subtyp ist @1', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('    Filter description:', NULL, NULL, 1, 448, '    Filter-Beschreibung:', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('Filters in database @1 (@2):', NULL, NULL, 1, 449, 'Filter in der Datenbank @1 (@2):', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('	Index @1@2@3@4', NULL, NULL, 1, 450, '	Index @1@2@3@4', NULL, NULL, 'daves', '1993-07-16 12:16:15')
-('simple field reference not allowed in global aggregates', NULL, NULL, 1, 451, 'Bei globalen Aggregaten ist keine Einzelfeld-Referenzierung zulssig', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('prompting not allowed in select field list', NULL, NULL, 1, 452, 'In einer Selektionsfeldliste ist keine Eingabeaufforderung zulssig', NULL, NULL, 'daves', '1993-07-16 12:16:01')
-('output pipe is not supported on MPE/XL', NULL, NULL, 1, 453, 'Ausgabe-Pipe von MPE/XL nicht untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:20')
-('could not resolve context for aggregate expression', NULL, NULL, 1, 454, 'Kontext fr Aggregat-Ausdruck nicht gefunden', NULL, NULL, 'daves', '1993-07-16 12:16:24')
-('source relation @1 does not exist', NULL, NULL, 1, 455, 'Die Quell-Relation @1 existiert nicht', NULL, NULL, 'daves', '1993-07-16 12:16:24')
-('Messages associated with @1:', NULL, NULL, 1, 456, 'Zu @1 gehrige Mitteilungen:', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('    message @1:  @2', NULL, NULL, 1, 457, '    Mitteilung @1:  @2', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('Connection to database @1 lost.
-	Please FINISH the database!', NULL, NULL, 1, 458, 'Verbindung zur Datenbank @1 abgebochen.
-	Datenbank mit FINISH abmelden!', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('Unable to create form window', NULL, NULL, 1, 459, 'Maskenfenster kann nicht erstellt werden', NULL, NULL, 'daves', '1993-07-16 12:16:06')
-('Do you want to rollback updates for @1?', NULL, NULL, 1, 460, 'Sollen die Updates fr @1 zurckgerollt werden (Rollback)?', NULL, NULL, 'daves', '1993-07-16 12:16:07')
-('functions are not supported in database @1', NULL, NULL, 1, 461, 'In der Datenbank @1 werden keine Funktionen untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('no functions are defined in database @1', NULL, NULL, 1, 462, 'In der Datenbank @1 sind keine Funktionen definiert', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('filters are not supported in database @1', NULL, NULL, 1, 463, 'In der Datenbank @1 werden keine Filter untersttzt', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('no filters are defined for database @1', NULL, NULL, 1, 464, 'Fr die Datenbank @1 sind keine Filter definiert', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('Error during two phase commit on database @1.
-Roll back all databases or commit databases individually', NULL, NULL, 1, 465, 'Fehler beim Zwei-Phasen-Commit bei Datenbank @1.
-Alle Datenbanken zurckrollen oder einzeln ''committen''', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('Only fields may be subscripted', NULL, NULL, 1, 466, 'Es knnen nur Felder indiziert werden', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('"@1" is not a field and so may not be subscripted', NULL, NULL, 1, 467, '"@1" ist kein Feld und darf nicht indiziert werden', NULL, NULL, 'daves', '1993-07-16 12:16:25')
-('Data type of field @1 may not be changed to or from BLOB', NULL, NULL, 1, 468, 'Der Datentyp des Feldes @1 kann nicht von oder zu BLOB gendert werden', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('qli: ignoring unknown switch -@1', NULL, NULL, 1, 469, 'QLI: Der unbekannte Schalter -@1 wird ignoriert', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('literal string  <MAXSYMLEN> characters or longer', NULL, NULL, 1, 470, 'Die Literalzeichenkette besteht aus <MAXSYMLEN> oder mehr Zeichen', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('Variable @1', NULL, NULL, 1, 471, 'Variable @1', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('    Query name:	 @1', NULL, NULL, 1, 472, '    Abfrage- (Query-)Name:	 @1', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('    Edit string:	 @1', NULL, NULL, 1, 473, '    Edit String:	 @1', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('Variable @1 has not been declared', NULL, NULL, 1, 474, 'Die Variable @1 ist nicht deklariert worden', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('    Datatype information:', NULL, NULL, 1, 475, '    Datentyp-Informationen:', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('input line too long', NULL, NULL, 1, 476, 'Die Eingabezeile ist zu lang', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('input line too long', NULL, NULL, 1, 477, 'Die Eingabezeile ist zu lang', NULL, NULL, 'daves', '1993-07-16 12:15:53')
-('number > 0', NULL, NULL, 1, 478, 'Zahl > 0', NULL, NULL, 'daves', '1993-07-16 12:15:57')
-(' (@1)', NULL, NULL, 1, 479, ' (@1)', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('cannot format unsubscripted array @1', NULL, NULL, 1, 480, 'Das nicht subskribierte Array @1 kann nicht formatiert werden', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('unsuccessful attempt to extend pool beyond 64KB', NULL, NULL, 1, 481, 'Der Versuch, den Pool ber 64KByte hinaus zu erweitern, scheiterte', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('field width (@1) * header segments (@2) greater than 60,000 characters', NULL, NULL, 1, 482, 'Feldbreite (@1) multipliziert mit Anzahl der Header-Segmente (@2) > 60.000 Zeichen', NULL, NULL, 'daves', '1993-07-16 12:15:59')
-('Relation @1 does not exist', NULL, NULL, 1, 483, 'Die Relation @1 existiert nicht', NULL, NULL, 'daves', '1993-07-16 12:15:59')
--- Translate (1,484)-(1,512)
-('FORMs not supported', NULL, NULL, 1, 484, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('	Expression index BLR:', NULL, NULL, 1, 485, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Invalid argument for UDF', NULL, NULL, 1, 487, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('SINGULAR (SELECT * <sql rse>)', NULL, NULL, 1, 488, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('JOIN', NULL, NULL, 1, 489, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field @1 in view @2 of database @3', NULL, NULL, 1, 495, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field @1 in relation @2 of database @3', NULL, NULL, 1, 496, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('YES', NULL, NULL, 1, 497, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('NO', NULL, NULL, 1, 498, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Re-enter', NULL, NULL, 1, 499, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Enter', NULL, NULL, 1, 500, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('bad kanji found while formatting output', NULL, NULL, 1, 501, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Subtopic? ', NULL, NULL, 1, 502, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('
-type <cr> for next topic or <EOF> to stop: ', NULL, NULL, 1, 503, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('unknown data type @1', NULL, NULL, 1, 504, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('    reads = !r writes = !w fetches = !f marks = !m', NULL, NULL, 1, 505, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('    elapsed = !e cpu = !u system = !s mem = !x buffers = !b', NULL, NULL, 1, 506, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('@1 Based on field @2 of relation @3', NULL, NULL, 1, 507, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('@1 Based on field @2 of view @3', NULL, NULL, 1, 508, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('PRECISION', NULL, NULL, 1, 509, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field scale exceeds allowed range', NULL, NULL, 1, 510, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field length exceeds allowed range', NULL, NULL, 1, 511, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field length should be greater than zero', NULL, NULL, 1, 512, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
 --GFIX(3) is missing
 -- Translate (3,1)-(3,115)
 ('data base file name (@1) already given', NULL, NULL, 3, 1, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
diff --git a/src/msgs/transmsgs.fr_FR2.sql b/src/msgs/transmsgs.fr_FR2.sql
index 881c62afaa..733fa3dc8a 100644
--- a/src/msgs/transmsgs.fr_FR2.sql
+++ b/src/msgs/transmsgs.fr_FR2.sql
@@ -2,7 +2,6 @@ set bulk_insert INSERT INTO TRANSMSGS (ENG_TEXT, ENG_ACTION, ENG_EXPLANATION, FA
 -- Notice LOCALE is hardcoded as 'fr_FR' in the INSERT statement and therefore the rows below have one fields less than the table.
 -- JRD
 ('', NULL, NULL, 0, 0, '', NULL, NULL, 'daves', '1993-07-16 12:11:28')
-('arithmetic exception, numeric overflow, or string truncation', NULL, NULL, 0, 1, 'Erreur arithmtique, dbordement numrique ou chane tronque', NULL, NULL, 'daves', '1993-07-16 12:11:43')
 ('invalid database key', NULL, NULL, 0, 2, 'Cl de base de donnes non valide', NULL, NULL, 'daves', '1993-07-16 12:11:43')
 ('file @1 is not a valid database', NULL, NULL, 0, 3, 'Le fichier @1 n''est pas une base de donnes valide', NULL, NULL, 'daves', '1993-07-16 12:11:43')
 ('invalid database handle (no active connection)', NULL, NULL, 0, 4, 'Alias de base de donnes non valide (###)', NULL, NULL, 'daves', '1993-07-16 12:11:43')
@@ -739,537 +738,6 @@ segmented) blob.', 'daves', '1993-07-16 12:11:27')
 ('Cannot take a table reservation isc_tpb_lock_write in TPB because the transaction is in read only mode', NULL, NULL, 0, 591, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
 ('value exceeds the range for a valid time', NULL, NULL, 0, 592, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
 ('value exceeds the range for valid timestamps', NULL, NULL, 0, 593, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
--- QLI
-('expected type', NULL, NULL, 1, 0, 'Un type est prvu', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('bad block type', NULL, NULL, 1, 1, 'Type de bloc erron', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('bad block size', NULL, NULL, 1, 2, 'Taille de bloc errone', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('corrupt pool', NULL, NULL, 1, 3, 'Rserve altre', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('bad pool ID', NULL, NULL, 1, 4, 'ID de rserve erron', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('memory exhausted', NULL, NULL, 1, 5, 'Pas assez d''espace mmoire', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('set option not implemented', NULL, NULL, 1, 6, 'Option SET non mise en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('show option not implemented', NULL, NULL, 1, 7, 'Option SHOW non mise en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('show_fields: dtype not done', NULL, NULL, 1, 8, 'show_fields : type de donne non reconnu', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('INTERNAL: @1', NULL, NULL, 1, 9, 'INTERNAL : @1', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('** QLI error from database "@1" **', NULL, NULL, 1, 10, '** Erreur de QLI provenant de la base de donnes "@1" **', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('** QLI error from database **', NULL, NULL, 1, 11, '** Erreur de QLI provenant de la base de donnes **', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('** QLI error: @1 **', NULL, NULL, 1, 12, '** Erreur de QLI : @1 **', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('expected @1, encountered "@2"', NULL, NULL, 1, 13, 'Prvu : @1.  Obtenu : "@2"', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('integer overflow', NULL, NULL, 1, 14, 'Dbordement de nombre entier', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('integer division by zero', NULL, NULL, 1, 15, 'Division d''un nombre entier par zro', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('floating overflow trap', NULL, NULL, 1, 16, 'Interruption de au dbordement d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('floating division by zero', NULL, NULL, 1, 17, 'Division par zro d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('floating underflow trap', NULL, NULL, 1, 18, 'Interruption de au dbordement ngatif d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('floating overflow fault', NULL, NULL, 1, 19, 'Anomalie de au dbordement d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('floating underflow fault', NULL, NULL, 1, 20, 'Anomalie de au dbordement ngatif d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('arithmetic exception', NULL, NULL, 1, 21, 'Erreur arithmtique', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('illegal instruction or address, recovering...', NULL, NULL, 1, 22, 'Commande ou adresse errone, rcupration en cours...', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Please retry, supplying an application script file name', NULL, NULL, 1, 23, 'Recommencer en donnant le nom du fichier de commandes d''une application', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Welcome to QLI
-Query Language Interpreter', NULL, NULL, 1, 24, 'Bienvenue  QLI
-Query Language Interpreter', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('qli version @1', NULL, NULL, 1, 25, 'Version de QLI @1', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('
-Statistics for database "@1"
-@2', NULL, NULL, 1, 26, '
-Statistiques pour la base de donnes "@1"
-@2', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('HSH_remove failed', NULL, NULL, 1, 27, 'chec de HSH_remove', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('EVAL_boolean: not finished', NULL, NULL, 1, 28, 'EVAL_boolean : non termin', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('EVAL_value: not finished', NULL, NULL, 1, 29, 'EVAL_value : non termin', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('data type not supported for arithmetic', NULL, NULL, 1, 30, 'Type de donne non reconnu pour une opration arithmtique', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('user name is supported in RSEs temporarily', NULL, NULL, 1, 31, 'Nom d''utilisateur temporairement reconnu dans les RSE', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Input value is too long', NULL, NULL, 1, 32, 'La valeur en entre est trop longue', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('EXEC_execute: not implemented', NULL, NULL, 1, 33, 'EXEC_execute : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('print_blob: expected field node', NULL, NULL, 1, 34, 'print_blob : un noeud de zone est prvu', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('output pipe is not supported on VMS', NULL, NULL, 1, 35, 'Racheminement de sortie non reconnu par VMS', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('could not create pipe', NULL, NULL, 1, 36, 'Impossible de crer un racheminement', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('fdopen failed', NULL, NULL, 1, 37, 'chec de fdopen', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('execution terminated by signal', NULL, NULL, 1, 38, 'Excution termine par un signal', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('field validation error', NULL, NULL, 1, 39, 'Erreur de validation de zone', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Request terminated by statement: @1', NULL, NULL, 1, 40, 'Demande termine par l''nonc : @1', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Request terminated by statement', NULL, NULL, 1, 41, 'Demande termine par un nonc', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Cannot open output file "@1"', NULL, NULL, 1, 42, 'Ouverture impossible du fichier de sortie "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Could not run "@1"', NULL, NULL, 1, 43, 'Lancement impossible de "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('comparison not done', NULL, NULL, 1, 44, 'Comparaison non effectue', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion not implemented', NULL, NULL, 1, 45, 'Conversion non mise en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion not implemented', NULL, NULL, 1, 46, 'Conversion non mise en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('MOVQ_move: conversion not done', NULL, NULL, 1, 47, 'MOVQ_move : conversion non effectue', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('BLOB conversion is not supported', NULL, NULL, 1, 48, 'Conversion de BLOB non reconnue', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('conversion error', NULL, NULL, 1, 49, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion error', NULL, NULL, 1, 50, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion error', NULL, NULL, 1, 51, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion error', NULL, NULL, 1, 52, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion error', NULL, NULL, 1, 53, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('conversion error', NULL, NULL, 1, 54, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('BLOB conversion is not supported', NULL, NULL, 1, 55, 'Conversion de BLOB non reconnue', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('Error converting string "@1" to date', NULL, NULL, 1, 56, 'Erreur de conversion de la chane "@1" en date', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('overflow during conversion', NULL, NULL, 1, 57, 'Dbordement pendant la conversion', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('gds_$put_segment failed', NULL, NULL, 1, 58, 'chec de gds_$put_segment', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('fseek failed', NULL, NULL, 1, 59, 'chec de fseek', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('unterminated quoted string', NULL, NULL, 1, 60, 'Chane entre guillemets incomplte', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('could not open scratch file', NULL, NULL, 1, 61, 'Ouverture impossible du fichier de travail', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('fseek failed', NULL, NULL, 1, 62, 'chec de fseek', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('unterminated quoted string', NULL, NULL, 1, 63, 'Chane entre guillemets incomplte', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('unexpected end of procedure in procedure @1', NULL, NULL, 1, 64, 'Fin de procdure imprvue dans la procdure @1', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('unexpected end of file in file @1', NULL, NULL, 1, 65, 'Fin du fichier imprvue dans le fichier @1', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('unexpected eof', NULL, NULL, 1, 66, 'Fin imprvue du fichier', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('cannot open command file "@1"', NULL, NULL, 1, 67, 'Ouverture impossible du fichier de commandes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('PIC_edit: class not yet implemented', NULL, NULL, 1, 68, 'PIC_edit : catgorie de scurit non mise en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('conversion error', NULL, NULL, 1, 69, 'Erreur de conversion', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('procedure "@1" is undefined', NULL, NULL, 1, 70, 'Procdure "@1" non dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('procedure "@1" is undefined in database @2', NULL, NULL, 1, 71, 'Procdure "@1" non dfinie dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('procedure "@1" is undefined', NULL, NULL, 1, 72, 'Procdure "@1" non dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Could not create QLI$PROCEDURE_NAME field', NULL, NULL, 1, 73, 'Cration impossible de la zone QLI$PROCEDURE_NAME', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Could not create QLI$PROCEDURE field', NULL, NULL, 1, 74, 'Cration impossible de la zone QLI$PROCEDURE', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Could not create QLI$PROCEDURES table', NULL, NULL, 1, 75, 'Cration impossible de la table QLI$PROCEDURES', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('procedure name "@1" in use in database @2', NULL, NULL, 1, 76, 'Nom de procdure "@1" utilis dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('database handle required', NULL, NULL, 1, 77, 'Alias de base de donnes requis', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('QLI$PROCEDURES table must be created with RDO in Rdb/VMS databases', NULL, NULL, 1, 78, 'Dans les bases de donnes Rdb/VMS il faut crer la table QLI$PROCEDURES avec RDO', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('procedure name over 31 characters', NULL, NULL, 1, 79, 'Le nom de procdure dpasse 31 caractres', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('	[@1 topics matched @2]', NULL, NULL, 1, 80, '	[@1 sujets correspondent  @2]', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('
-@1Sub-topics available:', NULL, NULL, 1, 81, '
-Sous-rubriques @1 disponibles :', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('
-No help is available for @1 @2', NULL, NULL, 1, 82, '
-Aucune aide disponible pour @1 @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('
-Sub-topics available for @1 are:', NULL, NULL, 1, 83, '
-Sous-rubriques disponibles pour @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Procedures can not be renamed across databases. Try COPY', NULL, NULL, 1, 84, 'Modification impossible d''un nom de procdure dans plusieurs bases de donnes. Essayer COPY', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 85, 'La procdure @1 est introuvable dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('substitute prompt string too long', NULL, NULL, 1, 86, 'Chane de remplacement trop longue pour le signal', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('substitute prompt string too long', NULL, NULL, 1, 87, 'Chane de remplacement trop longue pour le signal', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 88, 'La procdure @1 est introuvable dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 89, 'La procdure @1 est introuvable dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('No security classes defined', NULL, NULL, 1, 90, 'Aucune catgorie de scurit n''est dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('	Security class @1 is not defined', NULL, NULL, 1, 91, '	La catgorie de scurit @1 n''est pas dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('	No views defined', NULL, NULL, 1, 92, '	Aucune vue n''est dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('	No indexes defined', NULL, NULL, 1, 93, '	Aucun index n''est dfini', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('	No indexes defined', NULL, NULL, 1, 94, '	Aucun index n''est dfini', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('No databases are currently ready', NULL, NULL, 1, 95, 'Aucune base de donnes n''est ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Procedure @1 in database "@2" (@3)', NULL, NULL, 1, 96, 'La procdure @1 est dans la base de donnes "@2" (@3)', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('text, length @1', NULL, NULL, 1, 97, 'Texte, longueur @1', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('varying text, length @1', NULL, NULL, 1, 98, 'Texte variable, longueur @1', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('null terminated text, length @1', NULL, NULL, 1, 99, 'Texte termin par des caractres nuls, longueur @1', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('short binary', NULL, NULL, 1, 100, 'Binaire court', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('long binary', NULL, NULL, 1, 101, 'Binaire long', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('quad', NULL, NULL, 1, 102, 'QUAD', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('short floating', NULL, NULL, 1, 103, 'Reprsentation courte d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('long floating', NULL, NULL, 1, 104, 'Reprsentation longue d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('BLOB', NULL, NULL, 1, 105, 'BLOB', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(', segment length @1', NULL, NULL, 1, 106, ', longueur du segment @1', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(', subtype @1', NULL, NULL, 1, 107, ', sous-type @1', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(', subtype BLR', NULL, NULL, 1, 108, ', sous-type BLR', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(', subtype ACL', NULL, NULL, 1, 109, ', sous-type ACL', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('date', NULL, NULL, 1, 110, 'date', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(', scale @1', NULL, NULL, 1, 111, ', chelle @1', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(', subtype fixed', NULL, NULL, 1, 112, ', sous-type fixed', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('Database "@1" readied as @2', NULL, NULL, 1, 113, 'La base de donnes "@1" est ouverte comme @2', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('Database "@1"', NULL, NULL, 1, 114, 'Base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('No databases are currently ready', NULL, NULL, 1, 115, 'Aucune base de donnes n''est ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('    Page size is @1 bytes.  Current allocation is @2 pages.', NULL, NULL, 1, 116, '    Taille de page : @1 octets.  @2 pages alloues actuellement.', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('Field @1 does not exist in database @2', NULL, NULL, 1, 117, 'La zone @1 est absente de la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('Field @1 does not exist in any open database', NULL, NULL, 1, 118, 'La zone @1 est absente de toute base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-(' (computed expression)', NULL, NULL, 1, 119, ' (expression calcule)', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('There are no forms defined for database @1', NULL, NULL, 1, 120, 'Aucun cran n''est dfini pour la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('There are no forms defined in any open database', NULL, NULL, 1, 121, 'Aucun cran n''est dfini pour aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('Global field @1 does not exist in database @2', NULL, NULL, 1, 122, 'La zone globale @1 est absente de la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('Global field @1 does not exist in any open database', NULL, NULL, 1, 123, 'La zone globale @1 est absente de toute base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('There are no fields defined for database @1', NULL, NULL, 1, 124, 'Aucune zone n''est dfinie pour la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('There are no fields defined in any open database', NULL, NULL, 1, 125, 'Aucune zone n''est dfinie dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('Procedure @1 not found in database @2', NULL, NULL, 1, 126, 'Procdure @1 introuvable dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('Procedure @1 not found', NULL, NULL, 1, 127, 'Procdure @1 introuvable', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('Procedures in database "@1" (@2):', NULL, NULL, 1, 128, 'Procdures dans la base de donnes "@1" (@2) :', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('No triggers are defined for table @1', NULL, NULL, 1, 129, 'Aucun dclencheur n''est dfini dans la table @1', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('No triggers are defined in database @1', NULL, NULL, 1, 130, 'Aucun dclencheur n''est dfini dans la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('No triggers are defined in database @1', NULL, NULL, 1, 131, 'Aucun dclencheur n''est dfini dans la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('Variables:', NULL, NULL, 1, 132, 'Variables :', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('    QLI, version "@1"', NULL, NULL, 1, 133, '    QLI, version "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('    Version(s) for database "@1"', NULL, NULL, 1, 134, '    Version(s) pour la base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('expand_expression: not yet implemented', NULL, NULL, 1, 135, 'expand_expression : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('expand_statement: not yet implemented', NULL, NULL, 1, 136, 'expand_statement : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('variables may not be based on BLOB fields', NULL, NULL, 1, 137, 'Il n''est pas permis de placer des variables dans des zones de BLOB', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('cannot perform assignment to computed field @1', NULL, NULL, 1, 138, 'Affectation impossible  la zone calcule @1', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('no context for ERASE', NULL, NULL, 1, 139, 'Aucun contexte pour ERASE', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('cannot erase from a join', NULL, NULL, 1, 140, 'Effacement impossible  partir d''une jointure', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('@1.* cannot be used when a single element is required', NULL, NULL, 1, 141, '@1.* ne peut tre utilis quand un seul lment est ncessaire', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('"@1" is undefined or used out of context', NULL, NULL, 1, 142, '"@1" non dfini ou hors contexte', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('no default form name', NULL, NULL, 1, 143, 'Pas de nom d''cran par dfaut', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('No database for form @1', NULL, NULL, 1, 144, 'Aucune base de donnes pour l''cran @1', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('form @1 is not defined in database "@2"', NULL, NULL, 1, 145, 'L''cran @1 n''est pas dfini dans la base de donnes "@2"', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('no context for form ACCEPT statement', NULL, NULL, 1, 146, 'L''nonc d''cran ACCEPT est hors contexte', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('field @1 is not defined in form @2', NULL, NULL, 1, 147, 'La zone @1 n''est pas dfinie pour l''cran @2', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('no context for modify', NULL, NULL, 1, 148, 'Pas de contexte pour une modification', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('field list required for modify', NULL, NULL, 1, 149, 'Liste de zones ncessaire pour une modification', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('No items in print list', NULL, NULL, 1, 150, 'Aucune donne dans la liste de zones pour impression', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('No items in print list', NULL, NULL, 1, 151, 'Pas de donnes dans la liste d''impression', NULL, NULL, 'daves', '1993-07-16 12:11:34')
-('invalid ORDER BY ordinal', NULL, NULL, 1, 152, '"ORDER BY n" non valide', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('asterisk expressions require exactly one qualifying context', NULL, NULL, 1, 153, 'Les expressions avec un astrisque n''ont besoin que d''un seul contexte', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('unrecognized context', NULL, NULL, 1, 154, 'Contexte non reconnu', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('field referenced in BASED ON cannot be resolved against readied databases', NULL, NULL, 1, 155, 'Zone spcifie par BASED ON introuvable dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('expected statement, encountered "@1"', NULL, NULL, 1, 156, 'Prvu : nonc.  Obtenu : "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('Expected PROCEDURE encountered "@1"', NULL, NULL, 1, 157, 'Prvu : PROCEDURE.  Obtenu : "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('period in qualified name', NULL, NULL, 1, 158, 'Point dans un nom complet', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('no databases are ready', NULL, NULL, 1, 159, 'Aucune base de donnes n''est ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('BLOB variables are not supported', NULL, NULL, 1, 160, 'Vaiables de BLOB non reconnues', NULL, NULL, 'daves', '1993-07-16 12:11:38')
-('end of statement', NULL, NULL, 1, 161, 'Fin de l''nonc', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('end of command', NULL, NULL, 1, 162, 'Fin de la commande', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('quoted edit string', NULL, NULL, 1, 163, 'Chane entre guillemets', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('variable definition clause', NULL, NULL, 1, 164, 'Dfinition d''une variable', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('@1 is not a database', NULL, NULL, 1, 165, '@1 n''est pas une base de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('@1 is not a table in database @2', NULL, NULL, 1, 166, '@1 n''est pas une table dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('variable data type', NULL, NULL, 1, 167, 'Type de donne d''une variable', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('no data type may be specified for a variable based on a field', NULL, NULL, 1, 168, 'Aucun type de donne ne peut tre spcifi pour une variable d''une zone', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('object type for DEFINE', NULL, NULL, 1, 169, 'Type d''objet pour DEFINE', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('table name', NULL, NULL, 1, 170, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('comma between field definitions', NULL, NULL, 1, 171, 'Virgule entre dfinitions de zones', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('FROM', NULL, NULL, 1, 172, 'FROM', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('table or view name', NULL, NULL, 1, 173, 'Nom de table ou de vue', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('[', NULL, NULL, 1, 174, '[', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-(']', NULL, NULL, 1, 175, ']', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('No statements issued yet', NULL, NULL, 1, 176, 'Aucun nonc mis', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('ON or TO', NULL, NULL, 1, 177, 'ON ou TO', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('quoted edit string', NULL, NULL, 1, 178, 'Chane de validation entre guillemets', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('column definition clause', NULL, NULL, 1, 179, 'Dfinition d''une ###', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('global fields may not be based on other fields', NULL, NULL, 1, 180, 'Impossible de dfinir des zones globales  partir d''autres zones', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('field name or asterisk expression', NULL, NULL, 1, 181, 'Nom de zone ou expression avec astrisque', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('FROM RSE clause', NULL, NULL, 1, 182, 'Option RSE FROM', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('comma', NULL, NULL, 1, 183, 'Virgule', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('quoted header segment', NULL, NULL, 1, 184, 'Segment d''en-tte entre guillemets', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('left parenthesis', NULL, NULL, 1, 185, 'Parenthse ouvrante', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('comma or terminating right parenthesis', NULL, NULL, 1, 186, 'Virgule ou parenthse fermante', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('left parenthesis', NULL, NULL, 1, 187, 'Parenthse ouvrante', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('VALUES list or SELECT clause', NULL, NULL, 1, 188, 'Liste VALUES ou option SELECT', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('the number of values do not match the number of fields', NULL, NULL, 1, 189, 'Le nombre de valeurs ne correspond pas au nombre de zones', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('value expression', NULL, NULL, 1, 190, 'Valeur', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('right parenthesis', NULL, NULL, 1, 191, 'Parenthse fermante', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('quoted string', NULL, NULL, 1, 192, 'Chane entre guillemets', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-COMMIT WORK;
-('ENTREE or END', NULL, NULL, 1, 193, 'ENTREE ou END', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('quoted string', NULL, NULL, 1, 194, 'Chane entre guillemets', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('index state option', NULL, NULL, 1, 195, 'Option d''tat de l''index', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('table name', NULL, NULL, 1, 196, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('ADD, MODIFY, or DROP', NULL, NULL, 1, 197, 'ADD, MODIFY ou DROP', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('comma between field definitions', NULL, NULL, 1, 198, 'Virgule entre dfinitions de zones', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('identifier', NULL, NULL, 1, 199, 'Identificateur', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('positive number', NULL, NULL, 1, 200, 'Nombre positif', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('FORM', NULL, NULL, 1, 201, 'FORM', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('period in qualified table name', NULL, NULL, 1, 202, 'Point dans un nom complet de table', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('@1 is not a table in database @2', NULL, NULL, 1, 203, '@1 n''est pas une table dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('database file name required on READY', NULL, NULL, 1, 204, 'Nom du fichier de la base de donnes requis pour READY', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('EXISTS (SELECT * <sql rse>)', NULL, NULL, 1, 205, 'EXISTS (SELECT * <sql rse>)', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('relational operator', NULL, NULL, 1, 206, 'Oprateur de relation', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('a database has not been readied', NULL, NULL, 1, 207, 'Une base de donnes n''est pas ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('expected "table_name", encountered "@1"', NULL, NULL, 1, 208, 'Prvu : "nom-de-table".  Obtenu : "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('table name', NULL, NULL, 1, 209, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('PROCEDURE', NULL, NULL, 1, 210, 'PROCEDURE', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('TOP or BOTTOM', NULL, NULL, 1, 211, 'TOP ou BOTTOM', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('report writer SET option', NULL, NULL, 1, 212, 'Option SET du gnrateur de rapports', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('report item', NULL, NULL, 1, 213, 'Donne du rapport', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('set option', NULL, NULL, 1, 214, 'Option SET', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('RELATIONS or TRIGGERS', NULL, NULL, 1, 215, 'RELATIONS ou TRIGGERS', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('table name', NULL, NULL, 1, 216, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('database name', NULL, NULL, 1, 217, 'Nom de base de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('table name', NULL, NULL, 1, 218, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('database name', NULL, NULL, 1, 219, 'Nom de base de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('table name', NULL, NULL, 1, 220, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('database name', NULL, NULL, 1, 221, 'Nom de base de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('table name', NULL, NULL, 1, 222, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('table name', NULL, NULL, 1, 223, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('FROM clause', NULL, NULL, 1, 224, 'FROM', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('AVG, MAX, MIN, SUM, or COUNT', NULL, NULL, 1, 225, 'AVG, MAX, MIN, SUM, ou COUNT', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('COUNT (*)', NULL, NULL, 1, 226, 'COUNT (*)', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('left parenthesis', NULL, NULL, 1, 227, 'Parenthse ouvrante', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('OF', NULL, NULL, 1, 228, 'OF', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('database handle', NULL, NULL, 1, 229, '### de base de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('SET', NULL, NULL, 1, 230, 'SET', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('database block not found for removal', NULL, NULL, 1, 231, 'Bloc de base de donnes introuvable pour suppression', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('show_fields: dtype not done', NULL, NULL, 1, 232, 'show_fields : type de donne non reconnu', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('global field @1 already exists', NULL, NULL, 1, 233, 'Zone(s) globale @1 existante(s)', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Cannot define an index in a view', NULL, NULL, 1, 234, 'Impossible de dfinir un index dans une vue', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Index @1 already exists', NULL, NULL, 1, 235, 'L''index @1 existe dj', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Column @1 does not occur in table @2', NULL, NULL, 1, 236, 'La ### @1 n''existe pas dans la table @2', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Table @1 already exists', NULL, NULL, 1, 237, 'La table @1 existe dj', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Field @1 is in use in the following relations:', NULL, NULL, 1, 238, 'La zone @1 est utilise dans les relations suivantes :', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Field @1 is in use in database "@2"', NULL, NULL, 1, 239, 'La zone @1 est utilise dans la base de donnes "@2"', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Field @1 is not defined in database "@2"', NULL, NULL, 1, 240, 'La zone @1 n''est pas dfinie dans la base de donnes "@2"', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Index @1 is not defined in database "@2"', NULL, NULL, 1, 241, 'L''index @1 n''est pas dfini dans la base de donnes "@2"', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('metadata operation failed', NULL, NULL, 1, 242, 'chec de l''opration sur des mtadonnes', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('no active database for operation', NULL, NULL, 1, 243, 'Aucune base de donnes n''est ouverte pour l''opration', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Interactive metadata updates are not available on Rdb', NULL, NULL, 1, 244, 'Mises  jour interactives de mtadonnes non disponibles dans les bases de donnes relationnelles', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('global field @1 is not defined', NULL, NULL, 1, 245, 'La zone globale @1 n''est pas dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Index @1 does not exist in database @2', NULL, NULL, 1, 246, 'L''index @1 n''existe pas dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('field @1 does not exist', NULL, NULL, 1, 247, 'La zone @1 n''existe pas', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('no active database for operation', NULL, NULL, 1, 248, 'Aucune base de donnes n''est ouverte pour l''opration', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Interactive metadata updates are not available on Rdb', NULL, NULL, 1, 249, 'Mises  jour interactives de mtadonnes non disponibles dans les bases de donnes relationnelles', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Unlicensed for database "@1"', NULL, NULL, 1, 250, 'Pas de licence pour la base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Field @1 already exists in relation @2', NULL, NULL, 1, 251, 'La zone @1 n''existe pas dans la relation @2', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('data type cannot be changed locally', NULL, NULL, 1, 252, 'Modification du type de donne impossible localement', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('global field @1 does not exist', NULL, NULL, 1, 253, 'La zone globale @1 n''existe pas', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('field @1 not found in relation @2', NULL, NULL, 1, 254, 'La zone @1 est introuvable dans la relation @2', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Data type conflict with existing global field @1', NULL, NULL, 1, 255, 'Type de donne incompatible avec zone globale @1 existante', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('No data type specified for field @1', NULL, NULL, 1, 256, 'Aucun type de donne n''est dfini pour la zone @1', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('database info call failed', NULL, NULL, 1, 257, 'chec de l''appel d''information sur la base de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('do not understand BLR operator @1', NULL, NULL, 1, 258, 'Oprateur BLR @1 inconnu', NULL, NULL, 'daves', '1993-07-16 12:11:40')
-('Operation unlicensed for database "@1"', NULL, NULL, 1, 259, 'Pas de licence pour cette opration sur la base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Security class for database @1', NULL, NULL, 1, 260, '    Catgorie de scurit pour la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Database description:', NULL, NULL, 1, 261, '    Description de la base de donnes :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Database description:', NULL, NULL, 1, 262, '    Description de la base de donnes :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('	File:	@1 starting at page @2', NULL, NULL, 1, 263, '	Fichier :	@1 commence  la page @2', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('Field @1 in @2 @3 of database @4', NULL, NULL, 1, 264, 'Le fichier @1 est dans @2 @3 de la base de donnes @4', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Global field @1', NULL, NULL, 1, 265, '    Zone globale @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field description:', NULL, NULL, 1, 266, '    Description de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Datatype information:', NULL, NULL, 1, 267, '    Information sur le type de donne :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field is computed from:', NULL, NULL, 1, 268, '    La zone est calcule  partir de :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field validation:', NULL, NULL, 1, 269, '    Validation de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Security class @1', NULL, NULL, 1, 270, '    Catgorie de scurit @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Query name:	 @1', NULL, NULL, 1, 271, '    Nom de l''interrogation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Query name:	 @1', NULL, NULL, 1, 272, '    Nom de l''interrogation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Edit string:	 @1', NULL, NULL, 1, 273, '    Chane de validation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Edit string:	 @1', NULL, NULL, 1, 274, '    Chane de validation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Query header:', NULL, NULL, 1, 275, '    En-tte de l''interrogation :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('Global field @1 in database @2', NULL, NULL, 1, 276, 'La zone globale @1 est dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field description:', NULL, NULL, 1, 277, '    Description de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Datatype information:', NULL, NULL, 1, 278, '    Information sur le type de donne :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field is computed from:', NULL, NULL, 1, 279, '    Zone calcule  partir de :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field validation:', NULL, NULL, 1, 280, '    Validation de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Query name:	 @1', NULL, NULL, 1, 281, '    Nom de l''interrogation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Edit string:	 @1', NULL, NULL, 1, 282, '    Chane de validation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Query header:', NULL, NULL, 1, 283, '    En-tte de l''interrogation :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    @1 is not used in any relations in database @2', NULL, NULL, 1, 284, '    @1 n''est utilis dans aucune relation de la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('Forms in database @1', NULL, NULL, 1, 285, 'crans de la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('Global fields for database @1:', NULL, NULL, 1, 286, 'Zones globales pour la base de donnes @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Field description:', NULL, NULL, 1, 287, '    Description de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('        Index @1@2', NULL, NULL, 1, 288, '        Index @1@2', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('            index @1 is NOT active', NULL, NULL, 1, 289, '            L''index @1 n''est pas actif', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('        Index @1@2', NULL, NULL, 1, 290, '        Index @1@2', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Description:', NULL, NULL, 1, 291, '    Description :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Security class @1', NULL, NULL, 1, 292, '    Catgorie de scurit @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Stored in external file @1', NULL, NULL, 1, 293, '    Stock dans le fichier externe @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -        An erase trigger is defined for @1', NULL, NULL, 1, 294, '### -        Un dclencheur d''effacement est dfini pour @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -        A modify trigger is defined for @1', NULL, NULL, 1, 295, '### -        Un dclencheur de modification est dfini pour @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -        A store trigger is defined for @1', NULL, NULL, 1, 296, '### -        Un dclencheur de stockage est dfini pour @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('    Security classes for database @1', NULL, NULL, 1, 297, '    Catgories de scurit pour la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -	Triggers for relation @1:', NULL, NULL, 1, 298, '### -	Dclencheurs pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('OBSOLETE -    Source for the erase trigger is not available.  Trigger BLR:', NULL, NULL, 1, 299, '### -    Code source non disponible pour le dclencheur d''effacement.  Dclencheur BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('OBSOLETE -    Erase trigger for relation @1:', NULL, NULL, 1, 300, '### -    Dclencheur d''effacement pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:39')
-('OBSOLETE -    Source for the modify trigger is not available.  Trigger BLR:', NULL, NULL, 1, 301, '### -    Code source non disponible pour le dclencheur de modification.  Dclencheur BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Modify trigger for relation @1:', NULL, NULL, 1, 302, '### -    Dclencheur de modification pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Source for the store trigger is not available.  Trigger BLR:', NULL, NULL, 1, 303, '### -    Code source non disponible pour le dclencheur de stockage.  Dclencheur BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Store trigger for relation @1:', NULL, NULL, 1, 304, '### -    Dclencheur de stockage pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Triggers for relation @1:', NULL, NULL, 1, 305, '### -    Dclencheurs pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Source for the erase trigger is not available.  Trigger BLR:', NULL, NULL, 1, 306, '### -    Code source non disponible pour le dclencheur d''effacement.  Dclencheur BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Erase trigger for relation @1:', NULL, NULL, 1, 307, '### -    Dclencheur d''effacement pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Source for the modify trigger is not available.  Trigger BLR:', NULL, NULL, 1, 308, '### -    Code source non disponible pour le dclencheur de modification.  Dclencheur BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Modify trigger for relation @1:', NULL, NULL, 1, 309, '### -    Dclencheur de modification pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Source for the store trigger is not available.  Trigger BLR:', NULL, NULL, 1, 310, '### -    Code source non disponible pour le dclencheur de stockage.  Dclencheur BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:41')
-('OBSOLETE -    Store trigger for relation @1:', NULL, NULL, 1, 311, '### -    Dclencheur de stockage pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('
-    View source for relation @1 is not available.  View BLR:', NULL, NULL, 1, 312, '
-    Code source de la vue non disponible pour la relation @1.  Vue BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('
-    Relation @1 is a view defined as:', NULL, NULL, 1, 313, '
-    La relation @1 est une vue dfinie comme :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('Views in database @1:', NULL, NULL, 1, 314, 'Vues dans la base de donnes @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    @1 comprised of :', NULL, NULL, 1, 315, '    @1 comprenant :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('Views in database @1:', NULL, NULL, 1, 316, 'Vues dans la base de donnes @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    @1 comprised of:', NULL, NULL, 1, 317, '    @1 comprenant :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('BLOB', NULL, NULL, 1, 318, 'BLOB', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', segment length @1', NULL, NULL, 1, 319, ', longueur du segment @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', subtype text', NULL, NULL, 1, 320, ', texte du sous-type', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', subtype BLR', NULL, NULL, 1, 321, ', sous-type BLR', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', subtype ACL', NULL, NULL, 1, 322, ', sous-type ACL', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', subtype @1', NULL, NULL, 1, 323, ', sous-type @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('text, length @1', NULL, NULL, 1, 324, 'texte, longueur @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('varying text, length @1', NULL, NULL, 1, 325, 'Texte variable, longueur @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('null terminated text, length @1', NULL, NULL, 1, 326, 'Texte termin par des caractres nuls, longueur @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('short binary', NULL, NULL, 1, 327, 'Binaire court', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('long binary', NULL, NULL, 1, 328, 'Binaire long', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('quadword binary', NULL, NULL, 1, 329, 'Binaire QUADWORD', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('short floating', NULL, NULL, 1, 330, 'Reprsentation courte d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('long floating', NULL, NULL, 1, 331, 'Reprsentation longue d''une donne de type FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('date', NULL, NULL, 1, 332, 'date', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', scale @1', NULL, NULL, 1, 333, ', chelle @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-(', subtype fixed', NULL, NULL, 1, 334, ', sous-type fixed', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Global field @1 is used in database @2 as :', NULL, NULL, 1, 335, '    La zone globale @1 est utilise dans la base de donnes @2 comme :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('	@1 in relation @2', NULL, NULL, 1, 336, '	@1 est dans la relation @2', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('Field @1 in @2 @3 of database @4', NULL, NULL, 1, 337, 'La zone @1 est dans @2 @3 de la base de donnes @4', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Global field @1', NULL, NULL, 1, 338, '    Zone globale @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Field description:', NULL, NULL, 1, 339, '    Description de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Datatype information', NULL, NULL, 1, 340, '    Information sur le type de donnes', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Field is computed from:', NULL, NULL, 1, 341, '    Zone calcule  partir de :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Field validation:', NULL, NULL, 1, 342, '    Validation de zone :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Query name:	 @1', NULL, NULL, 1, 343, '    Nom de l''interrogation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Query name:	 @1', NULL, NULL, 1, 344, '    Nom de l''interrogation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Query header:', NULL, NULL, 1, 345, '    En-tte de l''interrogation :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Edit string:	 @1', NULL, NULL, 1, 346, '    Chane de validation :	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('    Edit string: 	 @1', NULL, NULL, 1, 347, '    Chane de validation : 	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('@1 Based on field @2 of @3@4', NULL, NULL, 1, 348, '@1 Bas sur la zone @2 de @3@4', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('@1Base field description for @2:', NULL, NULL, 1, 349, 'Description de la zone de @1Base pour @2 :', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('END PROCEDURE', NULL, NULL, 1, 350, 'END PROCEDURE', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('Do you want to roll back your updates?', NULL, NULL, 1, 351, 'Annulation de vos mises  jour ?', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('gen_descriptor: dtype not recognized', NULL, NULL, 1, 352, 'gen_descriptor : type de donne non reconnu', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('gen_expression: not understood', NULL, NULL, 1, 353, 'gen_expression : non reconnu', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('gen_statement: not yet implemented', NULL, NULL, 1, 354, 'gen_statement : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('gen_statistical: not understood', NULL, NULL, 1, 355, 'gen_statistical : non reconnu', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('EDIT argument must be a BLOB field', NULL, NULL, 1, 356, 'L''argument de EDIT doit tre une zone de BLOB', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('relations from multiple databases in single RSE', NULL, NULL, 1, 357, 'Relations de plusieurs bases de donnes dans une seule RSE', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('cannot find database for BLOB edit', NULL, NULL, 1, 358, 'Base de donnes introuvable pour dition de BLOB', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('compile_expression: not yet implemented', NULL, NULL, 1, 359, 'compile_expression : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('not yet implemented (compile_statement)', NULL, NULL, 1, 360, 'compile_statement : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('computable: not yet implemented', NULL, NULL, 1, 361, 'COMPUTABLE : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('make_descriptor: not yet implemented', NULL, NULL, 1, 362, 'make_descriptor : non mis en oeuvre', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('missing message', NULL, NULL, 1, 363, 'Message manquant', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('lost message', NULL, NULL, 1, 364, 'Message perdu', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Triggers for relation @1:', NULL, NULL, 1, 365, 'Dclencheurs pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('    @1	@2, Sequence @3, @4', NULL, NULL, 1, 366, '    @1	@2, squence @3, @4', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Pre-store', NULL, NULL, 1, 367, 'Pre-store', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Post-store', NULL, NULL, 1, 368, 'Post-store', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Pre-modify', NULL, NULL, 1, 369, 'Pre-modify', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Post-modify', NULL, NULL, 1, 370, 'Post-modify', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Pre-erase', NULL, NULL, 1, 371, 'Pre-erase', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Post-erase', NULL, NULL, 1, 372, 'Post-erase', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Active', NULL, NULL, 1, 373, 'Active', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Inactive', NULL, NULL, 1, 374, 'Inactive', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('	Description:', NULL, NULL, 1, 375, '	Description :', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('	Source for the trigger:', NULL, NULL, 1, 376, '	Code source du dclencheur :', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('	Source for the trigger is not available.  Trigger BLR:', NULL, NULL, 1, 377, '	Code source non disponible pour le dclencheur.  Dclencheur  BLR :', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('No system triggers are defined', NULL, NULL, 1, 378, 'Aucun dclencheur du systme n''est dfini', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('System Trigger for relation @1', NULL, NULL, 1, 379, 'Dclencheur du systme pour la relation @1', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('	Triggers defined for this relation:', NULL, NULL, 1, 380, '	Dclencheurs dfinis pour cette relation :', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Trigger for relation @1:', NULL, NULL, 1, 381, 'Dclencheur pour la relation @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('TOP or BOTTOM', NULL, NULL, 1, 382, 'TOP ou BOTTOM', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('sort field', NULL, NULL, 1, 383, 'Zone de tri', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Too many WITHs', NULL, NULL, 1, 384, 'Trop d''noncs WITH', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('	Shadow @1, File: @2 starting at page @3', NULL, NULL, 1, 385, '	Fichier SHADOW @1, Fichier : @2 commence  la page @3', NULL, NULL, 'daves', '1993-07-16 12:11:48')
-('DATABASE, TABLE, or INDEX', NULL, NULL, 1, 386, 'DATABASE, TABLE ou INDEX', NULL, NULL, 'daves', '1993-07-16 12:11:48')
-('Database filename required in CREATE', NULL, NULL, 1, 387, 'Nom de base de donnes requis dans CREATE', NULL, NULL, 'daves', '1993-07-16 12:11:48')
-('FLOAT', NULL, NULL, 1, 388, 'FLOAT', NULL, NULL, 'daves', '1993-07-16 12:11:48')
-('INDEX', NULL, NULL, 1, 389, 'INDEX', NULL, NULL, 'daves', '1993-07-16 12:11:48')
-('Multiple page size specifications', NULL, NULL, 1, 390, 'Plusieurs spcifications de taille de page', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('GROUP BY not allowed in view definition', NULL, NULL, 1, 391, 'GROUP BY n''est pas autoris dans la dfinition d''une vue', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Aggregates not allowed in view definition', NULL, NULL, 1, 392, 'Opration globale non autorise dans la dfinition d''une vue', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('NULL', NULL, NULL, 1, 393, 'NULL', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('AS', NULL, NULL, 1, 394, 'AS', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('SELECT', NULL, NULL, 1, 395, 'SELECT', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('=', NULL, NULL, 1, 396, '=', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('ON', NULL, NULL, 1, 397, 'ON', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('field name', NULL, NULL, 1, 398, 'Nom de zone', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('table name', NULL, NULL, 1, 399, 'Nom de table', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('user name identifier', NULL, NULL, 1, 400, 'Identification de l''utilisateur', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('GRANT', NULL, NULL, 1, 401, 'GRANT', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('OPTION', NULL, NULL, 1, 402, 'OPTION', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('FROM', NULL, NULL, 1, 403, 'FROM', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('TO', NULL, NULL, 1, 404, 'TO', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('ADD or DROP', NULL, NULL, 1, 405, 'ADD ou DROP', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Dynamic DDL buffer exceeded', NULL, NULL, 1, 406, 'Zone tampon dpasse pour DDL dynamique', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('TABLE', NULL, NULL, 1, 407, 'TABLE', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Database handle @1 conflicts with an established name', NULL, NULL, 1, 408, 'L''alias @1 de la base de donne est incompatible avec un nom tabli', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Could not create QLI$PROCEDURES index', NULL, NULL, 1, 409, 'Cration impossible de l''index de QLI$PROCEDURES', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Cannot convert from @1 to @2', NULL, NULL, 1, 410, 'Conversion impossible de @1  @2', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('Cannot convert "@1" to a numeric value', NULL, NULL, 1, 411, 'Conversion impossible de "@1" en un nombre', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('function @1 not found in database @2', NULL, NULL, 1, 412, 'fonction @1 introuvable dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Incompatible global field @1 already exists in target database', NULL, NULL, 1, 413, 'La zone globale incompatible @1 existe dj dans la base de donnes de destination', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('Relation @1 is missing or undefined', NULL, NULL, 1, 414, 'La relation @1 est absente ou non dfinie', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('matching language string too long', NULL, NULL, 1, 415, 'La chane correspondante est trop longue', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Functions in database "@1" (@2):', NULL, NULL, 1, 416, 'Fonctions de la base de donnes "@1" (@2) :', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Functions are not supported in database @1.', NULL, NULL, 1, 417, 'Fonctions non reconnues dans la base de donnes @1', NULL, NULL, 'daves', '1993-07-16 12:11:49')
--- 418 doesn't exist
-('There are no functions defined in any open database.', NULL, NULL, 1, 419, 'Aucune fonction n''est dfinie dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Functions are not supported in any open database.', NULL, NULL, 1, 420, 'Fonctions non reconnues dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('    Function description:', NULL, NULL, 1, 421, '    Description de fonction :', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Function @1 is not defined in database @2.', NULL, NULL, 1, 422, 'La fonction @1 n''est pas dfinie dans la base de donnes @2', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Function @1 is not defined in any open database.', NULL, NULL, 1, 423, 'La fonction @1 n''est dfinie dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Function @1 (@2) in database "@3" (@4):', NULL, NULL, 1, 424, 'La fonction @1 (@2) dans la base de donnes "@3" (@4) :', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Function @1 in database "@2" (@3):', NULL, NULL, 1, 425, 'Fonction @1 dans la base de donnes "@2" (@3) :', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('    Function library is @1', NULL, NULL, 1, 426, '    La bibliothque de fonctions est @1', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('    Return argument is', NULL, NULL, 1, 427, '    L''argument de retour est', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('    Argument @1 is', NULL, NULL, 1, 428, '    L''argument @1 est', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('database file name required on DROP DATABASE', NULL, NULL, 1, 429, 'Nom de base de donnes requis dans DROP DATABASE', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Unlicensed for database "@1"', NULL, NULL, 1, 430, 'Pas de licence pour la base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Could not drop database file "@1"', NULL, NULL, 1, 431, 'limination impossible du fichier de base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('Operation unlicensed for database "@1"', NULL, NULL, 1, 432, 'Pas de licence pour l''opration sur la base de donnes "@1"', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-(' array', NULL, NULL, 1, 433, ' Tableau', NULL, NULL, 'daves', '1993-07-16 12:11:49')
-('memory pool free list is incorrect', NULL, NULL, 1, 434, 'Liste errone de blocs disponibles dans la rserve de mmoire', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('block released twice', NULL, NULL, 1, 435, 'Bloc libr deux fois', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('released block overlaps following free block', NULL, NULL, 1, 436, 'Le bloc libr recouvre le bloc disponible suivant', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('released block overlaps prior free block', NULL, NULL, 1, 437, 'Le bloc libr recouvre le bloc disponible antrieur', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('References to array fields like @1 in relation @2 are not supported', NULL, NULL, 1, 438, 'La rfrence  des zones d''un tableau comme @1 n''est pas reconnue dans la relation @2', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('Filters are not supported in database @1.', NULL, NULL, 1, 439, 'Les filtres de conversion ne sont pas reconnus dans la base de donnes @1.', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('Filter @1 is not defined in database @2.', NULL, NULL, 1, 440, 'Le filtre de conversion @1 n''est pas dfini dans la base de donnes @2.', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('Filter @1 is not defined in any open database.', NULL, NULL, 1, 441, 'Le filtre de conversion @1 n''est reconnu dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('Filters are not supported in any open database.', NULL, NULL, 1, 442, 'Les filtres de conversion ne sont reconnus dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('There are no filters defined in any open database.', NULL, NULL, 1, 443, 'Il n''y a aucun filtre de conversion dfini dans aucune base de donnes ouverte', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('Filter @1 in database "@2" (@3):', NULL, NULL, 1, 444, 'Filtre de conversion @1 dans la base de donnes "@2" (@3) :', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('    Filter library is @1', NULL, NULL, 1, 445, '    La bibliothque de filtres de conversion est @1', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('    Input sub-type is @1', NULL, NULL, 1, 446, '    Le sous-type en entre est @1', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('    Output sub-type is @1', NULL, NULL, 1, 447, '    Le sous-type en sortie est @1', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('    Filter description:', NULL, NULL, 1, 448, '    Description du filtre de conversion :', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('Filters in database @1 (@2):', NULL, NULL, 1, 449, 'Filtres dans la base de donnes @1 (@2) :', NULL, NULL, 'daves', '1993-07-16 12:11:50')
-('	Index @1@2@3@4', NULL, NULL, 1, 450, '	Index @1@2@3@4', NULL, NULL, 'daves', '1993-07-16 12:11:51')
-('simple field reference not allowed in global aggregates', NULL, NULL, 1, 451, 'Simple rfrence de zone non autorise dans une opration globale', NULL, NULL, 'daves', '1993-07-16 12:11:35')
-('prompting not allowed in select field list', NULL, NULL, 1, 452, 'Demande non autorise dans une liste de zones choisies', NULL, NULL, 'daves', '1993-07-16 12:11:36')
-('output pipe is not supported on MPE/XL', NULL, NULL, 1, 453, 'Racheminement de sortie non reconnue par MPE/XL', NULL, NULL, 'daves', '1993-07-16 12:11:55')
-('could not resolve context for aggregate expression', NULL, NULL, 1, 454, 'Contexte introuvable pour expression d''opration globale', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('source relation @1 does not exist', NULL, NULL, 1, 455, 'Le code source de la relation @1 est inexistant', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('Messages associated with @1:', NULL, NULL, 1, 456, 'Messages associs  @1 :', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('    message @1:  @2', NULL, NULL, 1, 457, '    message @1 :  @2', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('Connection to database @1 lost.
-	Please FINISH the database!', NULL, NULL, 1, 458, 'Le lien  la base de donnes @1 est perdu.
-	Fermer la base de donnes (avec FINISH)', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('Unable to create form window', NULL, NULL, 1, 459, 'Cration impossible d''une fentre d''cran', NULL, NULL, 'daves', '1993-07-16 12:11:42')
-('Do you want to rollback updates for @1?', NULL, NULL, 1, 460, 'Annulation des mises  jour pour @1?', NULL, NULL, 'daves', '1993-07-16 12:11:43')
-('functions are not supported in database @1', NULL, NULL, 1, 461, 'Fonctions non reconnues dans la base de donnes @1.', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('no functions are defined in database @1', NULL, NULL, 1, 462, 'Aucune fonction n''est dfinie dans la base de donnes @1.', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('filters are not supported in database @1', NULL, NULL, 1, 463, 'Filtres non reconnus dans la base de donnes @1.', NULL, NULL, 'daves', '1993-07-16 12:11:59')
-('no filters are defined for database @1', NULL, NULL, 1, 464, 'Aucun filtre n''est reconnu dans la base de donnes @1.', NULL, NULL, 'daves', '1993-07-16 12:12:00')
-('Error during two phase commit on database @1.
-Roll back all databases or commit databases individually', NULL, NULL, 1, 465, 'Erreur au cours de la validation de la base de donnes @1.
-Restaurer les bases de donnes ou les valider (Commit).', NULL, NULL, 'daves', '1993-07-16 12:12:00')
-('Only fields may be subscripted', NULL, NULL, 1, 466, 'Seules les zones peuvent tre indices.', NULL, NULL, 'daves', '1993-07-16 12:12:00')
-('"@1" is not a field and so may not be subscripted', NULL, NULL, 1, 467, '@1 ne peut pas tre indic.  Ce n''est pas une zone.', NULL, NULL, 'daves', '1993-07-16 12:12:00')
-('Data type of field @1 may not be changed to or from BLOB', NULL, NULL, 1, 468, 'Le type de donne de la zone @1 ne peut devenir BLOB.  S''il l''est, il doit le rester.', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('qli: ignoring unknown switch -@1', NULL, NULL, 1, 469, 'QLI :  Option inconnue -@1', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('literal string  <MAXSYMLEN> characters or longer', NULL, NULL, 1, 470, 'Longueur de chane gale ou suprieure  <MAXSYMLEN> caractres.', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('Variable @1', NULL, NULL, 1, 471, 'Variable @1', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('    Query name:	 @1', NULL, NULL, 1, 472, '    Nom de la requte:	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('    Edit string:	 @1', NULL, NULL, 1, 473, '    Chane de validation:	 @1', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('Variable @1 has not been declared', NULL, NULL, 1, 474, 'La variable @1 n''est pas dclare.', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('    Datatype information:', NULL, NULL, 1, 475, '    Type de donne :', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('input line too long', NULL, NULL, 1, 476, 'Ligne en entre trop longue', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('input line too long', NULL, NULL, 1, 477, 'Ligne en entre trop longue', NULL, NULL, 'daves', '1993-07-16 12:11:27')
-('number > 0', NULL, NULL, 1, 478, 'Nombre > 0', NULL, NULL, 'daves', '1993-07-16 12:11:31')
-(' (@1)', NULL, NULL, 1, 479, ' (@1)', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('cannot format unsubscripted array @1', NULL, NULL, 1, 480, 'Mise en forme impossible du tableau sans indiage @1', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('unsuccessful attempt to extend pool beyond 64KB', NULL, NULL, 1, 481, 'chec de l''augmentation de la rserve au-del de 64 Ko', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('field width (@1) * header segments (@2) greater than 60,000 characters', NULL, NULL, 1, 482, 'Le produit de la longueur de la zone (@1) par les segments de l''en-tte (@2) est suprieur  60 000 caractres.', NULL, NULL, 'daves', '1993-07-16 12:11:33')
-('Relation @1 does not exist', NULL, NULL, 1, 483, 'La relation @1 n''existe pas.', NULL, NULL, 'daves', '1993-07-16 12:11:33')
--- Translate (1,484)-(1,512)
-('FORMs not supported', NULL, NULL, 1, 484, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('	Expression index BLR:', NULL, NULL, 1, 485, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Invalid argument for UDF', NULL, NULL, 1, 487, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('SINGULAR (SELECT * <sql rse>)', NULL, NULL, 1, 488, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('JOIN', NULL, NULL, 1, 489, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field @1 in view @2 of database @3', NULL, NULL, 1, 495, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field @1 in relation @2 of database @3', NULL, NULL, 1, 496, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('YES', NULL, NULL, 1, 497, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('NO', NULL, NULL, 1, 498, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Re-enter', NULL, NULL, 1, 499, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Enter', NULL, NULL, 1, 500, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('bad kanji found while formatting output', NULL, NULL, 1, 501, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Subtopic? ', NULL, NULL, 1, 502, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('
-type <cr> for next topic or <EOF> to stop: ', NULL, NULL, 1, 503, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('unknown data type @1', NULL, NULL, 1, 504, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('    reads = !r writes = !w fetches = !f marks = !m', NULL, NULL, 1, 505, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('    elapsed = !e cpu = !u system = !s mem = !x buffers = !b', NULL, NULL, 1, 506, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('@1 Based on field @2 of relation @3', NULL, NULL, 1, 507, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('@1 Based on field @2 of view @3', NULL, NULL, 1, 508, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('PRECISION', NULL, NULL, 1, 509, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field scale exceeds allowed range', NULL, NULL, 1, 510, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field length exceeds allowed range', NULL, NULL, 1, 511, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
-('Field length should be greater than zero', NULL, NULL, 1, 512, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
 --GFIX(3) is missing
 -- Translate (3,1)-(3,115)
 ('data base file name (@1) already given', NULL, NULL, 3, 1, '#', NULL, NULL, 'truser', '1000-01-01 00:00:00')
diff --git a/src/qli/all.cpp b/src/qli/all.cpp
deleted file mode 100644
index d2012769a4..0000000000
--- a/src/qli/all.cpp
+++ /dev/null
@@ -1,512 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		all.cpp
- *	DESCRIPTION:	Internal block allocator
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-/***************************************************
-   THIS MODULE HAS SEVERAL KISSING COUSINS; IF YOU
-   SHOULD CHANGE ONE OF THE MODULES IN THE FOLLOWING
-   LIST, PLEASE BE SURE TO CHECK THE OTHERS FOR
-   SIMILAR CHANGES:
-
-                  /qli/all.cpp
-                  /gpre/msc.cpp
-
-   - THANK YOU
-***************************************************/
-
-#include "firebird.h"
-#include <string.h>
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "../qli/compile.h"
-#include "../qli/exe.h"
-#include "../qli/report.h"
-#include "../qli/format.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/mov_proto.h"
-#include "../yvalve/gds_proto.h"
-
-
-#define BLKDEF(type, root, tail) { sizeof(root), tail },
-
-static const struct
-{
-	SSHORT typ_root_length;
-	SSHORT typ_tail_length;
-} block_sizes[] =
-{
-	{0, 0},
-#include "../qli/blk.h"
-};
-
-#undef BLKDEF
-
-static void extend_pool(qli_plb*, USHORT);
-
-static qli_vec* global_pools;
-
-const int MIN_ALLOCATION	= 1024;
-
-
-BLK ALLQ_alloc( qli_plb* pool, UCHAR type, int count)
-{
-/**************************************
- *
- *	A L L Q _ a l l o c
- *
- **************************************
- *
- * Functional description
- *	Allocate a block from a given pool and initialize the block.
- *	This is the primary block allocation routine.
- *
- **************************************/
-	if (type <= (SCHAR) type_MIN || type >= (SCHAR) type_MAX)
-		ERRQ_bugcheck(1);			// Msg1 bad block type
-
-	// Compute block length
-
-	FB_SIZE_T size = block_sizes[type].typ_root_length;
-
-	SLONG tail = block_sizes[type].typ_tail_length;
-	if (tail)
-		size += count * tail;
-
-	size = FB_ALIGN(size, FB_ALIGNMENT);
-
-	if (size <= 4 || size > 65535)
-		ERRQ_bugcheck(2);			// Msg2 bad block size
-
-	// Find best fit.  Best fit is defined to be the free block of SHORTest
-	// tail.  If there isn't a fit, extend the pool and try, try again.
-
-	qli_frb* free;
-	qli_frb** best;
-	FB_SIZE_T best_tail;
-
-	while (true)
-	{
-		best = NULL;
-		best_tail = 32767;
-		for (qli_frb** ptr = &pool->plb_free; (free = *ptr); ptr = &free->frb_next)
-		{
-			if (free->frb_next && (SCHAR *) free >= (SCHAR *) free->frb_next)
-				ERRQ_bugcheck(434);	// memory pool free list is incorrect
-			else if ((tail = free->frb_header.blk_length - size) >= 0 &&
-				tail < static_cast<SLONG>(best_tail))
-			{
-				best = ptr;
-				best_tail = tail;
-				if (tail == 0)
-					break;
-			}
-		}
-		if (best)
-			break;
-		extend_pool(pool, size);
-	}
-
-	// We've got our free block.  If there's enough left of the free block
-	// after taking out our block, chop out out block.  If not, allocate
-	// the entire free block as our block (a little extra won't hurt).
-
-	free = *best;
-	qli_frb* block;
-	if (best_tail > sizeof(qli_frb))
-	{
-		USHORT l = free->frb_header.blk_length - size;
-		block = (qli_frb*) ((SCHAR *) free + l);
-		free->frb_header.blk_length -= size;
-	}
-	else
-	{
-		*best = free->frb_next;
-		size += best_tail;
-		block = free;
-	}
-
-	block->frb_header.blk_type = type;
-	block->frb_header.blk_pool_id = pool->plb_pool_id;
-	block->frb_header.blk_length = size;
-
-	if (size -= sizeof(blk))
-		memset((SCHAR *) block + sizeof(blk), 0, size);
-
-	return (BLK) block;
-}
-
-
-BLK ALLQ_extend(BLK* pointer, int size)
-{
-/**************************************
- *
- *	A L L Q _ e x t e n d
- *
- **************************************
- *
- * Functional description
- *	Extend a repeating block, copying the constant part.
- *
- **************************************/
-	BLK block = *pointer;
-	BLK new_blk = (BLK) ALLQ_alloc((qli_plb*) global_pools->vec_object[block->blk_pool_id],
-						   block->blk_type, size);
-	const int length = MIN(block->blk_length, new_blk->blk_length) - sizeof(blk);
-	memcpy((SCHAR*) new_blk + sizeof(blk), (SCHAR*) block + sizeof(blk), length);
-	ALLQ_release((qli_frb*) block);
-
-	if (new_blk->blk_type == (SCHAR) type_vec)
-		((qli_vec*) new_blk)->vec_count = size;
-	else if (new_blk->blk_type == (SCHAR) type_vcl)
-		((qli_vcl*) new_blk)->vcl_count = size;
-
-	*pointer = new_blk;
-
-	return new_blk;
-}
-
-
-void ALLQ_fini()
-{
-/**************************************
- *
- *	A L L Q _ f i n i
- *
- **************************************
- *
- * Functional description
- *	Get rid of everything.
- *
- **************************************/
-	qli_plb** vector = (qli_plb**) global_pools->vec_object + global_pools->vec_count;
-	qli_plb** until = (qli_plb**) global_pools->vec_object;
-	while (--vector >= until)
-	{
-	    qli_plb* pool = *vector;
-		if (pool)
-		{
-			qli_hnk* hunk;
-			for (qli_hnk* hunks = pool->plb_hunks; hunk = hunks;)
-			{
-				hunks = hunk->hnk_next;
-				ALLQ_free(hunk->hnk_address);
-			}
-		}
-	}
-}
-
-
-void ALLQ_free(void* memory)
-{
-/**************************************
- *
- *	A L L Q _ f r e e
- *
- **************************************
- *
- * Functional description
- *	Give space back to system.
- *
- **************************************/
-
-	gds__free(memory);
-}
-
-
-void ALLQ_init()
-{
-/**************************************
- *
- *	A L L Q _ i n i t
- *
- **************************************
- *
- * Functional description
- *	Initialize the pool system.
- *
- **************************************/
-	qli_vec temp_vector[2];
-	memset(temp_vector, 0, sizeof(temp_vector));
-
-	global_pools = temp_vector;
-	global_pools->vec_count = 1;
-	global_pools->vec_object[0] = NULL;
-
-    qli_plb* const pool = ALLQ_pool();
-	QLI_default_pool = QLI_permanent_pool = pool;
-	global_pools = (qli_vec*) ALLQ_alloc(pool, type_vec, 10);
-	global_pools->vec_count = 10;
-	global_pools->vec_object[0] = (BLK) pool;
-}
-
-
-SCHAR *ALLQ_malloc(SLONG size)
-{
-/**************************************
- *
- *	A L L Q _ m a l l o c
- *
- **************************************
- *
- * Functional description
- *	Get memory from system.
- *
- **************************************/
-	SCHAR *memory = (SCHAR*) gds__alloc(size);
-
-	if (memory)
-	{
-#ifdef DEBUG_GDS_ALLOC
-		gds_alloc_flag_unfreed((void *) memory);	// Don't care about QLI leaks
-#endif
-		return memory;
-	}
-
-	IBERROR(5);					// Msg5 "memory gonzo"
-	return 0;
-}
-
-
-qli_plb* ALLQ_pool()
-{
-/**************************************
- *
- *	A L L Q _ p o o l
- *
- **************************************
- *
- * Functional description
- *	Allocate a new pool.  This is done by creating a tempory
- *	pool block on the stack, then allocating a real pool block.
- *	In SHORT, by mirrors.
- *
- **************************************/
-	USHORT pool_id;
-
-	// Start by assigning a pool id
-
-	for (pool_id = 0; pool_id < global_pools->vec_count; pool_id++)
-	{
-		if (!(global_pools->vec_object[pool_id]))
-			break;
-	}
-
-	if (pool_id >= global_pools->vec_count)
-		ALLQ_extend((BLK*) &global_pools, pool_id + 10);
-
-	qli_plb temp_pool;
-	global_pools->vec_object[pool_id] = (BLK) &temp_pool;
-	temp_pool.plb_free = NULL;
-	temp_pool.plb_hunks = NULL;
-	temp_pool.plb_pool_id = pool_id;
-	if (pool_id == 0)
-		QLI_permanent_pool = &temp_pool;
-
-	qli_plb* const pool = (qli_plb*) ALLQ_alloc(&temp_pool, type_plb, 0);
-	pool->plb_pool_id = pool_id;
-	pool->plb_free = temp_pool.plb_free;
-	pool->plb_hunks = temp_pool.plb_hunks;
-	global_pools->vec_object[pool_id] = (BLK) pool;
-
-	if (pool_id == 0)
-		QLI_permanent_pool = pool;
-
-	return pool;
-}
-
-
-void ALLQ_push( BLK object, qli_lls** stack)
-{
-/**************************************
- *
- *	A L L Q _ p u s h
- *
- **************************************
- *
- * Functional description
- *	Push an object on a qli_lls stack.
- *
- **************************************/
-	qli_plb* pool = QLI_default_pool;
-
-    qli_lls* node = pool->plb_lls;
-	if (node)
-		pool->plb_lls = node->lls_next;
-	else
-		node = (qli_lls*) ALLQ_alloc(pool, type_lls, 0);
-
-	node->lls_object = object;
-	node->lls_next = *stack;
-	*stack = node;
-}
-
-
-BLK ALLQ_pop(qli_lls** stack)
-{
-/**************************************
- *
- *	A L L Q _ p o p
- *
- **************************************
- *
- * Functional description
- *	Pop an object off a linked list stack.  Save the node for
- *	further use.
- *
- **************************************/
-	qli_lls* node = *stack;
-	qli_plb* pool = (qli_plb*) global_pools->vec_object[node->lls_header.blk_pool_id];
-	*stack = node->lls_next;
-	node->lls_next = pool->plb_lls;
-	pool->plb_lls = node;
-
-	return node->lls_object;
-}
-
-
-void ALLQ_release( qli_frb* block)
-{
-/**************************************
- *
- *	A L L Q _ r e l e a s e
- *
- **************************************
- *
- * Functional description
- *	Release a block to its pool.  If it is contiguous to
- *	another free block, combine them.  Otherwise link it
- *	into the free block linked list (kept in ascending order
- *	of addresses).
- *
- **************************************/
-	block->frb_header.blk_type = (SCHAR) type_frb;
-	UCHAR pool_id = block->frb_header.blk_pool_id;
-
-	qli_plb* pool;
-	if (pool_id >= global_pools->vec_count || !(pool = (qli_plb*) global_pools->vec_object[pool_id]))
-	{
-		ERRQ_bugcheck(4);
-		// Msg4 bad pool id
-	}
-
-	qli_frb* prior = NULL;
-	qli_frb* free;
-	qli_frb** ptr;
-	for (ptr = &pool->plb_free; free = *ptr; prior = free, ptr = &free->frb_next)
-	{
-		if ((SCHAR *) block <= (SCHAR *) free)
-			break;
-	}
-
-	if ((SCHAR *) block == (SCHAR *) free)
-		ERRQ_bugcheck(435);			// block released twice
-
-	// Merge block into list first, then try to combine blocks
-
-	block->frb_next = free;
-	*ptr = block;
-
-	// Try to merge the free block with the next one down.
-
-	if (free)
-	{
-		if ((SCHAR *) block + block->frb_header.blk_length == (SCHAR *) free)
-		{
-			block->frb_header.blk_length += free->frb_header.blk_length;
-			block->frb_next = free->frb_next;
-		}
-		else if ((SCHAR *) block + block->frb_header.blk_length > (SCHAR *) free)
-			ERRQ_bugcheck(436);		// released block overlaps following free block
-	}
-
-	// Try and merge the block with the prior free block
-
-	if (prior)
-	{
-		if ((SCHAR *) prior + prior->frb_header.blk_length == (SCHAR *) block)
-		{
-			prior->frb_header.blk_length += block->frb_header.blk_length;
-			prior->frb_next = block->frb_next;
-		}
-		else if ((SCHAR *) prior + prior->frb_header.blk_length > (SCHAR *) block)
-			ERRQ_bugcheck(437);		// released block overlaps prior free block
-	}
-}
-
-
-void ALLQ_rlpool( qli_plb* pool)
-{
-/**************************************
- *
- *	A L L Q _ r l p o o l
- *
- **************************************
- *
- * Functional description
- *	Release a storage pool.  This involves nothing more than returning
- *	hunks to the free hunk list.
- *
- **************************************/
-	global_pools->vec_object[pool->plb_pool_id] = NULL;
-
-	qli_hnk* hunk;
-	for (qli_hnk* hunks = pool->plb_hunks; hunk = hunks;)
-	{
-		hunks = hunk->hnk_next;
-		gds__free(hunk->hnk_address);
-	}
-}
-
-
-static void extend_pool( qli_plb* pool, USHORT count)
-{
-/**************************************
- *
- *	e x t e n d _ p o o l
- *
- **************************************
- *
- * Functional description
- *	Extend a pool by at least enough to accomodate a block
- *	of given size.
- *
- **************************************/
-	const SLONG size = (count + sizeof(qli_hnk) + MIN_ALLOCATION - 1) & ~(MIN_ALLOCATION - 1);
-
-	if ((USHORT) size < count)
-		IBERROR(481);			// msg 481 unsuccessful attempt to extend pool beyond 64KB
-
-	BLK block = (BLK) ALLQ_malloc(size);
-	block->blk_length = size;
-	block->blk_type = (SCHAR) type_frb;
-	block->blk_pool_id = pool->plb_pool_id;
-	ALLQ_release((qli_frb*) block);
-
-	qli_hnk* const hunk = (qli_hnk*) ALLQ_alloc(pool, type_hnk, 0);
-	hunk->hnk_address = block;
-	hunk->hnk_length = size;
-	hunk->hnk_next = pool->plb_hunks;
-	pool->plb_hunks = hunk;
-}
-
-
diff --git a/src/qli/all_proto.h b/src/qli/all_proto.h
deleted file mode 100644
index a3079f7e63..0000000000
--- a/src/qli/all_proto.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		all_proto.h
- *	DESCRIPTION:	Prototype header file for all.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_ALL_PROTO_H
-#define QLI_ALL_PROTO_H
-
-blk*		ALLQ_alloc(qli_plb*, UCHAR, int);
-blk*		ALLQ_extend(blk**, int);
-void		ALLQ_fini();
-void		ALLQ_free(void*);
-void		ALLQ_init();
-SCHAR*		ALLQ_malloc(SLONG);
-qli_plb*	ALLQ_pool();
-void		ALLQ_push(blk*, qli_lls**);
-blk*		ALLQ_pop(qli_lls**);
-void		ALLQ_release(qli_frb*);
-void		ALLQ_rlpool(qli_plb*);
-
-#endif // QLI_ALL_PROTO_H
-
diff --git a/src/qli/blk.h b/src/qli/blk.h
deleted file mode 100644
index f2bdd2716a..0000000000
--- a/src/qli/blk.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		blk.h
- *	DESCRIPTION:	Block type definitions
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-BLKDEF (type_frb, qli_frb, 0)
-BLKDEF (type_hnk, qli_hnk, 0)
-BLKDEF (type_plb, qli_plb, 0)
-BLKDEF (type_vec, qli_vec, sizeof (((qli_vec*) NULL)->vec_object[0]))
-BLKDEF (type_dbb, qli_dbb, 1)
-BLKDEF (type_rel, qli_rel, 0)
-BLKDEF (type_fld, qli_fld, 1)
-BLKDEF (type_vcl, qli_vcl, sizeof (((qli_vcl*) NULL)->vcl_long[0]))
-BLKDEF (type_req, qli_req, 0)			// Request block
-BLKDEF (type_nod, qli_nod, sizeof(qli_nod*)) // sizeof (((qli_nod*) NULL)->nod_arg[0]))
-BLKDEF (type_syn, qli_nod, sizeof (((qli_syntax*) NULL)->syn_arg[0]))
-BLKDEF (type_lls, qli_lls, 0)			// linked list stack
-BLKDEF (type_str, qli_str, 1)			// random string block
-BLKDEF (type_tok, qli_tok, 1)			// token block
-BLKDEF (type_sym, qli_symbol, 1)		// symbol block
-BLKDEF (type_msg, qli_msg, 0)			// Message block
-BLKDEF (type_nam, qli_name, 1)			// Name node
-BLKDEF (type_ctx, qli_ctx, 0)			// Context block
-BLKDEF (type_con, qli_const, 1)			// Constant block
-BLKDEF (type_itm, qli_print_item, 0)	// Print item
-BLKDEF (type_par, qli_par, 0)			// Parameter block
-BLKDEF (type_line, qli_line, 1)			// Input line block
-BLKDEF (type_brk, qli_brk, 0)
-BLKDEF (type_rpt, qli_rpt, 0)
-BLKDEF (type_pic, pics, 0)
-BLKDEF (type_prt, qli_prt, 0)
-BLKDEF (type_map, qli_map, 0)
-BLKDEF (type_qpr, qli_proc, 0)
-BLKDEF (type_qfn, qli_func, 0)
-BLKDEF (type_qfl, qli_filter, 0)
-BLKDEF (type_fun, qli_fun, 0) 			//, sizeof(dsc)) // sizeof (((FUN) NULL)->fun_arg[0]))
-BLKDEF (type_rlb, qli_rlb, 0)			// Request language block
diff --git a/src/qli/comma_proto.h b/src/qli/comma_proto.h
deleted file mode 100644
index a42e7c3e81..0000000000
--- a/src/qli/comma_proto.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		comma_proto.h
- *	DESCRIPTION:	Prototype header file for command.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_COMMA_PROTO_H
-#define QLI_COMMA_PROTO_H
-
-bool	CMD_check_ready();
-void	CMD_copy_procedure(qli_syntax*);
-void	CMD_define_procedure(qli_syntax*);
-void	CMD_delete_proc(qli_syntax*);
-void	CMD_edit_proc(qli_syntax*);
-void	CMD_extract(qli_syntax*);
-void	CMD_finish(qli_syntax*);
-void	CMD_rename_proc(qli_syntax*);
-void	CMD_set(qli_syntax*);
-void	CMD_shell(qli_syntax*);
-void	CMD_transaction(qli_syntax*);
-
-#endif // QLI_COMMA_PROTO_H
-
diff --git a/src/qli/command.cpp b/src/qli/command.cpp
deleted file mode 100644
index d9abad1c20..0000000000
--- a/src/qli/command.cpp
+++ /dev/null
@@ -1,568 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		command.cpp
- *	DESCRIPTION:	Interprete commands
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "ibase.h"
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "../qli/compile.h"
-#include "../qli/exe.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/exe_proto.h"
-#include "../qli/meta_proto.h"
-#include "../qli/proc_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../common/utils_proto.h"
-
-using MsgFormat::SafeArg;
-
-
-static void dump_procedure(qli_dbb*, FILE*, const TEXT*, USHORT, FB_API_HANDLE);
-static void extract_procedure(void*, const TEXT*, USHORT, qli_dbb*, ISC_QUAD&);
-
-#ifdef NOT_USED_OR_REPLACED
-static SCHAR db_items[] = { gds_info_page_size, gds_info_allocation, gds_info_end };
-#endif
-
-bool CMD_check_ready()
-{
-/**************************************
- *
- *	C M D _ c h e c k _ r e a d y
- *
- **************************************
- *
- * Functional description
- *	Make sure at least one database is ready.  If not, give a
- *	message.
- *
- **************************************/
-
-	if (QLI_databases)
-		return false;
-
-	ERRQ_msg_put(95);	// Msg95 No databases are currently ready
-
-	return true;
-}
-
-
-void CMD_copy_procedure( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ c o p y  _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Copy one procedure to another, possibly
- *	across databases
- *
- **************************************/
-	qli_proc* old_proc = (qli_proc*) node->syn_arg[0];
-	qli_proc* new_proc = (qli_proc*) node->syn_arg[1];
-
-	PRO_copy_procedure(old_proc->qpr_database, old_proc->qpr_name->nam_string,
-					   new_proc->qpr_database, new_proc->qpr_name->nam_string);
-}
-
-
-void CMD_define_procedure( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ d e f i n e  _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Define a procedure in the named database
- *	or in the most recently readied database.
- *
- **************************************/
-	qli_proc* proc = (qli_proc*) node->syn_arg[0];
-
-	if (!(proc->qpr_database))
-		proc->qpr_database = QLI_databases;
-
-	PRO_create(proc->qpr_database, proc->qpr_name->nam_string);
-}
-
-
-void CMD_delete_proc( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ d e l e t e _ p r o c
- *
- **************************************
- *
- * Functional description
- *	Delete a procedure in the named database
- *	or in the most recently readied database.
- *
- **************************************/
-	qli_proc* proc = (qli_proc*) node->syn_arg[0];
-
-	if (!proc->qpr_database)
-		proc->qpr_database = QLI_databases;
-
-	if (PRO_delete_procedure(proc->qpr_database, proc->qpr_name->nam_string))
-		return;
-
-	ERRQ_msg_put(88, SafeArg() << proc->qpr_name->nam_string <<	// Msg88 Procedure %s not found in database %s
-				 proc->qpr_database->dbb_symbol->sym_string);
-}
-
-
-void CMD_edit_proc( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ e d i t _ p r o c
- *
- **************************************
- *
- * Functional description
- *	Edit a procedure in the specified database.
- *
- **************************************/
-	qli_proc* proc = (qli_proc*) node->syn_arg[0];
-	if (!proc->qpr_database)
-		proc->qpr_database = QLI_databases;
-
-	PRO_edit_procedure(proc->qpr_database, proc->qpr_name->nam_string);
-}
-
-
-void CMD_extract( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ e x t r a c t
- *
- **************************************
- *
- * Functional description
- *	Extract a series of procedures.
- *
- **************************************/
-	FILE* file = (FILE*) EXEC_open_output((qli_nod*) node->syn_arg[1]);
-
-	qli_syntax* list = node->syn_arg[0];
-	if (list)
-	{
-		qli_syntax** ptr = list->syn_arg;
-		for (const qli_syntax* const* const end = ptr + list->syn_count; ptr < end; ptr++)
-		{
-			qli_proc* proc = (qli_proc*) *ptr;
-			qli_dbb* database = proc->qpr_database;
-			if (!database)
-				database = QLI_databases;
-
-			const qli_name* name = proc->qpr_name;
-			FB_API_HANDLE blob = PRO_fetch_procedure(database, name->nam_string);
-			if (!blob)
-			{
-				ERRQ_msg_put(89, SafeArg() << name->nam_string << database->dbb_symbol->sym_string);
-				// Msg89 Procedure %s not found in database %s
-				continue;
-			}
-			dump_procedure(database, file, name->nam_string, name->nam_length, blob);
-		}
-	}
-	else
-	{
-		CMD_check_ready();
-		for (qli_dbb* database = QLI_databases; database; database = database->dbb_next)
-		{
-			PRO_scan(database, extract_procedure, file);
-		}
-	}
-
-#ifdef WIN_NT
-	if (((qli_nod*) node->syn_arg[1])->nod_arg[e_out_pipe])
-		_pclose(file);
-	else
-#endif
-		fclose(file);
-}
-
-
-void CMD_finish( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ f i n i s h
- *
- **************************************
- *
- * Functional description
- *	Perform FINISH.  Either finish listed databases or everything.
- *
- **************************************/
-	if (node->syn_count == 0)
-	{
-		while (QLI_databases)
-			MET_finish(QLI_databases);
-		return;
-	}
-
-	for (USHORT i = 0; i < node->syn_count; i++)
-		MET_finish((qli_dbb*) node->syn_arg[i]);
-}
-
-
-void CMD_rename_proc( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ r e n a m e _ p r o c
- *
- **************************************
- *
- * Functional description
- *	Rename a procedure in the named database,
- *	or the most recently readied database.
- *
- **************************************/
-	qli_proc* old_proc = (qli_proc*) node->syn_arg[0];
-	qli_proc* new_proc = (qli_proc*) node->syn_arg[1];
-
-	qli_dbb* database = old_proc->qpr_database;
-	if (!database)
-		database = QLI_databases;
-
-	if (new_proc->qpr_database && (new_proc->qpr_database != database))
-		IBERROR(84);			// Msg84 Procedures can not be renamed across databases. Try COPY
-	const qli_name* old_name = old_proc->qpr_name;
-	const qli_name* new_name = new_proc->qpr_name;
-
-	if (PRO_rename_procedure(database, old_name->nam_string, new_name->nam_string))
-	{
-		return;
-	}
-
-	ERRQ_error(85, SafeArg() << old_name->nam_string << database->dbb_symbol->sym_string);
-	// Msg85 Procedure %s not found in database %s
-}
-
-
-void CMD_set( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ s e t
- *
- **************************************
- *
- * Functional description
- *	Set various options.
- *
- **************************************/
-	USHORT length;
-	const qli_const* string;
-
-	const qli_syntax* const* ptr = node->syn_arg;
-
-	for (USHORT i = 0; i < node->syn_count; i++)
-	{
-		const USHORT foo = (USHORT)(IPTR) *ptr++;
-		const enum set_t sw = (enum set_t) foo;
-		const qli_syntax* value = *ptr++;
-		switch (sw)
-		{
-		case set_blr:
-			QLI_blr = (bool)(IPTR) value;
-			break;
-
-		case set_statistics:
-			QLI_statistics = (bool)(IPTR) value;
-			break;
-
-		case set_columns:
-			QLI_name_columns = QLI_columns = (USHORT)(IPTR) value;
-			break;
-
-		case set_lines:
-			QLI_lines = (USHORT)(IPTR) value;
-			break;
-
-		case set_semi:
-			QLI_semi = (bool)(IPTR) value;
-			break;
-
-		case set_echo:
-			QLI_echo = (bool)(IPTR) value;
-			break;
-
-		//case set_form:
-		//	IBERROR(484);		// FORMs not supported
-		//	break;
-
-		case set_password:
-			string = (qli_const*) value;
-			length = MIN(string->con_desc.dsc_length + 1u, sizeof(QLI_default_password));
-			fb_utils::copy_terminate(QLI_default_password, (char*) string->con_data, length);
-			break;
-
-		case set_prompt:
-			string = (qli_const*) value;
-			if (string->con_desc.dsc_length >= sizeof(QLI_prompt_string))
-				ERRQ_error(86);	// Msg86 substitute prompt string too long
-			fb_utils::copy_terminate(QLI_prompt_string, (char*) string->con_data, string->con_desc.dsc_length + 1);
-			break;
-
-		case set_continuation:
-			string = (qli_const*) value;
-			if (string->con_desc.dsc_length >= sizeof(QLI_cont_string))
-				ERRQ_error(87);	// Msg87 substitute prompt string too long
-			fb_utils::copy_terminate(QLI_cont_string, (char*) string->con_data, string->con_desc.dsc_length + 1);
-			break;
-
-		case set_matching_language:
-			if (QLI_matching_language)
-				ALLQ_release((qli_frb*) QLI_matching_language);
-			string = (qli_const*) value;
-			if (!string)
-				QLI_matching_language = NULL;
-			else
-			{
-				const USHORT len = string->con_desc.dsc_length;
-				QLI_matching_language = (qli_const*) ALLOCPV(type_con, len);
-				fb_utils::copy_terminate((char*) QLI_matching_language->con_data,
-										 (char*) string->con_data, len + 1);
-				dsc& lang = QLI_matching_language->con_desc;
-				lang.dsc_dtype = dtype_text;
-				lang.dsc_address = QLI_matching_language->con_data;
-				lang.dsc_length = len;
-			}
-			break;
-
-		case set_user:
-			string = (qli_const*) value;
-			length = MIN(string->con_desc.dsc_length + 1u, sizeof(QLI_default_user));
-			fb_utils::copy_terminate(QLI_default_user, (char*) string->con_data, length);
-			break;
-
-			break;
-
-		case set_count:
-			QLI_count = (USHORT)(IPTR) value;
-			break;
-
-		case set_charset:
-			{
-				if (!value)
-				{
-					QLI_charset[0] = 0;
-					break;
-				}
-				const TEXT* name = ((qli_name*) value)->nam_string;
-				fb_utils::copy_terminate(QLI_charset, name, sizeof(QLI_charset));
-				break;
-			}
-
-#ifdef DEV_BUILD
-		case set_explain:
-			QLI_explain = (bool)(IPTR) value;
-			break;
-
-		case set_hex_output:
-			QLI_hex_output = (bool)(IPTR) value;
-			break;
-#endif
-
-		default:
-			ERRQ_bugcheck(6);		// Msg6 set option not implemented
-		}
-	}
-}
-
-
-void CMD_shell( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ s h e l l
- *
- **************************************
- *
- * Functional description
- *	Invoke operating system shell.
- *
- **************************************/
-	TEXT buffer[256];
-
-	// Copy command, inserting extra blank at end.
-
-	TEXT* p = buffer;
-	const qli_const* constant = (qli_const*) node->syn_arg[0];
-	if (constant)
-	{
-		const USHORT l = constant->con_desc.dsc_length;
-		if (l)
-			memcpy(p, constant->con_data, l);
-
-		p += l;
-		*p++ = ' ';
-		*p = 0;
-	}
-	else
-	{
-#ifndef WIN_NT
-		strcpy(buffer, "$SHELL");
-#else
-		strcpy(buffer, "%ComSpec%");
-#endif
-	}
-
-	FB_UNUSED(system(buffer));
-}
-
-
-void CMD_transaction( qli_syntax* node)
-{
-/**************************************
- *
- *	C M D _ t r a n s a c t i o n
- *
- **************************************
- *
- * Functional description
- *	Perform COMMIT, ROLLBACK or PREPARE
- *      on listed databases or everything.
- *
- **************************************/
-
-	// If there aren't any open databases then obviously
-	// there isn't anything to commit.
-
-	if (node->syn_count == 0 && !QLI_databases)
-		return;
-
-	if (node->syn_type == nod_commit)
-	{
-		if ((node->syn_count > 1) || (node->syn_count == 0 && QLI_databases->dbb_next))
-		{
-			node->syn_type = nod_prepare;
-			CMD_transaction(node);
-			node->syn_type = nod_commit;
-		}
-		else if (node->syn_count == 1)
-		{
-			qli_dbb* tmp_db = (qli_dbb*) node->syn_arg[0];
-			tmp_db->dbb_flags |= DBB_prepared;
-		}
-		else
-			QLI_databases->dbb_flags |= DBB_prepared;
-	}
-
-
-	if (node->syn_count == 0)
-	{
-		for (qli_dbb* db_iter = QLI_databases; db_iter; db_iter = db_iter->dbb_next)
-		{
-			if ((node->syn_type == nod_commit) && !(db_iter->dbb_flags & DBB_prepared))
-			{
-				ERRQ_msg_put(465, db_iter->dbb_symbol->sym_string);
-			}
-			else if (node->syn_type == nod_prepare)
-				db_iter->dbb_flags |= DBB_prepared;
-			if (db_iter->dbb_transaction)
-				MET_transaction(node->syn_type, db_iter);
-			if (db_iter->dbb_meta_trans)
-				MET_meta_commit(db_iter);
-			if (db_iter->dbb_proc_trans)
-				PRO_commit(db_iter);
-		}
-		return;
-	}
-
-	qli_syntax** ptr = node->syn_arg;
-	for (const qli_syntax* const* const end = ptr + node->syn_count; ptr < end; ptr++)
-	{
-		qli_dbb* database = (qli_dbb*) *ptr;
-		if ((node->syn_type == nod_commit) && !(database->dbb_flags & DBB_prepared))
-		{
-				ERRQ_msg_put(465, database->dbb_symbol->sym_string);
-		}
-		else if (node->syn_type == nod_prepare)
-			database->dbb_flags |= DBB_prepared;
-		if (database->dbb_transaction)
-			MET_transaction(node->syn_type, database);
-	}
-}
-
-
-static void dump_procedure(qli_dbb* database,
-						   FILE* file,
-						   const TEXT* name, USHORT length, FB_API_HANDLE blob)
-{
-/**************************************
- *
- *	d u m p _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Extract a procedure from a database.
- *
- **************************************/
-	TEXT buffer[256];
-
-	fprintf(file, "DELETE PROCEDURE %.*s;\n", length, name);
-	fprintf(file, "DEFINE PROCEDURE %.*s\n", length, name);
-
-	while (PRO_get_line(blob, buffer, sizeof(buffer)))
-		fputs(buffer, file);
-
-	PRO_close(database, blob);
-	fprintf(file, "END_PROCEDURE\n\n");
-}
-
-
-static void extract_procedure(void* file,
-							  const TEXT* name,
-							  USHORT length, qli_dbb* database, ISC_QUAD& blob_id)
-{
-/**************************************
- *
- *	e x t r a c t _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Extract a procedure from a database.
- *
- **************************************/
-	FB_API_HANDLE blob = PRO_open_blob(database, blob_id);
-	dump_procedure(database, static_cast<FILE*>(file), name, length, blob);
-}
-
-
diff --git a/src/qli/compi_proto.h b/src/qli/compi_proto.h
deleted file mode 100644
index 242f22b0cc..0000000000
--- a/src/qli/compi_proto.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		compi_proto.h
- *	DESCRIPTION:	Prototype header file for compile.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_COMPI_PROTO_H
-#define QLI_COMPI_PROTO_H
-
-qli_nod*	CMPQ_compile(qli_nod*);
-void		CMP_alloc_temp(qli_nod*);
-bool		CMP_node_match(const qli_nod*, const qli_nod*);
-
-#endif // QLI_COMPI_PROTO_H
-
diff --git a/src/qli/compile.cpp b/src/qli/compile.cpp
deleted file mode 100644
index aba6f01072..0000000000
--- a/src/qli/compile.cpp
+++ /dev/null
@@ -1,2143 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		compile.cpp
- *	DESCRIPTION:	Compile expanded statement into executable things
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <string.h>
-#include "../qli/dtr.h"
-#include "../qli/compile.h"
-#include "../qli/exe.h"
-#include "../qli/report.h"
-#include "../jrd/intl.h"
-#include "../qli/all_proto.h"
-#include "../qli/compi_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/forma_proto.h"
-#include "../qli/meta_proto.h"
-#include "../common/dsc_proto.h"
-#include "../common/gdsassert.h"
-#include "../jrd/align.h"
-
-const USHORT PROMPT_LENGTH	= 80;
-
-static qli_nod* compile_any(qli_nod*, qli_req*);
-static qli_nod* compile_assignment(qli_nod*, qli_req*, bool);
-static void compile_context(qli_nod*, qli_req*, bool);
-static void compile_control_break(qli_brk*, qli_req*);
-static qli_nod* compile_edit(qli_nod*, qli_req*);
-static qli_nod* compile_erase(qli_nod*, qli_req*);
-static qli_nod* compile_expression(qli_nod*, qli_req*, bool);
-static qli_nod* compile_field(qli_nod*, qli_req*, bool);
-static qli_nod* compile_for(qli_nod*, qli_req*, bool);
-static qli_nod* compile_function(qli_nod*, qli_req*, bool);
-static qli_nod* compile_if(qli_nod*, qli_req*, bool);
-static qli_nod* compile_list_fields(qli_nod*, qli_req*);
-static qli_nod* compile_modify(qli_nod*, qli_req*, bool);
-static qli_nod* compile_print(qli_nod*, qli_req*);
-static qli_nod* compile_print_list(qli_nod*, qli_req*, qli_lls**);
-static qli_nod* compile_prompt(qli_nod*);
-static qli_nod* compile_repeat(qli_nod*, qli_req*, bool);
-static qli_nod* compile_report(qli_nod*, qli_req*);
-static qli_req* compile_rse(qli_nod*, qli_req*, bool, qli_msg**, qli_msg**, qli_dbb**);
-static qli_nod* compile_statement(qli_nod*, qli_req*, bool);
-static qli_nod* compile_statistical(qli_nod*, qli_req*, bool);
-static qli_nod* compile_store(qli_nod*, qli_req*, bool);
-static bool computable(qli_nod*, qli_req*);
-static void make_descriptor(qli_nod*, dsc*);
-static qli_msg* make_message(qli_req*);
-static void make_missing_reference(qli_par*);
-static qli_par* make_parameter(qli_msg*, qli_nod*);
-static qli_nod* make_reference(qli_nod*, qli_msg*);
-static qli_req* make_request(qli_dbb*);
-static void release_message(qli_msg*);
-static int string_length(const dsc*);
-
-static qli_lls* print_items;
-static TEXT** print_header;
-static qli_brk* report_control_break;
-
-
-qli_nod* CMPQ_compile( qli_nod* node)
-{
-/**************************************
- *
- *	C M P _ c o m p i l e
- *
- **************************************
- *
- * Functional description
- *	Compile a statement into something executable.
- *
- **************************************/
-
-	print_header = NULL;
-	print_items = NULL;
-	QLI_requests = NULL;
-	compile_statement(node, 0, true);
-
-	if (print_header)
-		*print_header = FMT_format(print_items);
-
-	return node;
-}
-
-
-void CMP_alloc_temp(qli_nod* node)
-{
-/**************************************
- *
- *	C M P _ a l l o c _ t e m p
- *
- **************************************
- *
- * Functional description
- *	Allocate a data area for a node.
- *
- **************************************/
-	if (node->nod_desc.dsc_address)
-		return;
-
-	qli_str* string = (qli_str*) ALLOCDV(type_str, node->nod_desc.dsc_length +
-					     type_alignments[node->nod_desc.dsc_dtype]);
-	node->nod_desc.dsc_address = (UCHAR*)
-		FB_ALIGN(string->str_data, type_alignments[node->nod_desc.dsc_dtype]);
-	QLI_validate_desc(node->nod_desc);
-}
-
-
-bool CMP_node_match( const qli_nod* node1, const qli_nod* node2)
-{
-/**************************************
- *
- *	C M P _ n o d e _ m a t c h
- *
- **************************************
- *
- * Functional description
- *	Compare two nodes for equality of value.
- *
- **************************************/
-	if (!node1 || !node2 || node1->nod_type != node2->nod_type)
-		return false;
-
-	switch (node1->nod_type)
-	{
-	case nod_field:
-		if (node1->nod_arg[e_fld_field] != node2->nod_arg[e_fld_field] ||
-			node1->nod_arg[e_fld_context] != node2->nod_arg[e_fld_context] ||
-			node1->nod_arg[e_fld_subs] != node2->nod_arg[e_fld_subs])
-		{
-			return false;
-		}
-		return true;
-
-	case nod_constant:
-		{
-			if (node1->nod_desc.dsc_dtype != node2->nod_desc.dsc_dtype ||
-				node1->nod_desc.dsc_scale != node2->nod_desc.dsc_scale ||
-				node1->nod_desc.dsc_length != node2->nod_desc.dsc_length)
-			{
-				return false;
-			}
-			int l = node1->nod_desc.dsc_length;
-			if (l)
-				return memcmp(node1->nod_desc.dsc_address, node2->nod_desc.dsc_address, l) == 0;
-
-			return true;
-		}
-
-	case nod_map:
-		{
-			const qli_map* map1 = (qli_map*) node1->nod_arg[e_map_map];
-			const qli_map* map2 = (qli_map*) node2->nod_arg[e_map_map];
-			return CMP_node_match(map1->map_node, map2->map_node);
-		}
-
-	case nod_agg_average:
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_total:
-	case nod_agg_count:
-		return CMP_node_match(node1->nod_arg[e_stt_value], node2->nod_arg[e_stt_value]);
-
-	case nod_function:
-		if (node1->nod_arg[e_fun_function] != node2->nod_arg[e_fun_function])
-			return false;
-		return CMP_node_match(node1->nod_arg[e_fun_args], node2->nod_arg[e_fun_args]);
-	}
-
-	const qli_nod* const* ptr1 = node1->nod_arg;
-	const qli_nod* const* ptr2 = node2->nod_arg;
-
-	for (const qli_nod* const* const end = ptr1 + node1->nod_count; ptr1 < end; ++ptr1, ++ptr2)
-	{
-		if (!CMP_node_match(*ptr1, *ptr2))
-			return false;
-	}
-
-	return true;
-}
-
-
-static qli_nod* compile_any( qli_nod* node, qli_req* old_request)
-{
-/**************************************
- *
- *	c o m p i l e _ a n y
- *
- **************************************
- *
- * Functional description
- *	Compile either an ANY or UNIQUE boolean expression.
- *
- **************************************/
-	qli_msg* old_send = NULL;
-	qli_msg* old_receive = NULL;
-
-	if (old_request)
-	{
-		old_send = old_request->req_send;
-		old_receive = old_request->req_receive;
-	}
-
-    qli_msg* send;
-	qli_msg* receive;
-	qli_req* request = compile_rse(node->nod_arg[e_any_rse], old_request, false, &send, &receive, 0);
-	if (request)
-		node->nod_arg[e_any_request] = (qli_nod*) request;
-	else
-		request = old_request;
-
-	if (old_request)
-	{
-		old_request->req_send = old_send;
-		old_request->req_receive = old_receive;
-	}
-
-	if ((send != old_send) && !send->msg_parameters)
-	{
-		release_message(send);
-		send = NULL;
-		if (!receive)
-			return NULL;
-	}
-
-	if (old_request && request->req_database != old_request->req_database)
-		IBERROR(357);			// Msg357 relations from multiple databases in single rse
-
-	if (old_request && (!receive || !receive->msg_parameters))
-	{
-		if (receive)
-			release_message(receive);
-		receive = NULL;
-	}
-
-	if (receive)
-	{
-		qli_par* parameter = make_parameter(receive, 0);
-		node->nod_import = parameter;
-		parameter->par_desc.dsc_dtype = dtype_short;
-		parameter->par_desc.dsc_length = sizeof(SSHORT);
-	}
-
-	node->nod_arg[e_any_send] = (qli_nod*) send;
-	node->nod_arg[e_any_receive] = (qli_nod*) receive;
-
-	return node;
-}
-
-
-static qli_nod* compile_assignment( qli_nod* node, qli_req* request, bool statement_internal)
-{
-/**************************************
- *
- *	c o m p i l e _ a s s i g n m e n t
- *
- **************************************
- *
- * Functional description:
- *	Compile an assignment statement, passing
- *	it to the database if possible.  Possibility
- *	happens when both sides of the assignment are
- *	computable in the request context.  (Following
- *	the logic of such things, the 'internal' flags
- *	mean external to qli, but internal to jrd.
- *	As is well known, the seat of the soul is the
- *	dbms).
- *
- **************************************/
-
-	// Start by assuming that the assignment will ultimately
-	// take place in the DBMS
-
-	qli_nod* to = node->nod_arg[e_asn_to];
-	to->nod_flags |= NOD_parameter2;
-	qli_nod* from = node->nod_arg[e_asn_from];
-	from->nod_flags |= NOD_parameter2;
-
-	// If the assignment is to a variable, the assignment is completely local
-
-	if (to->nod_type == nod_variable)
-	{
-		statement_internal = false;
-		node->nod_flags |= NOD_local;
-	}
-
-	const bool target_internal = computable(to, request);
-	statement_internal = statement_internal && request && target_internal && computable(from, request);
-
-	qli_nod* target = compile_expression(to, request, target_internal);
-	node->nod_arg[e_asn_to] = target;
-	node->nod_arg[e_asn_from] = compile_expression(from, request, statement_internal);
-	qli_nod* initial = node->nod_arg[e_asn_initial];
-	if (initial)
-		node->nod_arg[e_asn_initial] = compile_expression(initial, request, false);
-
-	if (statement_internal)
-	{
-		node->nod_arg[e_asn_valid] = NULL;	// Memory reclaimed in the main loop
-		node->nod_flags |= NOD_remote;
-		node = NULL;
-	}
-	else
-	{
-		if (node->nod_arg[e_asn_valid])
-			compile_expression(node->nod_arg[e_asn_valid], request, false);
-		if (target->nod_type == nod_field)
-		{
-			if (!request)
-			{
-				qli_ctx* context = (qli_ctx*) target->nod_arg[e_fld_context];
-				request = context->ctx_request;
-			}
-			target->nod_arg[e_fld_reference] = make_reference(target, request->req_send);
-		}
-	}
-
-	return node;
-}
-
-
-static void compile_context( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ c o n t e x t
- *
- **************************************
- *
- * Functional description
- *	Set all of the contexts in a request.
- *	This may require a recursive call.
- *
- **************************************/
-	qli_ctx** ctx_ptr = (qli_ctx**) node->nod_arg + e_rse_count;
-	const qli_ctx* const* const ctx_end = ctx_ptr + node->nod_count;
-
-	for (; ctx_ptr < ctx_end; ctx_ptr++)
-	{
-		qli_ctx* context = *ctx_ptr;
-		context->ctx_request = request;
-		context->ctx_context = request->req_context++;
-		context->ctx_message = request->req_receive;
-		if (context->ctx_sub_rse)
-			compile_rse(context->ctx_sub_rse, request, internal_flag, 0, 0, 0);
-		if (context->ctx_stream)
-			compile_context(context->ctx_stream, request, internal_flag);
-	}
-}
-
-
-static void compile_control_break( qli_brk* control, qli_req* request)
-{
-/**************************************
- *
- *	c o m p i l e _ c o n t r o l _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Compile a control/page/report break.
- *
- **************************************/
-	for (; control; control = control->brk_next)
-	{
-		report_control_break = control;
-		if (control->brk_field)
-		{
-			// control->brk_field  = (qli_syntax*) compile_expression (control->brk_field, request, false);
-			qli_nod* temp = (qli_nod*) control->brk_field;
-			temp->nod_flags |= NOD_parameter2;
-			temp =  compile_expression((qli_nod*) control->brk_field, request, false);
-			if (temp->nod_type == nod_field)
-				temp = temp->nod_arg[e_fld_reference];
-			control->brk_field = (qli_syntax*) temp;
-		}
-		if (control->brk_line)
-			compile_print_list((qli_nod*) control->brk_line, request, 0);
-		report_control_break = NULL;
-	}
-}
-
-
-static qli_nod* compile_edit( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	c o m p i l e _ e d i t
- *
- **************************************
- *
- * Functional description
- *	Compile the "edit blob" expression.
- *
- **************************************/
-
-	// Make sure there is a message.  If there isn't a message, we
-	// can't find the target database.
-
-	if (!request)
-		ERRQ_bugcheck(358);			// Msg358 can't find database for blob edit
-
-	// If there is an input blob, get it now.
-
-	qli_nod* value = node->nod_arg[e_edt_input];
-	if (value)
-	{
-		qli_fld* field = (qli_fld*) value->nod_arg[e_fld_field];
-		if (value->nod_type != nod_field || field->fld_dtype != dtype_blob)
-			IBERROR(356);		// Msg356 EDIT argument must be a blob field
-		node->nod_arg[e_edt_input] = compile_expression(value, request, false);
-	}
-
-	node->nod_arg[e_edt_dbb] = (qli_nod*) request->req_database;
-	node->nod_desc.dsc_dtype = dtype_blob;
-	node->nod_desc.dsc_length = 8;
-	node->nod_desc.dsc_address = (UCHAR*) &node->nod_arg[e_edt_id1];
-	QLI_validate_desc(node->nod_desc);
-
-	return node;
-}
-
-
-static qli_nod* compile_erase( qli_nod* node, qli_req* org_request)
-{
-/**************************************
- *
- *	c o m p i l e _ e r a s e
- *
- **************************************
- *
- * Functional description
- *	Compile an ERASE statement.  This is so simple that nothing
- *	needs to be done.
- *
- **************************************/
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_era_context];
-	qli_req* request = context->ctx_request;
-	node->nod_arg[e_era_request] = (qli_nod*) request;
-
-	request->req_database->dbb_flags |= DBB_updates;
-
-	if (org_request == request && !request->req_continue)
-		return NULL;
-
-	if (!request->req_continue)
-		request->req_continue = make_message(request);
-
-	node->nod_arg[e_era_message] = (qli_nod*) make_message(request);
-
-	return node;
-}
-
-
-static qli_nod* compile_expression( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ e x p r e s s i o n
- *
- **************************************
- *
- * Functional description
- *	Compile a value.  The value may be used internally as part of
- *	another expression (internal_flag == true) or may be referenced
- *	in the QLI context (internal_flag == false).
- *
- **************************************/
-	qli_nod** ptr;
-	const qli_nod* const* end;
-	qli_nod* value;
-	qli_map* map;
-	qli_fld* field;
-
-	switch (node->nod_type)
-	{
-	case nod_any:
-	case nod_unique:
-		return compile_any(node, request);
-
-	case nod_max:
-	case nod_min:
-	case nod_count:
-	case nod_average:
-	case nod_total:
-	case nod_from:
-		node->nod_count = 0;
-		return compile_statistical(node, request, internal_flag);
-
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_count:
-	case nod_rpt_average:
-	case nod_rpt_total:
-		if (report_control_break)
-			ALLQ_push((blk*) node, &report_control_break->brk_statisticals);
-
-	case nod_running_total:
-	case nod_running_count:
-		node->nod_count = 0;
-		if (value = node->nod_arg[e_stt_value])
-		{
-			value->nod_flags |= NOD_parameter2;
-			node->nod_arg[e_stt_value] = compile_expression(value, request, false);
-		}
-		make_descriptor(node, &node->nod_desc);
-		if (internal_flag)
-		{
-			qli_par* parm = make_parameter(request->req_send, 0);
-			node->nod_export = parm;
-			parm->par_desc = node->nod_desc;
-			parm->par_value = node;
-		}
-		else
-		{
-			CMP_alloc_temp(node);
-			if (request && value && computable(value, request))
-				node->nod_arg[e_stt_value] = make_reference(value, request->req_receive);
-		}
-		return node;
-
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_count:
-	case nod_agg_average:
-	case nod_agg_total:
-		node->nod_count = 0;
-		if (value = node->nod_arg[e_stt_value])
-		{
-			value->nod_flags |= NOD_parameter2;
-			node->nod_arg[e_stt_value] = compile_expression(value, request, true);
-		}
-		make_descriptor(node, &node->nod_desc);
-		if (!internal_flag && request)
-			return make_reference(node, request->req_receive);
-		return node;
-
-	case nod_map:
-		map = (qli_map*) node->nod_arg[e_map_map];
-		map->map_node = value = compile_expression(map->map_node, request, true);
-		make_descriptor(value, &node->nod_desc);
-		if (!internal_flag && request)
-			return make_reference(node, request->req_receive);
-		return node;
-
-	case nod_function:
-		return compile_function(node, request, internal_flag);
-
-	case nod_eql:
-	case nod_neq:
-	case nod_gtr:
-	case nod_geq:
-	case nod_leq:
-	case nod_lss:
-	case nod_between:
-		node->nod_flags |= nod_comparison;
-
-	case nod_list:
-	case nod_matches:
-	case nod_sleuth:
-	case nod_like:
-	case nod_containing:
-	case nod_starts:
-	case nod_missing:
-	case nod_and:
-	case nod_or:
-	case nod_not:
-		for (ptr = node->nod_arg, end = ptr + node->nod_count; ptr < end; ptr++)
-		{
-			(*ptr)->nod_flags |= NOD_parameter2;
-			*ptr = compile_expression(*ptr, request, internal_flag);
-		}
-		if (node->nod_type == nod_and || node->nod_type == nod_or)
-			node->nod_flags |= nod_partial;
-		return node;
-
-	case nod_null:
-	case nod_add:
-	case nod_subtract:
-	case nod_multiply:
-	case nod_divide:
-	case nod_negate:
-	case nod_concatenate:
-	case nod_substr:
-	case nod_user_name:
-		if (!internal_flag && request && request->req_receive && computable(node, request))
-		{
-			compile_expression(node, request, true);
-			return make_reference(node, request->req_receive);
-		}
-		for (ptr = node->nod_arg, end = ptr + node->nod_count; ptr < end; ptr++)
-		{
-			(*ptr)->nod_flags |= NOD_parameter2;
-			*ptr = compile_expression(*ptr, request, internal_flag);
-		}
-		make_descriptor(node, &node->nod_desc);
-		if (!internal_flag)
-		{
-			node->nod_flags |= NOD_local;
-			CMP_alloc_temp(node);
-		}
-		return node;
-
-	case nod_format:
-		value = node->nod_arg[e_fmt_value];
-		node->nod_arg[e_fmt_value] = compile_expression(value, request, false);
-		node->nod_desc.dsc_length = FMT_expression(node);
-		node->nod_desc.dsc_dtype = dtype_text;
-		CMP_alloc_temp(node);
-		if (!internal_flag)
-			node->nod_flags |= NOD_local;
-		return node;
-
-	case nod_constant:
-		if (!internal_flag)
-			node->nod_flags |= NOD_local;
-		return node;
-
-	case nod_edit_blob:
-		compile_edit(node, request);
-		return node;
-
-	case nod_prompt:
-		node->nod_count = 0;
-		compile_prompt(node);
-		if (internal_flag)
-		{
-			qli_par* parm = make_parameter(request->req_send, node);
-			node->nod_export = parm;
-			parm->par_value = node;
-			if (field = (qli_fld*) node->nod_arg[e_prm_field])
-			{
-				parm->par_desc.dsc_dtype = field->fld_dtype;
-				parm->par_desc.dsc_length = field->fld_length;
-				parm->par_desc.dsc_scale = field->fld_scale;
-				parm->par_desc.dsc_sub_type = field->fld_sub_type;
-				if (parm->par_desc.dsc_dtype == dtype_text)
-				{
-					parm->par_desc.dsc_dtype = dtype_varying;
-					parm->par_desc.dsc_length += sizeof(SSHORT);
-				}
-			}
-			else
-				parm->par_desc = node->nod_desc;
-		}
-		return node;
-
-	case nod_field:
-		if (value = node->nod_arg[e_fld_subs])
-			compile_expression(value, request, true);
-		return compile_field(node, request, internal_flag);
-
-	case nod_variable:
-		field = (qli_fld*) node->nod_arg[e_fld_field];
-		node->nod_desc.dsc_address = field->fld_data;
-		QLI_validate_desc(node->nod_desc);
-		make_descriptor(node, &node->nod_desc);
-		if (internal_flag)
-		{
-			qli_par* parm = make_parameter(request->req_send, node);
-			node->nod_export = parm;
-			parm->par_value = node;
-			parm->par_desc = node->nod_desc;
-		}
-		return node;
-
-	case nod_upcase:
-	case nod_lowcase:
-		value = node->nod_arg[0];
-		node->nod_arg[0] = compile_field(value, request, internal_flag);
-		return node;
-
-	default:
-		ERRQ_bugcheck(359);			// Msg359 compile_expression: not yet implemented
-		return NULL;
-	}
-}
-
-
-static qli_nod* compile_field( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Compile a field reference.
- *
- **************************************/
-
-	// Pick up field characteristics
-
-	node->nod_count = 0;
-	qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_fld_context];
-	if ((field->fld_flags & FLD_array) && !node->nod_arg[e_fld_subs])
-	{
-		node->nod_desc.dsc_dtype = dtype_quad;
-		node->nod_desc.dsc_length = 8;
-		node->nod_desc.dsc_scale = 0;
-		node->nod_desc.dsc_sub_type = 0;
-	}
-	else
-	{
-		node->nod_desc.dsc_dtype = field->fld_dtype;
-		node->nod_desc.dsc_length = field->fld_length;
-		node->nod_desc.dsc_scale = field->fld_scale;
-		node->nod_desc.dsc_sub_type = field->fld_sub_type;
-	}
-	node->nod_flags |= NOD_parameter2;
-
-	// If the reference is external, or the value is computable in the
-	// current request, there is nothing to do.  If the value is not computable,
-	// make up a parameter to send the value into the request.
-
-	if (internal_flag)
-	{
-		if (computable(node, request))
-			return node;
-
-		qli_par* parm = make_parameter(request->req_send, node);
-		node->nod_export = parm;
-		parm->par_desc = node->nod_desc;
-		parm->par_value = node;
-		qli_msg* message = context->ctx_message;
-		if (!message)
-			message = request->req_receive;
-		node->nod_arg[e_fld_reference] = make_reference(node, message);
-		return node;
-	}
-
-	qli_msg* message = context->ctx_message;
-	if (!message && request)
-		message = request->req_receive;
-
-	node->nod_arg[e_fld_reference] = make_reference(node, message);
-	return node;
-}
-
-
-static qli_nod* compile_for( qli_nod* node, qli_req* old_request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ f o r
- *
- **************************************
- *
- * Functional description
- *	Compile a FOR loop.  If the loop can be done as part of the parent
- *	request, dandy.
- *
- **************************************/
-
-	// Compile rse.  This will set up both send and receive message.  If the
-	// messages aren't needed, we can release them later.
-
-	qli_msg* old_send = NULL;
-	qli_msg* old_receive = NULL;
-	if (old_request)
-	{
-		old_send = old_request->req_send;
-		old_receive = old_request->req_receive;
-	}
-
-	qli_msg* send;
-	qli_msg* receive;
-	qli_req* request = compile_rse(node->nod_arg[e_for_rse], old_request, false, &send, &receive, 0);
-	if (request)
-		node->nod_arg[e_for_request] = (qli_nod*) request;
-	else
-		request = old_request;
-
-	// If nothing is required for sub-statement, and no data is required in
-	// either direction, we don't need  to execute the statement.
-
-	if (!compile_statement(node->nod_arg[e_for_statement], request, internal_flag) &&
-		 !receive->msg_parameters)
-	{
-		release_message(receive);
-		receive = NULL;
-	}
-
-	if (old_request)
-	{
-		old_request->req_send = old_send;
-		old_request->req_receive = old_receive;
-	}
-
-	if ((send != old_send) && !send->msg_parameters)
-	{
-		release_message(send);
-		send = NULL;
-		if (!receive)
-			return NULL;
-	}
-
-	if (receive)
-	{
-		qli_par* parameter = make_parameter(receive, 0);
-		node->nod_arg[e_for_eof] = (qli_nod*) parameter;
-		parameter->par_desc.dsc_dtype = dtype_short;
-		parameter->par_desc.dsc_length = sizeof(SSHORT);
-	}
-
-	node->nod_arg[e_for_send] = (qli_nod*) send;
-	node->nod_arg[e_for_receive] = (qli_nod*) receive;
-
-	return node;
-}
-
-
-static qli_nod* compile_function( qli_nod* node, qli_req* old_request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	Compile a database function reference.
- *
- **************************************/
-	qli_msg* old_send = NULL;
-	qli_msg* old_receive = NULL;
-
-	qli_fun* function = (qli_fun*) node->nod_arg[e_fun_function];
-	node->nod_count = 0;
-	qli_msg* send = NULL;
-
-	if (!internal_flag)
-		old_request = NULL;
-
-	if (old_request)
-	{
-		old_send = old_request->req_send;
-		old_receive = old_request->req_receive;
-	}
-
-	qli_req* request;
-	qli_msg* receive = 0;
-	if (!old_request || old_request->req_database != function->fun_database)
-	{
-		request = make_request(function->fun_database);
-		node->nod_arg[e_fun_request] = (qli_nod*) request;
-		request->req_send = send = make_message(request);
-		request->req_receive = receive = make_message(request);
-	}
-	else
-		request = old_request;
-
-	// If there is a value, compile it here
-
-	qli_par* parameter = 0;
-	if (!internal_flag)
-	{
-		node->nod_import = parameter = make_parameter(request->req_receive, 0);
-		make_descriptor(node, &parameter->par_desc);
-	}
-
-	qli_nod* list = node->nod_arg[e_fun_args];
-
-	qli_nod** ptr = list->nod_arg;
-	for (const qli_nod* const* const end = ptr + list->nod_count; ptr < end; ptr++)
-		compile_expression(*ptr, request, true);
-
-	if (old_request)
-	{
-		old_request->req_send = old_send;
-		old_request->req_receive = old_receive;
-	}
-
-	if (!internal_flag && request == old_request && computable(node, request))
-	{
-		make_descriptor(node, &node->nod_desc);
-		return make_reference(node, request->req_receive);
-	}
-
-	if (send && (send != old_send) && !send->msg_parameters)
-	{
-		release_message(send);
-		send = NULL;
-	}
-
-	node->nod_arg[e_fun_receive] = (qli_nod*) receive;
-	node->nod_arg[e_fun_send] = (qli_nod*) send;
-
-	return node;
-}
-
-
-static qli_nod* compile_if( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ i f
- *
- **************************************
- *
- * Functional description
- *	Compile an IF statement.  Determine whether the
- *	statement is going to be executed in QLI or database
- *	context.  Try to make sure that the whole thing is
- *	executed one place or the other.
- *
- **************************************/
-
-	// If the statement can't be executed in database context,
-	// make sure it gets executed locally
-
-	if (!internal_flag || !computable(node, request))
-	{
-		internal_flag = false;
-		node->nod_flags |= NOD_local;
-		request = NULL;
-	}
-
-	qli_nod* sub = node->nod_arg[e_if_boolean];
-	compile_expression(sub, request, internal_flag);
-	compile_statement(node->nod_arg[e_if_true], request, internal_flag);
-
-	if (sub = node->nod_arg[e_if_false])
-		compile_statement(sub, request, internal_flag);
-
-	if (internal_flag)
-		return NULL;
-
-	return node;
-}
-
-
-static qli_nod* compile_list_fields( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	c o m p i l e _ l i s t _ f i e l d s
- *
- **************************************
- *
- * Functional description
- *	Compile a print node.
- *
- **************************************/
-	qli_nod* list = node->nod_arg[e_prt_list];
-	compile_print_list(list, request, 0);
-	node->nod_arg[e_prt_list] = FMT_list(list);
-	node->nod_type = nod_print;
-
-	return node;
-}
-
-
-static qli_nod* compile_modify( qli_nod* node, qli_req* org_request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ m o d i f y
- *
- **************************************
- *
- * Functional description
- *	Compile a modify statement.
- *
- **************************************/
-
-	// If this is a different request from the current one, this will require an
-	// optional action and a "continue" message
-
-	qli_nod** ptr = node->nod_arg + e_mod_count;
-	qli_ctx* context = (qli_ctx*) *ptr;
-	qli_req* request = context->ctx_source->ctx_request;
-	node->nod_arg[e_mod_request] = (qli_nod*) request;
-
-	if ((request != org_request || !internal_flag) && !request->req_continue)
-		request->req_continue = make_message(request);
-
-	qli_msg* old_send = request->req_send;
-	qli_msg* send = make_message(request);
-	request->req_send = send;
-
-	for (USHORT i = 0; i < node->nod_count; i++)
-	{
-		context = (qli_ctx*) * ptr++;
-		context->ctx_request = request;
-		context->ctx_context = request->req_context++;
-		context->ctx_message = send;
-	}
-
-	// If nothing is required for sub-statement, and no data is required in
-	// either direction, we don't need  to execute the statement.
-
-	if (internal_flag)
-		internal_flag = computable(node->nod_arg[e_mod_statement], request);
-
-	if (!compile_statement(node->nod_arg[e_mod_statement], request, internal_flag) &&
-		(send != old_send) && !send->msg_parameters)
-	{
-		node->nod_flags |= NOD_remote;
-		release_message(send);
-		send = NULL;
-	}
-
-	node->nod_arg[e_mod_send] = (qli_nod*) send;
-	request->req_send = old_send;
-	request->req_database->dbb_flags |= DBB_updates;
-
-	if (internal_flag)
-		return NULL;
-
-	return node;
-}
-
-
-static qli_nod* compile_print( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	c o m p i l e _ p r i n t
- *
- **************************************
- *
- * Functional description
- *	Compile a print node.
- *
- **************************************/
-
-	if (!print_header)
-		print_header = (TEXT**) & node->nod_arg[e_prt_header];
-
-	compile_print_list(node->nod_arg[e_prt_list], request, &print_items);
-
-	return node;
-}
-
-
-static qli_nod* compile_print_list( qli_nod* list, qli_req* request, qli_lls** stack)
-{
-/**************************************
- *
- *	c o m p i l e _ p r i n t _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Compile a print node.
- *
- **************************************/
-	qli_nod** ptr = list->nod_arg;
-	for (const qli_nod* const* const end = ptr + list->nod_count; ptr < end; ptr++)
-	{
-		qli_print_item* item = (qli_print_item*) *ptr;
-		if (stack)
-			ALLQ_push((blk*) item, stack);
-		if (item->itm_type == item_value)
-		{
-			qli_nod* value = item->itm_value;
-			value->nod_flags |= NOD_parameter2;
-			item->itm_value = compile_expression(value, request, false);
-			if (item->itm_value->nod_type == nod_field)
-				item->itm_value = item->itm_value->nod_arg[e_fld_reference];
-			if (!value->nod_desc.dsc_dtype)
-				make_descriptor(value, &value->nod_desc);
-		}
-	}
-
-	return list;
-}
-
-
-static qli_nod* compile_prompt( qli_nod* node)
-{
-/**************************************
- *
- *	c o m p i l e _ p r o m p t
- *
- **************************************
- *
- * Functional description
- *	Set up a prompt expression for execution.
- *
- **************************************/
-	USHORT prompt_length;
-
-	// Make up a plausible prompt length
-
-	qli_fld* field = (qli_fld*) node->nod_arg[e_prm_field];
-	if (!field)
-		prompt_length = PROMPT_LENGTH;
-	else
-	{
-		switch (field->fld_dtype)
-		{
-		case dtype_text:
-			prompt_length = field->fld_length;
-			break;
-
-		case dtype_varying:
-			prompt_length = field->fld_length - sizeof(SSHORT);
-			break;
-
-		case dtype_short:
-			prompt_length = 8;
-			break;
-
-
-		case dtype_long:
-		case dtype_real:
-			prompt_length = 15;
-			break;
-
-		default:
-			prompt_length = 30;
-			break;
-		}
-	}
-
-	// Allocate string buffer to hold data, a two byte count,
-	// a possible carriage return, and a null
-
-	fb_assert(prompt_length <= MAX_USHORT - 2 - sizeof(SSHORT));
-	prompt_length += 2 + sizeof(SSHORT);
-	qli_str* string = (qli_str*) ALLOCDV(type_str, prompt_length);
-	node->nod_arg[e_prm_string] = (qli_nod*) string;
-	node->nod_desc.dsc_dtype = dtype_varying;
-	node->nod_desc.dsc_length = prompt_length;
-	node->nod_desc.dsc_address = (UCHAR*) string->str_data;
-	QLI_validate_desc(node->nod_desc);
-
-	return node;
-}
-
-
-static qli_nod* compile_repeat( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ r e p e a t
- *
- **************************************
- *
- * Functional description
- *	Compile a REPEAT statement.
- *
- **************************************/
-
-	compile_expression(node->nod_arg[e_rpt_value], request, false);
-	compile_statement(node->nod_arg[e_rpt_statement], 0, internal_flag);
-
-	return node;
-}
-
-
-static qli_nod* compile_report( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	c o m p i l e _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Compile the body of a report specification.
- *
- **************************************/
-	qli_brk* control;
-
-	qli_rpt* report = (qli_rpt*) node->nod_arg[e_prt_list];
-
-	if (control = report->rpt_top_rpt)
-		compile_control_break(control, request);
-
-	if (control = report->rpt_top_page)
-		compile_control_break(control, request);
-
-	if (control = report->rpt_top_breaks)
-		compile_control_break(control, request);
-
-	qli_nod* list = report->rpt_detail_line;
-	if (list)
-		compile_print_list(list, request, 0);
-
-	if (control = report->rpt_bottom_breaks)
-	{
-		compile_control_break(control, request);
-		report->rpt_bottom_breaks = NULL;
-		while (control)
-		{
-			qli_brk* temp = control;
-			control = control->brk_next;
-			temp->brk_next = report->rpt_bottom_breaks;
-			report->rpt_bottom_breaks = temp;
-		}
-	}
-
-	if (control = report->rpt_bottom_page)
-		compile_control_break(control, request);
-
-	if (control = report->rpt_bottom_rpt)
-		compile_control_break(control, request);
-
-	FMT_report(report);
-
-	return node;
-}
-
-
-static qli_req* compile_rse(qli_nod* node, qli_req* old_request, bool internal_flag,
-							qli_msg** send, qli_msg** receive, qli_dbb** database)
-{
-/**************************************
- *
- *	c o m p i l e _ r s e
- *
- **************************************
- *
- * Functional description
- *	Compile a record selection expression.  If it can't be processed
- *	as part of an existing parent request, make up a new request.  If
- *	data must be sent to start the loop, generate a send message.  Set
- *	up for a receive message as well.
- *
- **************************************/
-	qli_req* request;
-	qli_dbb* local_dbb;
-
-	qli_req* const original_request = old_request;
-
-	if (!database)
-	{
-		local_dbb = NULL;
-		database = &local_dbb;
-	}
-
-	// Loop thru relations to make sure only a single database is presented
-
-	qli_ctx** ctx_ptr = (qli_ctx**) node->nod_arg + e_rse_count;
-	const qli_ctx* const* const ctx_end = ctx_ptr + node->nod_count;
-
-	for (; ctx_ptr < ctx_end; ctx_ptr++)
-	{
-		qli_ctx* context = *ctx_ptr;
-		if (context->ctx_stream)
-		{
-			if (request = compile_rse(context->ctx_stream, old_request, internal_flag,
-										send, receive, database))
-			{
-				old_request = request;
-			}
-		}
-		else
-		{
-			qli_rel* relation = context->ctx_relation;
-			if (!*database)
-				*database = relation->rel_database;
-			else if (*database != relation->rel_database)
-				IBERROR(357);	// Msg357 relations from multiple databases in single rse
-		}
-	}
-
-	if (!old_request || old_request->req_database != *database)
-		request = make_request(*database);
-	else
-		request = old_request;
-
-	if (send)
-	{
-		if (old_request && request == old_request && !(old_request->req_flags & REQ_rse_compiled))
-			*send = request->req_send;
-		else
-			request->req_send = *send = make_message(request);
-		request->req_receive = *receive = make_message(request);
-	}
-
-	compile_context(node, request, internal_flag);
-
-	// Process various clauses
-
-	if (node->nod_arg[e_rse_first])
-		compile_expression(node->nod_arg[e_rse_first], request, true);
-
-	if (node->nod_arg[e_rse_boolean])
-		compile_expression(node->nod_arg[e_rse_boolean], request, true);
-
-	qli_nod** ptr;
-	const qli_nod* const* end;
-	qli_nod* list;
-	if (list = node->nod_arg[e_rse_sort])
-		for (ptr = list->nod_arg, end = ptr + list->nod_count * 2; ptr < end; ptr += 2)
-		{
-			compile_expression(*ptr, request, true);
-		}
-
-	if (list = node->nod_arg[e_rse_reduced])
-		for (ptr = list->nod_arg, end = ptr + list->nod_count * 2; ptr < end; ptr += 2)
-		{
-			compile_expression(*ptr, request, true);
-		}
-
-	if (list = node->nod_arg[e_rse_group_by])
-		for (ptr = list->nod_arg, end = ptr + list->nod_count; ptr < end; ptr++)
-		{
-			compile_expression(*ptr, request, true);
-		}
-
-	if (node->nod_arg[e_rse_having])
-		compile_expression(node->nod_arg[e_rse_having], request, true);
-
-	// If we didn't allocate a new request block, say so by returning NULL
-
-	if (request == original_request)
-		return NULL;
-
-	request->req_flags |= REQ_rse_compiled;
-
-	return request;
-}
-
-
-static qli_nod* compile_statement( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ s t a t e m e n t
- *
- **************************************
- *
- * Functional description
- *	Compile a statement.  Actually, just dispatch, passing along
- *	the parent request.
- *
- **************************************/
-	switch (node->nod_type)
-	{
-	case nod_assign:
-		return compile_assignment(node, request, internal_flag);
-
-	case nod_erase:
-		return compile_erase(node, request);
-
-	case nod_commit_retaining:
-		return node;
-
-	case nod_for:
-	case nod_report_loop:
-		return compile_for(node, request, internal_flag);
-
-	case nod_list:
-		{
-			qli_nod* result = NULL;
-			qli_nod** ptr = node->nod_arg;
-			for (const qli_nod* const* const end = ptr + node->nod_count; ptr < end; ptr++)
-			{
-				if (compile_statement(*ptr, request, internal_flag))
-					result = node;
-			}
-			return result;
-		}
-
-	case nod_modify:
-		return compile_modify(node, request, internal_flag);
-
-	case nod_output:
-		compile_expression(node->nod_arg[e_out_file], request, false);
-		compile_statement(node->nod_arg[e_out_statement], request, false);
-		return node;
-
-	case nod_print:
-		return compile_print(node, request);
-
-	case nod_list_fields:
-		return compile_list_fields(node, request);
-
-	case nod_repeat:
-		return compile_repeat(node, request, internal_flag);
-
-	case nod_report:
-		return compile_report(node, request);
-
-	case nod_store:
-		return compile_store(node, request, internal_flag);
-
-	case nod_if:
-		return compile_if(node, request, internal_flag);
-
-	case nod_abort:
-		if (node->nod_count)
-			compile_expression(node->nod_arg[0], 0, false);
-		return node;
-
-	default:
-		ERRQ_bugcheck(360);			// Msg360 not yet implemented (compile_statement)
-		return NULL;
-	}
-}
-
-
-static qli_nod* compile_statistical( qli_nod* node, qli_req* old_request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ s t a t i s t i c a l
- *
- **************************************
- *
- * Functional description
- *	Compile a statistical expression.  The expression may or may not
- *	request a separate request.
- *
- **************************************/
-	qli_msg* old_send = NULL;
-	qli_msg* old_receive = NULL;
-
-	// If a default value is present, compile it outside the context of the rse.
-
-	qli_nod* value = node->nod_arg[e_stt_default];
-	if (value)
-		compile_expression(value, old_request, true);
-
-	// Compile rse.  This will set up both send and receive message.  If the
-	// messages aren't needed, we can release them later.
-
-	if (!internal_flag)
-		old_request = NULL;
-
-	if (old_request)
-	{
-		old_send = old_request->req_send;
-		old_receive = old_request->req_receive;
-	}
-
-	qli_msg* send;
-	qli_msg* receive;
-	qli_req* request = compile_rse(node->nod_arg[e_stt_rse],
-								   old_request, internal_flag, &send, &receive, 0);
-	if (request) {
-		node->nod_arg[e_stt_request] = (qli_nod*) request;
-	}
-	else
-		request = old_request;
-
-	// If there is a value, compile it here
-
-	if (!internal_flag)
-	{
-		qli_par* parameter = make_parameter(request->req_receive, 0);
-		node->nod_import = parameter;
-		make_descriptor(node, &parameter->par_desc);
-	}
-
-	value = node->nod_arg[e_stt_value];
-	if (value)
-		compile_expression(value, request, true);
-
-	if (old_request)
-	{
-		old_request->req_send = old_send;
-		old_request->req_receive = old_receive;
-	}
-
-	if (!internal_flag && request == old_request && computable(node, request))
-	{
-		make_descriptor(node, &node->nod_desc);
-		return make_reference(node, request->req_receive);
-	}
-
-	if ((send != old_send) && !send->msg_parameters)
-	{
-		release_message(send);
-		send = NULL;
-	}
-
-	node->nod_arg[e_stt_receive] = (qli_nod*) receive;
-	node->nod_arg[e_stt_send] = (qli_nod*) send;
-
-	return node;
-}
-
-
-static qli_nod* compile_store( qli_nod* node, qli_req* request, bool internal_flag)
-{
-/**************************************
- *
- *	c o m p i l e _ s t o r e
- *
- **************************************
- *
- * Functional description
- *	Compile a STORE statement.
- *
- **************************************/
-	// Find or make up request for statement
-
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_sto_context];
-	qli_rel* relation = context->ctx_relation;
-
-	if (!request || request->req_database != relation->rel_database)
-	{
-		request = make_request(relation->rel_database);
-		node->nod_arg[e_sto_request] = (qli_nod*) request;
-	}
-
-	request->req_database->dbb_flags |= DBB_updates;
-
-	context->ctx_request = request;
-	context->ctx_context = request->req_context++;
-	qli_msg* send = make_message(request);
-	context->ctx_message = request->req_send = send;
-
-	// If nothing is required for sub-statement, and no data is required in
-	// either direction, we don't need to execute the statement.
-
-	if (internal_flag)
-		internal_flag = computable(node->nod_arg[e_sto_statement], request);
-
-	if (!compile_statement(node->nod_arg[e_sto_statement], request, internal_flag) &&
-		!send->msg_parameters)
-	{
-		node->nod_flags |= NOD_remote;
-		release_message(send);
-		return NULL;
-	}
-
-	node->nod_arg[e_sto_send] = (qli_nod*) send;
-
-	return node;
-}
-
-
-static bool computable( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	c o m p u t a b l e
- *
- **************************************
- *
- * Functional description
- *	Check to see if a value is computable within the context of a
- *	given request.
- *
- **************************************/
-	qli_nod** ptr;
-	const qli_nod* const* end;
-	qli_nod* sub;
-	qli_ctx* context;
-	qli_map* map;
-
-	switch (node->nod_type)
-	{
-	case nod_max:
-	case nod_min:
-	case nod_count:
-	case nod_average:
-	case nod_total:
-	case nod_from:
-		if ((sub = node->nod_arg[e_stt_rse]) && !computable(sub, request))
-			return false;
-		if ((sub = node->nod_arg[e_stt_value]) && !computable(sub, request))
-			return false;
-		if ((sub = node->nod_arg[e_stt_default]) && !computable(sub, request))
-			return false;
-		return true;
-
-	case nod_rse:
-		if (!request)
-			return false;
-		if ((sub = node->nod_arg[e_rse_first]) && !computable(sub, request))
-			return false;
-		for (ptr = node->nod_arg + e_rse_count, end = ptr + node->nod_count; ptr < end; ptr++)
-		{
-			context = (qli_ctx*) * ptr;
-			if (context->ctx_stream)
-			{
-				if (!computable(context->ctx_stream, request))
-					return false;
-			}
-			else if (context->ctx_relation->rel_database != request->req_database)
-				return false;
-
-			context->ctx_request = request;
-		}
-		if ((sub = node->nod_arg[e_rse_boolean]) && !computable(sub, request))
-			return false;
-		return true;
-
-	case nod_field:
-		if (sub = node->nod_arg[e_fld_subs])
-			for (ptr = sub->nod_arg, end = ptr + sub->nod_count; ptr < end;  ptr++)
-			{
-				if (*ptr && !computable(*ptr, request))
-					return false;
-			}
-		context = (qli_ctx*) node->nod_arg[e_fld_context];
-		return (request == context->ctx_request);
-
-	case nod_map:
-		map = (qli_map*) node->nod_arg[e_map_map];
-		return computable(map->map_node, request);
-
-	case nod_print:
-	case nod_report:
-	case nod_abort:
-	case nod_repeat:
-	case nod_commit_retaining:
-
-	case nod_rpt_average:
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_total:
-	case nod_rpt_count:
-	case nod_running_total:
-	case nod_running_count:
-	case nod_edit_blob:
-	case nod_prompt:
-	case nod_variable:
-	case nod_format:
-		return false;
-
-	case nod_null:
-	case nod_constant:
-	case nod_user_name:
-		return true;
-
-	case nod_for:
-		if ((qli_req*) node->nod_arg[e_for_request] != request)
-			return false;
-		if (!computable(node->nod_arg[e_for_rse], request) ||
-			!computable(node->nod_arg[e_for_statement], request))
-		{
-			return false;
-		}
-		return true;
-
-	case nod_store:
-		if ((qli_req*) node->nod_arg[e_sto_request] != request)
-			return false;
-		return computable(node->nod_arg[e_sto_statement], request);
-
-	case nod_modify:
-		context = (qli_ctx*) node->nod_arg[e_mod_count];
-		if (context->ctx_source->ctx_request != request)
-			return false;
-		return computable(node->nod_arg[e_mod_statement], request);
-
-	case nod_erase:
-		context = (qli_ctx*) node->nod_arg[e_era_context];
-		if (context->ctx_source->ctx_request != request)
-			return false;
-		return true;
-
-	case nod_unique:
-	case nod_any:
-		if (node->nod_arg[e_any_request] != (qli_nod*) request)
-			return false;
-		return (computable(node->nod_arg[e_any_rse], request));
-
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_count:
-	case nod_agg_average:
-	case nod_agg_total:
-		if (sub = node->nod_arg[e_stt_value])
-			return (computable(sub, request));
-
-	case nod_assign:
-		if (node->nod_arg[e_asn_valid])
-		{
-			sub = node->nod_arg[e_asn_from];
-			// Try to do validation in QLI as soon as the user responds to the prompt
-			if (sub->nod_type == nod_prompt)
-				return false;
-		}
-	case nod_list:
-	case nod_if:
-
-	case nod_eql:
-	case nod_neq:
-	case nod_gtr:
-	case nod_geq:
-	case nod_leq:
-	case nod_lss:
-	case nod_between:
-	case nod_matches:
-	case nod_sleuth:
-	case nod_like:
-	case nod_containing:
-	case nod_starts:
-	case nod_missing:
-	case nod_and:
-	case nod_or:
-	case nod_not:
-	case nod_add:
-	case nod_subtract:
-	case nod_multiply:
-	case nod_divide:
-	case nod_negate:
-	case nod_concatenate:
-	case nod_function:
-	case nod_substr:
-		for (ptr = node->nod_arg, end = ptr + node->nod_count; ptr < end; ptr++)
-		{
-			if (*ptr && !computable(*ptr, request))
-				return false;
-		}
-		return true;
-
-	default:
-		ERRQ_bugcheck(361);			// Msg361 computable: not yet implemented
-		return false;
-	}
-}
-
-
-static void make_descriptor( qli_nod* node, dsc* desc)
-{
-/**************************************
- *
- *	m a k e _ d e s c r i p t o r
- *
- **************************************
- *
- * Functional description
- *	Fill out a descriptor based on an expression.
- *
- **************************************/
-	USHORT dtype;
-
-	dsc desc1;
-	desc1.dsc_dtype = 0;
-	desc1.dsc_scale = 0;
-	desc1.dsc_length = 0;
-	desc1.dsc_sub_type = 0;
-	desc1.dsc_address = NULL;
-	desc1.dsc_flags = 0;
-	dsc desc2 = desc1;
-
-	switch (node->nod_type)
-	{
-	case nod_field:
-	case nod_variable:
-		{
-			const qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-			desc->dsc_dtype = field->fld_dtype;
-			desc->dsc_length = field->fld_length;
-			desc->dsc_scale = field->fld_scale;
-			desc->dsc_sub_type = field->fld_sub_type;
-		}
-		return;
-
-	case nod_reference:
-		{
-			qli_par* parameter = node->nod_import;
-			*desc = parameter->par_desc;
-		}
-		return;
-
-	case nod_map:
-		{
-			qli_map* map = (qli_map*) node->nod_arg[e_map_map];
-			make_descriptor(map->map_node, desc);
-		}
-		return;
-
-	case nod_function:
-		{
-			qli_fun* function = (qli_fun*) node->nod_arg[e_fun_function];
-			*desc = function->fun_return;
-		}
-		return;
-
-	case nod_constant:
-	case nod_prompt:
-	case nod_format:
-		*desc = node->nod_desc;
-		return;
-
-	case nod_concatenate:
-		{
-			make_descriptor(node->nod_arg[0], &desc1);
-			make_descriptor(node->nod_arg[1], &desc2);
-			desc->dsc_scale = 0;
-			desc->dsc_dtype = dtype_varying;
-			ULONG len = sizeof(USHORT) + string_length(&desc1) + string_length(&desc2);
-			if (len > MAX_USHORT) // Silent truncation for now.
-				len = MAX_USHORT;
-			desc->dsc_length = static_cast<USHORT>(len);
-			if (desc1.dsc_dtype <= dtype_any_text)
-				desc->dsc_sub_type = desc1.dsc_sub_type;
-			else
-				desc->dsc_sub_type = ttype_ascii;
-		}
-		return;
-
-	case nod_add:
-	case nod_subtract:
-		make_descriptor(node->nod_arg[0], &desc1);
-		make_descriptor(node->nod_arg[1], &desc2);
-		if ((desc1.dsc_dtype == dtype_text && desc1.dsc_length >= 9) ||
-			(desc2.dsc_dtype == dtype_text && desc2.dsc_length >= 9))
-		{
-			dtype = dtype_double;
-		}
-		else
-			dtype = MAX(desc1.dsc_dtype, desc2.dsc_dtype);
-		switch (dtype)
-		{
-		case dtype_sql_time:
-		case dtype_sql_date:
-		case dtype_timestamp:
-			node->nod_flags |= nod_date;
-			if (node->nod_type == nod_add)
-			{
-				desc->dsc_dtype = dtype;
-				desc->dsc_length = (dtype == dtype_timestamp) ? 8 : 4;
-				break;
-			}
-
-		case dtype_varying:
-		case dtype_cstring:
-		case dtype_text:
-		case dtype_double:
-		case dtype_real:
-		case dtype_long:
-			desc->dsc_dtype = dtype_double;
-			desc->dsc_length = sizeof(double);
-			break;
-
-		default:
-			desc->dsc_dtype = dtype_long;
-			desc->dsc_length = sizeof(SLONG);
-			desc->dsc_scale = MIN(desc1.dsc_scale, desc2.dsc_scale);
-			break;
-		}
-		return;
-
-	case nod_multiply:
-		make_descriptor(node->nod_arg[0], &desc1);
-		make_descriptor(node->nod_arg[1], &desc2);
-		if ((desc1.dsc_dtype == dtype_text && desc1.dsc_length >= 9) ||
-			(desc2.dsc_dtype == dtype_text && desc2.dsc_length >= 9))
-		{
-			dtype = dtype_double;
-		}
-		else
-			dtype = MAX(desc1.dsc_dtype, desc2.dsc_dtype);
-		switch (dtype)
-		{
-		case dtype_varying:
-		case dtype_cstring:
-		case dtype_text:
-		case dtype_real:
-		case dtype_double:
-		case dtype_long:
-			desc->dsc_dtype = dtype_double;
-			desc->dsc_length = sizeof(double);
-			break;
-
-		default:
-			desc->dsc_dtype = dtype_long;
-			desc->dsc_length = sizeof(SLONG);
-			desc->dsc_scale = desc1.dsc_scale + desc2.dsc_scale;
-			break;
-		}
-		return;
-
-	case nod_agg_average:
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_total:
-
-	case nod_average:
-	case nod_max:
-	case nod_min:
-	case nod_total:
-	case nod_from:
-
-	case nod_rpt_average:
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_total:
-	case nod_running_total:
-		make_descriptor(node->nod_arg[e_stt_value], desc);
-		if (desc->dsc_dtype == dtype_short)
-		{
-			desc->dsc_dtype = dtype_long;
-			desc->dsc_length = sizeof(SLONG);
-		}
-		else if (desc->dsc_dtype == dtype_real)
-		{
-			desc->dsc_dtype = dtype_double;
-			desc->dsc_length = sizeof(double);
-		}
-		return;
-
-	case nod_null:
-		desc->dsc_dtype = dtype_long;
-		desc->dsc_length = sizeof(SLONG);
-		desc->dsc_missing = DSC_missing;
-		return;
-
-	case nod_count:
-	case nod_agg_count:
-	case nod_running_count:
-	case nod_rpt_count:
-		desc->dsc_dtype = dtype_long;
-		desc->dsc_length = sizeof(SLONG);
-		return;
-
-	case nod_divide:
-		desc->dsc_dtype = dtype_double;
-		desc->dsc_length = sizeof(double);
-		return;
-
-	case nod_negate:
-		make_descriptor(node->nod_arg[0], desc);
-		return;
-
-	case nod_user_name:
-		desc->dsc_dtype = dtype_varying;
-		desc->dsc_scale = 0;
-		desc->dsc_length = sizeof(USHORT) + 16;
-		return;
-
-	case nod_substr:
-	default:
-		ERRQ_bugcheck(362);			// Msg362 make_descriptor: not yet implemented
-	}
-}
-
-
-static qli_msg* make_message( qli_req* request)
-{
-/**************************************
- *
- *	m a k e _ m e s s a g e
- *
- **************************************
- *
- * Functional description
- *	Allocate a message block for a request.
- *
- **************************************/
-	qli_msg* message = (qli_msg*) ALLOCDV(type_msg, 0);
-	message->msg_request = request;
-	message->msg_next = request->req_messages;
-	request->req_messages = message;
-	message->msg_number = request->req_msg_number++;
-
-	return message;
-}
-
-
-static void make_missing_reference( qli_par* parameter)
-{
-/**************************************
- *
- *	m a k e _ m i s s i n g _ r e f e r e n c e
- *
- **************************************
- *
- * Functional description
- *	Make up a parameter to pass a missing value.
- *
- **************************************/
-	if (parameter->par_missing)
-		return;
-
-	qli_par* missing = (qli_par*) ALLOCD(type_par);
-	parameter->par_missing = missing;
-	missing->par_message = parameter->par_message;
-	missing->par_desc.dsc_dtype = dtype_short;
-	missing->par_desc.dsc_length = sizeof(SSHORT);
-}
-
-
-static qli_par* make_parameter( qli_msg* message, qli_nod* node)
-{
-/**************************************
- *
- *	m a k e _ p a r a m e t e r
- *
- **************************************
- *
- * Functional description
- *	Make a parameter block and hang it off a message block.
- *	To make prompts come out in the right order, insert the
- *	new prompt at the end of the prompt list.  Sigh.
- *
- **************************************/
-	qli_par** ptr = &message->msg_parameters;
-
-	while (*ptr)
-		ptr = &(*ptr)->par_next;
-
-	qli_par* parm = (qli_par*) ALLOCD(type_par);
-	*ptr = parm;
-	parm->par_message = message;
-	if (node && (node->nod_flags & NOD_parameter2))
-		make_missing_reference(parm);
-
-	return parm;
-}
-
-
-static qli_nod* make_reference( qli_nod* node, qli_msg* message)
-{
-/**************************************
- *
- *	m a k e _ r e f e r e n c e
- *
- **************************************
- *
- * Functional description
- *	Make a reference to a value to be computed in the
- *	database context.  Since a field can be referenced
- *	several times, construct reference blocks linking
- *	the single field to the single parameter.  (I think.)
- *	In any event, if a parameter for a field exists,
- *	use it rather than generating an new one.   Make it
- *	parameter2 style if necessary.
- *
- **************************************/
-	if (!message)
-		ERRQ_bugcheck(363);			// Msg363 missing message
-
-	qli_par* parm;
-
-	// Look for an existing field reference
-
-	for (parm = message->msg_parameters; parm; parm = parm->par_next)
-	{
-		if (CMP_node_match(parm->par_value, node))
-			break;
-	}
-
-	// Parameter doesn't exist -- make a new one.
-
-	if (!parm)
-	{
-		parm = make_parameter(message, node);
-		parm->par_value = node;
-		parm->par_desc = node->nod_desc;
-	}
-
-	qli_nod* reference = (qli_nod*) ALLOCDV(type_nod, 1);
-	reference->nod_type = nod_reference;
-	reference->nod_arg[0] = node;
-	reference->nod_desc = parm->par_desc;
-	reference->nod_import = parm;
-
-	return reference;
-}
-
-
-static qli_req* make_request( qli_dbb* database)
-{
-/**************************************
- *
- *	m a k e _ r e q u e s t
- *
- **************************************
- *
- * Functional description
- *	Make a request block for a database.
- *
- **************************************/
-	qli_req* request = (qli_req*) ALLOCD(type_req);
-	request->req_database = database;
-	request->req_next = QLI_requests;
-	QLI_requests = request;
-	database->dbb_flags |= DBB_active;
-	if (!(database->dbb_transaction))
-		MET_transaction(nod_start_trans, database);
-
-	return request;
-}
-
-
-static void release_message( qli_msg* message)
-{
-/**************************************
- *
- *	r e l e a s e _ m e s s a g e
- *
- **************************************
- *
- * Functional description
- *	A message block is unneeded, so release it.
- *
- **************************************/
-	qli_req* request = message->msg_request;
-
-	qli_msg** ptr;
-	for (ptr = &request->req_messages; *ptr; ptr = &(*ptr)->msg_next)
-	{
-		if (*ptr == message)
-			break;
-	}
-
-	if (!*ptr)
-		ERRQ_bugcheck(364);			// Msg 364 lost message
-
-	*ptr = message->msg_next;
-	ALLQ_release((qli_frb*) message);
-}
-
-
-static int string_length(const dsc* desc)
-{
-/**************************************
- *
- *	s t r i n g _ l e n g t h
- *
- **************************************
- *
- * Functional description
- *	Estimate length of string based on descriptor.
- *
- **************************************/
-
-	return DSC_string_length(desc);
-}
diff --git a/src/qli/compile.h b/src/qli/compile.h
deleted file mode 100644
index d25386a246..0000000000
--- a/src/qli/compile.h
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		compile.h
- *	DESCRIPTION:	Parser/compiler definitions
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_COMPILE_H
-#define QLI_COMPILE_H
-
-// Name nodes -- used to hold names between parse and compilation
-
-struct qli_name
-{
-    blk			nam_header;
-    qli_symbol*	nam_symbol;		// Symbol pointer, if any
-    USHORT		nam_length;		// Length of name
-    TEXT		nam_string[1];	// Actual name string
-};
-
-// Qualified procedure node -- used to hold qualified procedure names
-
-struct qli_proc
-{
-    blk  qpr_header;
-    qli_dbb* qpr_database;		// database block
-    const qli_name* qpr_name;			// name block
-};
-
-// Qualified function node -- used to hold qualified function names
-
-struct qli_func
-{
-    blk  qfn_header;
-    qli_dbb* qfn_database;		// database block
-    const qli_name* qfn_name;			// name block
-};
-
-// Qualified filter node -- used to hold qualified filter names
-
-struct qli_filter
-{
-    blk  qfl_header;
-    qli_dbb* qfl_database;		// database block
-    const qli_name* qfl_name;			// name block
-};
-
-// SHOW options
-
-enum show_t {
-    show_all,
-    show_relation,
-    show_relations,
-    show_system_relations,
-    show_database,
-    show_databases,
-    show_procedure,
-    show_procedures,
-    show_version,
-    show_variable,
-    show_variables,
-    show_indices,
-    //show_qualified_procedure,
-    show_field,
-    show_filter,
-    show_filters,
-    show_global_field,
-    show_global_fields,
-    show_trigger,
-    show_triggers,
-    show_security_class,
-    show_security_classes,
-    //show_forms,
-    show_function,
-    show_functions,
-    show_views,
-    show_system_triggers,
-    show_matching_language,
-    show_db_indices,
-    show_db_fields
-};
-
-enum set_t {
-    set_blr,
-    set_statistics,
-    //set_epilog,	// Unused
-    set_columns,
-    set_lines,
-    set_semi,
-    set_echo,
-    //set_form,
-    set_matching_language,
-    set_prompt,
-    set_continuation,
-    set_user,
-    set_password,
-    //set_euc_justify,			// JPN specific option
-    set_count,
-    set_charset
-#ifdef DEV_BUILD
-    , set_hex_output,
-    set_explain
-#endif
-};
-
-// Position assignments for syntax tree nodes
-
-const int s_rel_relation	= 0;	// Actual relation block
-const int s_rel_context		= 1;	// Symbol block for context, if any
-const int s_rel_count		= 2;
-
-const int s_prt_list		= 0;	// Print list
-const int s_prt_rse			= 1;	// Rse, if any
-const int s_prt_output		= 2;	// Output file, if any
-const int s_prt_distinct	= 3;	// Simple flag indicating distinct
-const int s_prt_order		= 4;	// SQL order clause
-const int s_prt_form		= 5;
-const int s_prt_count		= 6;
-
-const int s_rse_first		= 0;	// FIRST clause, if any
-const int s_rse_boolean		= 1;	// Boolean clause, if any
-const int s_rse_sort		= 2;	// Sort clause, if any
-const int s_rse_reduced		= 3;	// Reduced clause, if any
-const int s_rse_group_by	= 4;
-const int s_rse_having		= 5;
-const int s_rse_outer		= 6;	// Outer context value (implicit ANY)
-const int s_rse_inner		= 7;	// Inner context value
-const int s_rse_op			= 8;	// Comparison operator
-const int s_rse_join_type	= 9;	// Join type
-const int s_rse_all_flag	= 10;	// Explicit "ALL" flag
-const int s_rse_list		= 11;
-const int s_rse_count		= 12;
-
-const int s_for_rse			= 0;
-const int s_for_statement	= 1;
-const int s_for_count		= 2;
-
-const int s_itm_value		= 0;	// Value of print item
-const int s_itm_edit_string	= 1;	// Edit string, if any
-const int s_itm_header		= 2;	// Query header, if any
-const int s_itm_count		= 3;
-
-const int s_sto_relation	= 0;
-const int s_sto_statement	= 1;
-const int s_sto_rse			= 2;
-const int s_sto_fields		= 3;
-const int s_sto_values		= 4;
-const int s_sto_form		= 5;
-const int s_sto_count		= 6;
-
-const int s_asn_from		= 0;
-const int s_asn_to			= 1;
-const int s_asn_count		= 2;
-
-const int s_mod_list		= 0;	// Field list
-const int s_mod_statement	= 1;	// Sub-statement
-const int s_mod_rse			= 2;	// Record selection expression
-const int s_mod_form		= 3;
-const int s_mod_count		= 4;
-
-const int s_era_rse			= 0;
-const int s_era_count		= 1;
-
-const int s_rpt_value		= 0;
-const int s_rpt_statement	= 1;
-const int s_rpt_count		= 2;
-
-const int s_if_boolean		= 0;
-const int s_if_true			= 1;
-const int s_if_false		= 2;
-const int s_if_count		= 3;
-
-const int s_stt_rse			= 0;
-const int s_stt_value		= 1;
-const int s_stt_default		= 2;
-const int s_stt_distinct	= 3;
-const int s_stt_count		= 4;
-
-const int s_out_file		= 0;
-const int s_out_pipe		= 1;
-const int s_out_count		= 2;
-
-const int s_fmt_value		= 0;
-const int s_fmt_edit		= 1;
-const int s_fmt_count		= 2;
-
-const int s_dfi_name		= 0;
-const int s_dfi_relation	= 1;	// Define index
-const int s_dfi_fields		= 2;
-const int s_dfi_count		= 3;
-
-const int s_mfi_name		= 0;	// Modify an index
-const int s_mfi_database	= 1;
-const int s_mfi_count		= 2;
-
-const int s_ffr_form		= 0;
-const int s_ffr_statement	= 1;
-const int s_ffr_count		= 2;
-
-const int s_frm_form		= 0;
-const int s_frm_context		= 1;
-const int s_frm_database	= 2;
-const int s_frm_count		= 3;
-
-const int s_men_string		= 0;
-const int s_men_labels		= 1;
-const int s_men_statements	= 2;
-const int s_men_count		= 3;
-
-const int s_fun_args		= 0;
-const int s_fun_function	= 1;
-const int s_fun_count		= 2;
-
-const int s_idx_field		= 0;	// array subscript
-const int s_idx_subs		= 1;
-const int s_idx_count		= 2;
-
-const int s_crv_name		= 0;
-const int s_crv_rse			= 1;
-const int s_crv_count		= 2;
-
-const int s_grant_fields	= 0;
-const int s_grant_relation	= 1;
-const int s_grant_users		= 2;
-const int s_grant_privileges	= 3;
-const int s_grant_count		= 4;
-
-//  some flags for index definitions
-
-const USHORT s_dfi_flag_unique		= 1;
-const USHORT s_dfi_flag_inactive	= 2;
-const USHORT s_dfi_flag_activity	= 4;
-const USHORT s_dfi_flag_selectivity	= 8;
-const USHORT s_dfi_flag_descending	= 16;
-const USHORT s_dfi_flag_order		= 32;
-const USHORT s_dfi_flag_statistics	= 64;
-
-#endif // QLI_COMPILE_H
-
diff --git a/src/qli/dtr.cpp b/src/qli/dtr.cpp
deleted file mode 100644
index 65c5ddf6a7..0000000000
--- a/src/qli/dtr.cpp
+++ /dev/null
@@ -1,749 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		dtr.cpp
- *	DESCRIPTION:	Top level driving module
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- *
- * 2002.10.30 Sean Leyne - Removed support for obsolete "PC_PLATFORM" define
- *
- */
-
-#include "firebird.h"
-
-#define QLI_MAIN
-
-#include <stdio.h>
-#include <setjmp.h>
-#include <stdlib.h>
-#include <string.h>
-#include <signal.h>
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "../qli/compile.h"
-#include "../yvalve/perf.h"
-#include "../jrd/license.h"
-#include "ibase.h"
-#include "../qli/exe.h"
-#include "../qli/all_proto.h"
-#include "../qli/compi_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/exe_proto.h"
-#include "../qli/expan_proto.h"
-#include "../qli/gener_proto.h"
-#include "../qli/help_proto.h"
-#include "../qli/lex_proto.h"
-#include "../qli/meta_proto.h"
-#include "../qli/parse_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../yvalve/perf_proto.h"
-#include "fb_exception.h"
-#include "../common/utils_proto.h"
-#include "../jrd/align.h"
-#include "../common/classes/Switches.h"
-#include "../qli/qliswi.h"
-
-#ifdef HAVE_LOCALE_H
-#include <locale.h>
-#endif
-
-using MsgFormat::SafeArg;
-
-
-const char* const STARTUP_FILE = "HOME";	// Assume it's Unix
-
-
-extern TEXT* QLI_prompt;
-
-static int async_quit(const int, const int, void*);
-static void enable_signals();
-static bool process_statement(bool);
-static void CLIB_ROUTINE signal_arith_excp(USHORT, USHORT, USHORT);
-static void usage(const Switches& switches);
-static bool yes_no(USHORT, const TEXT*);
-
-// the old name new_handler comflicts with std::new_handler for the "new" operator
-typedef void (*new_signal_handler)(int);
-
-
-struct answer_t
-{
-	TEXT answer[30];
-	bool value;
-};
-
-static bool yes_no_loaded = false;
-static answer_t answer_table[] =
-{
-	{ "NO", false },					// NO
-	{ "YES", true },					// YES
-	{ "", false }
-};
-
-
-static void atexit_fb_shutdown()
-{
-	fb_shutdown(0, fb_shutrsn_app_stopped);
-}
-
-int CLIB_ROUTINE main(int argc, char** argv)
-{
-/**************************************
- *
- *	m a i n
- *
- **************************************
- *
- * Functional description
- *	Top level routine.
- *
- **************************************/
-
-	// Look at options, if any
-
-	Firebird::PathName startup_file = STARTUP_FILE;
-
-#ifdef UNIX
-	// If a Unix system, get home directory from environment
-	SCHAR home_directory[MAXPATHLEN];
-	if (!fb_utils::readenv("HOME", startup_file))
-		startup_file = ".qli_startup";
-	else
-		startup_file.append("/.qli_startup");
-#endif
-
-#ifdef HAVE_LOCALE_H
-	// Pick up the system locale to allow SYSTEM<->UTF8 conversions
-	setlocale(LC_CTYPE, "");
-#endif
-	atexit(&atexit_fb_shutdown);
-
-	const TEXT* application_file = NULL;
-	ALLQ_init();
-	LEX_init();
-	bool version_flag = false;
-	bool banner_flag = true;
-	sw_buffers = 0;
-	strcpy(QLI_prompt_string, "QLI> ");
-	strcpy(QLI_cont_string, "CON> ");
-	// Let's define the default number of columns on a machine by machine basis
-	QLI_columns = 80;
-#ifdef TRUSTED_AUTH
-	QLI_trusted = false;
-#endif
-	QLI_nodb_triggers = false;
-	QLI_lines = 60;
-	QLI_name_columns = 0;
-	QLI_prompt = QLI_prompt_string;
-	QLI_matching_language = 0;
-	QLI_default_user[0] = 0;
-	QLI_default_password[0] = 0;
-	QLI_charset[0] = 0;
-	QLI_quit_flag = false;
-	bool help_flag = false;
-
-#ifdef DEV_BUILD
-	QLI_hex_output = false;
-#endif
-
-	SLONG debug_value; // aparently unneeded, see usage below.
-
-	const Switches switches(qli_in_sw_table, FB_NELEM(qli_in_sw_table), false, true);
-
-	const TEXT* const* const arg_end = argv + argc;
-	argv++;
-	while (argv < arg_end)
-	{
-		const TEXT* const p = *argv++;
-		if (*p != '-')
-		{
-			banner_flag = false;
-			LEX_pop_line();
-			LEX_push_string(p);
-			continue;
-		}
-		if (!p[1])
-			continue;
-
-		const Switches::in_sw_tab_t* option = switches.findSwitch(p);
-		const int in_sw = option ? option->in_sw : IN_SW_QLI_0;
-
-		switch (in_sw)
-		{
-		case IN_SW_QLI_APP_SCRIPT:
-			if (argv >= arg_end)
-			{
-				ERRQ_msg_put(23);	// Msg23 Please retry, supplying an application script file name
-				exit(FINI_ERROR);
-			}
-
-			application_file = *argv++;
-			break;
-
-		case IN_SW_QLI_BUFFERS:
-			if (argv < arg_end && **argv != '-')
-				sw_buffers = atoi(*argv++);
-			break;
-
-		case IN_SW_QLI_EXIT:
-			QLI_quit_flag = true;
-			break;
-
-		case IN_SW_QLI_FETCH_PASSWORD:
-			{
-				if (argv >= arg_end || **argv == '-')
-					break;
-				const char* pwd = NULL;
-				if (fb_utils::fetchPassword(*argv++, pwd) != fb_utils::FETCH_PASS_OK)
-					break;
-				fb_utils::copy_terminate(QLI_default_password, pwd, sizeof(QLI_default_password));
-			}
-			break;
-
-		case IN_SW_QLI_INITIAL_SCRIPT:
-			if (argv >= arg_end || **argv == '-')
-				startup_file = "";
-			else
-				startup_file = *argv++;
-			break;
-
-#ifdef TRUSTED_AUTH
-		case IN_SW_QLI_TRUSTED_AUTH:
-			QLI_trusted = true;
-			break;
-#endif
-
-		case IN_SW_QLI_NOBANNER:
-			banner_flag = false;
-			break;
-
-		case IN_SW_QLI_NODBTRIGGERS:
-			QLI_nodb_triggers = true;
-			break;
-
-		case IN_SW_QLI_PASSWORD:
-			if (argv >= arg_end || **argv == '-')
-				break;
-			fb_utils::copy_terminate(QLI_default_password, fb_utils::get_passwd(*argv++),
-				sizeof(QLI_default_password));
-			break;
-
-		case IN_SW_QLI_TRACE:
-			sw_trace = true;
-			break;
-
-		case IN_SW_QLI_USER:
-			if (argv >= arg_end || **argv == '-')
-				break;
-			fb_utils::copy_terminate(QLI_default_user, *argv++, sizeof(QLI_default_user));
-			break;
-
-		case IN_SW_QLI_VERIFY:
-			sw_verify = true;
-			break;
-
-		case IN_SW_QLI_X:
-			debug_value = 1;
-			isc_set_debug(debug_value);
-			break;
-
-		// This switch's name is arbitrary; since it is an internal
-		// mechanism it can be changed at will
-		case IN_SW_QLI_Y:
-			QLI_trace = true;
-			break;
-
-		case IN_SW_QLI_Z:
-			version_flag = true;
-			break;
-
-		case IN_SW_QLI_HELP:
-			help_flag = true;
-			break;
-
-		default:
-			ERRQ_msg_put(529, SafeArg() << p);
-			// Msg469 qli: ignoring unknown switch %c
-			break;
-		}
-	}
-
-	enable_signals();
-
-	if (help_flag)
-	{
-		usage(switches);
-		HELP_fini();
-		MET_shutdown();
-		LEX_fini();
-		ALLQ_fini();
-		return FINI_OK;
-	}
-
-	if (banner_flag)
-		ERRQ_msg_put(24);	// Msg24 Welcome to QLI Query Language Interpreter
-
-	if (version_flag)
-		ERRQ_msg_put(25, SafeArg() << FB_VERSION);	// Msg25 qli version %s
-
-	if (application_file)
-		LEX_push_file(application_file, true);
-	else
-		QLI_quit_flag = false;		// Silently ignore -E switch when no script is given
-
-	if (startup_file.length())
-		LEX_push_file(startup_file.c_str(), false);
-
-#if defined(_MSC_VER) && _MSC_VER >= 1400 && _MSC_VER < 1900
-	_set_output_format(_TWO_DIGIT_EXPONENT);
-#endif
-
-	for (bool got_started = false; !got_started;)
-	{
-		got_started = true;
-		try {
-			PAR_token();
-		}
-		catch (const Firebird::Exception&)
-		{
-			// try again
-			got_started = false;
-			ERRQ_pending();
-		}
-	}
-	QLI_error = NULL;
-
-	// Loop until end of file or forced exit
-
-	bool flush_flag = false;
-	while (QLI_line)
-	{
-		qli_plb* temp = QLI_default_pool = ALLQ_pool();
-		flush_flag = process_statement(flush_flag);
-		ERRQ_pending();
-		ALLQ_rlpool(temp);
-	}
-
-	HELP_fini();
-	MET_shutdown();
-	LEX_fini();
-	ALLQ_fini();
-#ifdef DEBUG_GDS_ALLOC
-	// Report any memory leaks noticed.
-	// We don't particularly care about QLI specific memory leaks, so all
-	// QLI allocations have been marked as "don't report".  However, much
-	// of the test-base uses QLI so having a report when QLI finishes
-	// could find leaks within the engine.
-
-	gds_alloc_report(0 ALLOC_ARGS);
-#endif
-	return (FINI_OK);
-}
-
-
-#ifdef DEV_BUILD
-void QLI_validate_desc(const dsc* d)
-{
-    fb_assert(d->dsc_dtype > dtype_unknown);
-    fb_assert(d->dsc_dtype < DTYPE_TYPE_MAX);
-    ULONG addr = (ULONG) (U_IPTR) (d->dsc_address);	// safely ignore higher bits even if present
-    USHORT ta = type_alignments[d->dsc_dtype];
-    if (ta > 1)
-		fb_assert((addr & (ta - 1)) == 0);
-}
-#endif
-
-
-static int async_quit(const int reason, const int, void*)
-{
-/**************************************
- *
- *	a s y n c _ q u i t
- *
- **************************************
- *
- * Functional description
- *	Stop whatever we happened to be doing.
- *
- **************************************/
-	if (reason == fb_shutrsn_signal)
-	{
-		EXEC_abort();
-		return FB_FAILURE;
-	}
-	return FB_SUCCESS;
-}
-
-
-static void enable_signals()
-{
-/**************************************
- *
- *	e n a b l e _ s i g n a l s
- *
- **************************************
- *
- * Functional description
- *	Enable signals.
- *
- **************************************/
-
-#ifdef SIGQUIT
-	signal(SIGQUIT, SIG_IGN);
-#endif
-	fb_shutdown_callback(0, async_quit, fb_shut_confirmation, 0);
-#ifdef SIGPIPE
-	signal(SIGPIPE, SIG_IGN);
-#endif
-	signal(SIGFPE, (new_signal_handler) signal_arith_excp);
-}
-
-
-static bool process_statement(bool flush_flag)
-{
-/**************************************
- *
- *	p r o c e s s _ s t a t e m e n t
- *
- **************************************
- *
- * Functional description
- *	Parse, compile, and execute a single statement.  If an input flush
- *	is required, return true (or status), otherwise return false.
- *
- **************************************/
-
-	// Clear database active flags in preparation for a new statement
-
-	QLI_abort = false;
-
-	for (qli_dbb* dbb = QLI_databases; dbb; dbb = dbb->dbb_next)
-		dbb->dbb_flags &= ~DBB_active;
-
-	// If the last statement wrote out anything to the terminal, skip a line
-
-	if (QLI_skip_line)
-	{
-		printf("\n");
-		QLI_skip_line = false;
-	}
-
-	// Enable signal handling for the next statement.  Each signal will
-	// be caught at least once, then reset to allow the user to really
-	// kill the process
-
-	enable_signals();
-
-	// Enable error unwinding and enable the unwinding environment
-
-	try {
-
-		// Set up the appropriate prompt and get the first significant token.  If
-		// we don't get one, we're at end of file
-
-		QLI_prompt = QLI_prompt_string;
-
-		// This needs to be done after setting QLI_prompt to prevent
-		// and infinite loop in LEX/next_line.
-		// If there was a prior syntax error, flush the token stream
-
-		if (flush_flag)
-			LEX_flush();
-
-		while (QLI_token->tok_keyword == KW_SEMI)
-			LEX_token();
-
-		PAR_real();
-
-		if (!QLI_line)
-			return false;
-
-		EXEC_poll_abort();
-
-		// Mark the current token as starting the statement.  This is allows
-		// the EDIT command to find the last statement
-
-		LEX_mark_statement();
-
-		// Change the prompt string to the continuation prompt, and parse
-		// the next statement
-
-		QLI_prompt = QLI_cont_string;
-
-		qli_syntax* syntax_tree = PARQ_parse();
-		if (!syntax_tree)
-			return false;
-
-		EXEC_poll_abort();
-
-		// If the statement was EXIT, force end of file on command input
-
-		if (syntax_tree->syn_type == nod_exit)
-		{
-			QLI_line = NULL;
-			return false;
-		}
-
-		// If the statement was quit, ask the user if he want to rollback
-
-		if (syntax_tree->syn_type == nod_quit)
-		{
-			QLI_line = NULL;
-			for (qli_dbb* dbb = QLI_databases; dbb; dbb = dbb->dbb_next)
-			{
-				if ((dbb->dbb_transaction) && (dbb->dbb_flags & DBB_updates))
-				{
-					// Msg460 Do you want to rollback updates for <dbb>?
-					if (yes_no(460, dbb->dbb_symbol->sym_string))
-						MET_transaction(nod_rollback, dbb);
-					else
-						MET_transaction(nod_commit, dbb);
-				}
-			}
-			return false;
-		}
-
-		// Expand the statement.  It will return NULL if the statement was
-		// a command.  An error will be unwound
-
-		qli_nod* expanded_tree = EXP_expand(syntax_tree);
-		if (!expanded_tree)
-			return false;
-
-		// Compile the statement
-
-		qli_nod* execution_tree = CMPQ_compile(expanded_tree);
-		if (!execution_tree)
-			return false;
-
-		// Generate any BLR needed to support the request
-
-		if (!GEN_generate(execution_tree))
-			return false;
-
-		if (QLI_statistics)
-		{
-			for (qli_dbb* dbb = QLI_databases; dbb; dbb = dbb->dbb_next)
-			{
-				if (dbb->dbb_flags & DBB_active)
-				{
-					if (!dbb->dbb_statistics)
-					{
-						dbb->dbb_statistics = (int*) gds__alloc((SLONG) sizeof(PERF64));
-#ifdef DEBUG_GDS_ALLOC
-						// We don't care about QLI specific memory leaks for V4.0
-						gds_alloc_flag_unfreed((void *) dbb->dbb_statistics);	// QLI: don't care
-#endif
-					}
-					perf64_get_info(&dbb->dbb_handle, (perf64*) dbb->dbb_statistics);
-				}
-			}
-		}
-
-		// Execute the request, for better or worse
-
-		EXEC_top(execution_tree);
-
-		if (QLI_statistics)
-		{
-			PERF64 statistics;
-			TEXT buffer[512], report[256];
-			for (qli_dbb* dbb = QLI_databases; dbb; dbb = dbb->dbb_next)
-			{
-				report[0] = 0;
-				if (dbb->dbb_flags & DBB_active)
-				{
-					ERRQ_msg_get(505, report, sizeof(report));
-					// Msg505 "    reads = !r writes = !w fetches = !f marks = !m\n"
-					FB_SIZE_T used_len = fb_strlen(report);
-					ERRQ_msg_get(506, report + used_len, sizeof(report) - used_len);
-					// Msg506 "    elapsed = !e cpu = !u system = !s mem = !x, buffers = !b"
-					perf64_get_info(&dbb->dbb_handle, &statistics);
-					perf64_format((perf64*) dbb->dbb_statistics, &statistics, report, buffer, 0);
-					ERRQ_msg_put(26, SafeArg() << dbb->dbb_filename << buffer);
-					// Msg26 Statistics for database %s %s
-					QLI_skip_line = true;
-				}
-			}
-		}
-
-		// Release resources associated with the request
-
-		GEN_release();
-
-		return false;
-
-	}	// try
-	catch (const Firebird::Exception&)
-	{
-		GEN_release();
-		return true;
-	}
-}
-
-
-static void CLIB_ROUTINE signal_arith_excp(USHORT /*sig*/, USHORT code, USHORT /*scp*/)
-{
-/**************************************
- *
- *	s i g n a l _ a r i t h _ e x c p
- *
- **************************************
- *
- * Functional description
- *	Catch arithmetic exception.
- *
- **************************************/
-	USHORT msg_number;
-
-#if defined(FPE_INOVF_TRAP) || defined(FPE_INTDIV_TRAP) || \
-	defined(FPE_FLTOVF_TRAP) || defined(FPE_FLTDIV_TRAP) || \
-	defined(FPE_FLTUND_TRAP) || defined(FPE_FLTOVF_FAULT) || \
-	defined(FPE_FLTUND_FAULT)
-
-	switch (code)
-	{
-#ifdef FPE_INOVF_TRAP
-	case FPE_INTOVF_TRAP:
-		msg_number = 14;		// Msg14 integer overflow
-		break;
-#endif
-
-#ifdef FPE_INTDIV_TRAP
-	case FPE_INTDIV_TRAP:
-		msg_number = 15;		// Msg15 integer division by zero
-		break;
-#endif
-
-#ifdef FPE_FLTOVF_TRAP
-	case FPE_FLTOVF_TRAP:
-		msg_number = 16;		// Msg16 floating overflow trap
-		break;
-#endif
-
-#ifdef FPE_FLTDIV_TRAP
-	case FPE_FLTDIV_TRAP:
-		msg_number = 17;		// Msg17 floating division by zero
-		break;
-#endif
-
-#ifdef FPE_FLTUND_TRAP
-	case FPE_FLTUND_TRAP:
-		msg_number = 18;		// Msg18 floating underflow trap
-		break;
-#endif
-
-#ifdef FPE_FLTOVF_FAULT
-	case FPE_FLTOVF_FAULT:
-		msg_number = 19;		// Msg19 floating overflow fault
-		break;
-#endif
-
-#ifdef FPE_FLTUND_FAULT
-	case FPE_FLTUND_FAULT:
-		msg_number = 20;		// Msg20 floating underflow fault
-		break;
-#endif
-
-	default:
-		msg_number = 21;		// Msg21 arithmetic exception
-	}
-#else
-	msg_number = 21;
-#endif
-
-	signal(SIGFPE, (new_signal_handler) signal_arith_excp);
-
-	IBERROR(msg_number);
-}
-
-
-static void usage(const Switches& switches)
-{
-/**************************************
- *
- *	u s a g e
- *
- **************************************
- *
- * Functional description
- *	Print help about command-line arguments.
- *
- **************************************/
-	ERRQ_msg_put(513);
-	ERRQ_msg_put(514);
-	ERRQ_msg_put(515);
-	for (const Switches::in_sw_tab_t* p = switches.getTable(); p->in_sw; ++p)
-	{
-		if (p->in_sw_msg)
-			ERRQ_msg_put(p->in_sw_msg);
-	}
-	ERRQ_msg_put(527);
-	ERRQ_msg_put(528);
-}
-
-static bool yes_no(USHORT number, const TEXT* arg1)
-{
-/**************************************
- *
- *	y e s _ n o
- *
- **************************************
- *
- * Functional description
- *	Put out a prompt that expects a yes/no
- *	answer, and keep trying until we get an
- *	acceptable answer (e.g. y, Yes, N, etc.)
- *
- **************************************/
-	TEXT prompt[256];
-
-	ERRQ_msg_format(number, sizeof(prompt), prompt, SafeArg() << arg1);
-
-	if (!yes_no_loaded)
-	{
-		yes_no_loaded = true;
-		// Msg498 NO
-		if (!ERRQ_msg_get(498, answer_table[0].answer, sizeof(answer_table[0].answer)))
-			strcpy(answer_table[0].answer, "NO");	// default if msg_get fails
-
-		// Msg497 YES
-		if (!ERRQ_msg_get(497, answer_table[1].answer, sizeof(answer_table[1].answer)))
-			strcpy(answer_table[1].answer, "YES");
-	}
-
-	TEXT buffer[256];
-	while (true)
-	{
-		buffer[0] = 0;
-		if (!LEX_get_line(prompt, buffer, sizeof(buffer)))
-			return true;
-		for (const answer_t* response = answer_table; *response->answer != '\0'; response++)
-		{
-			const TEXT* p = buffer;
-			while (*p == ' ')
-				p++;
-			if (*p == EOF)
-				return true;
-			for (const TEXT* q = response->answer; *p && UPPER(*p) == *q++; p++)
-				;
-			if (!*p || *p == '\n')
-				return response->value;
-		}
-	}
-}
diff --git a/src/qli/dtr.h b/src/qli/dtr.h
deleted file mode 100644
index e246ef4823..0000000000
--- a/src/qli/dtr.h
+++ /dev/null
@@ -1,558 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		dtr.h
- *	DESCRIPTION:	General definitions, etc.
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_DTR_H
-#define QLI_DTR_H
-
-#include "../common/dsc.h"
-#include "../jrd/constants.h"
-
-const USHORT QLI_MSG_FAC		= 1;
-
-#define IBERROR(number)			ERRQ_error (number)
-
-#define ALLOCD(type)			ALLQ_alloc (QLI_default_pool, type, 0)
-#define ALLOCDV(type, repeat)	ALLQ_alloc (QLI_default_pool, type, repeat)
-#define ALLOCP(type)			ALLQ_alloc (QLI_permanent_pool, type, 0)
-#define ALLOCPV(type, repeat)	ALLQ_alloc (QLI_permanent_pool, type, repeat)
-
-#define BLKDEF(type, root, tail) type,
-enum blk_t
-{
-	type_MIN = 0,
-#include "../qli/blk.h"
-	type_MAX
-};
-#undef BLKDEF
-
-// Block types
-
-#ifndef INCLUDE_FB_BLK
-#include "../include/old_fb_blk.h"
-#endif
-
-enum nod_t {
-
-	// Commands, not executed.
-	nod_nothing = 0,
-	nod_ready = 1,
-	nod_finish,
-	nod_commit,
-	nod_rollback,
-	nod_prepare,
-	nod_start_trans,
-	nod_show,
-	nod_exit,
-	nod_quit,
-	//nod_create,
-	nod_define,
-	nod_delete_proc,
-	nod_rename_proc,
-	nod_edit_proc,
-	nod_copy_proc,
-	nod_extract,
-	nod_set,
-	nod_help,
-	nod_shell,
-	nod_def_database,
-	nod_del_database,
-	nod_def_relation,
-	nod_mod_relation,
-	nod_del_relation,
-	nod_def_field,
-	nod_mod_field,
-	nod_del_field,
-	nod_def_index,
-	nod_del_index,
-	nod_mod_index,
-
-	// SQL statements, mapped into GDML statements
-
-	//nod_select,
-	//nod_insert,
-	//nod_delete,
-	//nod_fetch,
-	//nod_close,
-	//nod_open,
-
-	nod_for,
-	nod_restructure,
-	nod_print,
-	nod_list_fields,
-	nod_list,
-	nod_store,
-	nod_modify,
-	nod_erase,
-	nod_assign,
-	nod_report,
-	nod_report_loop,
-	nod_repeat,
-	nod_if,
-	nod_output,
-	nod_declare,
-	nod_variable,
-	nod_abort,
-	//nod_label,
-	//nod_leave,
-	//nod_sync,
-	nod_commit_retaining,
-
-	nod_relation,
-	//nod_name,
-	nod_rse,
-	//nod_union,
-	//nod_aggregate,
-
-	nod_print_item,
-	nod_star,			// Bunch of items
-	nod_column,
-	nod_tab,
-	nod_skip,
-	nod_space,
-	nod_new_page,
-	nod_report_header,
-	nod_column_header,
-
-	nod_eql,
-	nod_neq,
-	nod_gtr,
-	nod_geq,
-	nod_leq,
-	nod_lss,
-	nod_between,
-	nod_containing,
-	nod_matches,
-	nod_like,
-	nod_starts,
-	nod_missing,
-	nod_and,
-	nod_or,
-	nod_any,
-	nod_not,
-	nod_unique,
-
-	nod_reference,
-	nod_field,
-	nod_prompt,
-	//nod_prompt2,
-	nod_edit_blob,
-	nod_parameter, // only tested, but not set
-	nod_constant,
-	nod_position,
-	nod_map,
-
-	nod_add,
-	nod_subtract,
-	nod_multiply,
-	nod_divide,
-	nod_negate,
-	nod_concatenate,
-	nod_substr,
-	nod_null,
-	nod_user_name,
-	nod_format,
-	nod_choice, // only tested but not set
-	nod_function,
-
-	nod_average,
-	nod_max,
-	nod_min,
-	nod_total,
-	nod_count,
-
-	nod_agg_average,
-	nod_agg_max,
-	nod_agg_min,
-	nod_agg_total,
-	nod_agg_count,
-
-	nod_rpt_average,
-	nod_rpt_max,
-	nod_rpt_min,
-	nod_rpt_total,
-	nod_rpt_count,
-
-	nod_running_count,
-	nod_running_total,
-	nod_from,
-	nod_via, // only tested but not set
-
-	nod_upcase,				// New blr for v3
-	nod_lowcase,
-	nod_sleuth,
-	nod_index,
-
-	nod_join_inner,
-	nod_join_left,
-	nod_join_right,
-	nod_join_full, // only set but not tested
-
-	//nod_sql_create,			// SQL metadata
-	nod_sql_database,
-	//nod_sql_dr_index,
-	nod_sql_al_table,
-	nod_sql_cr_table,
-	//nod_sql_dr_table,
-	nod_sql_cr_view,
-	//nod_sql_dr_view,
-	nod_sql_grant,
-	nod_sql_revoke
-
-};
-
-struct qli_vec
-{
-	blk		vec_header;
-	ULONG	vec_count;
-	blk*	vec_object[1];
-};
-
-struct qli_vcl
-{
-	blk		vcl_header;
-	ULONG	vcl_count;
-	SLONG	vcl_long[1];
-};
-
-// Constant block
-
-struct qli_const
-{
-	blk		con_header;
-	dsc		con_desc;
-	UCHAR	con_data[1];
-};
-
-// Symbol types
-
-enum sym_t
-{
-	SYM_keyword,
-	SYM_context, // set but never tested
-	SYM_database,
-	SYM_relation,
-	SYM_field, // set but never tested
-	//SYM_stream,
-	//SYM_cursor,
-	//SYM_form,
-	SYM_function
-};
-
-struct qli_symbol
-{
-	blk			sym_header;
-	const TEXT*	sym_string;		// address of asciz string
-	USHORT		sym_length;		// length of string (exc. term.)
-	sym_t		sym_type;		// symbol type
-	USHORT		sym_keyword;	// keyword number, if keyword
-	blk*		sym_object;		// general pointer to object
-	qli_symbol*	sym_collision;	// collision pointer
-	qli_symbol*	sym_homonym;	// homonym pointer
-	TEXT		sym_name[2];	// space for name, if necessary
-};
-
-// Syntax nodes (moved from compile.h because of cross-references)
-
-struct qli_syntax
-{
-	blk		syn_header;
-	nod_t	syn_type;		// Type of node
-	USHORT	syn_flags;
-	USHORT	syn_count;		// Number of arguments
-	qli_syntax*	syn_arg[1];
-};
-
-// Database block
-
-struct qli_dbb
-{
-	blk				dbb_header;
-	qli_dbb*		dbb_next;			// Next database in system
-	struct qli_rel*	dbb_relations;		// Linked list of relations
-	struct qli_fun*	dbb_functions;		// Known functions in database
-	FB_API_HANDLE	dbb_handle;			// database handle
-	FB_API_HANDLE	dbb_transaction;	// transaction handle
-	FB_API_HANDLE	dbb_proc_trans;		// procedure transaction
-	FB_API_HANDLE	dbb_meta_trans;		// metadata update transaction
-	FB_API_HANDLE	dbb_field_request;	// "get fields" request handle
-	qli_symbol*		dbb_symbol;			// Database variable
-	qli_const*		dbb_user;			// user name
-	qli_const*		dbb_password;		// password
-	USHORT			dbb_filename_length;	// Length of filename
-	FB_API_HANDLE	dbb_lookup_blob;	// Request to look up blob
-	FB_API_HANDLE	dbb_store_blob;		// Request to store blob
-	FB_API_HANDLE	dbb_edit_blob;
-	FB_API_HANDLE	dbb_edit_store;
-	FB_API_HANDLE	dbb_scan_blobs;
-	//FB_API_HANDLE	dbb_delete_blob;	// Unused
-	USHORT			dbb_flags;
-	//USHORT		dbb_type;			// Friend or foe?
-	USHORT			dbb_pagesize;		// For SQL metadata
-	ULONG			dbb_capabilities;	// Special characteristics to look out for
-	int*			dbb_statistics;		// Statistics memory
-	FB_API_HANDLE	dbb_requests [96];	// Misc meta-data requests
-	TEXT			dbb_filename [2];	// Filename of database
-};
-
-// Bits in dbb_flags
-
-const USHORT DBB_procedures	= 1;		// Procedures relation found
-const USHORT DBB_active		= 2;		// Database is active in request
-const USHORT DBB_updates	= 8;		// Updates in current transaction
-const USHORT DBB_prepared	= 32;		// User transaction has been prepared
-
-// Bits in dbb_capabilities
-
-const ULONG DBB_cap_extern_file		= 1;	// supports the concept of external files
-const ULONG DBB_cap_files			= 2;	// uses the Firebird concept of multi-file
-const ULONG DBB_cap_security		= 4;	// Firebird style security classes
-// const ULONG DBB_cap_triggers		= 8;	-- OBSOLETE: triggers (old style)
-const ULONG DBB_cap_idx_inactive	= 16;	// Firebird index inactive flag
-const ULONG DBB_cap_multi_trans		= 32;	// Database supports multiple transactions
-const ULONG DBB_cap_single_trans	= 64;	// Database supports only a single transaction
-//const ULONG DBB_cap_dudley		= 128;	// We're authorized for meta-data updates. Unused
-const ULONG DBB_cap_functions		= 256;	// The DBMS knows about function
-const ULONG DBB_cap_new_triggers	= 512;	// triggers (new V3 style)
-const ULONG DBB_cap_shadowing		= 1024;	// Database supports shadowing
-const ULONG DBB_cap_types			= 2048;	// Database has RDB$TYPES relation
-const ULONG DBB_cap_dimensions		= 4096;	// Database supports arrays -- What a database!
-//const ULONG DBB_cap_external_type	= 8192;	// Database supports external datatypes. Unused
-const ULONG DBB_cap_rfr_sys_flag	= 16384;	// Database hasn't forgotten about the system flag
-const ULONG DBB_cap_filters			= 32768;	// Database supports filters
-const ULONG DBB_cap_index_type		= 65536;	// Database has descending indices
-const ULONG DBB_cap_nodyn			= 131072;	// Database (really, engine) does not support DYN
-// Relation block
-
-struct qli_rel
-{
-	blk				rel_header;
-	qli_rel* 		rel_next;			// Next relation in database
-	qli_dbb*		rel_database;		// Parent database
-	qli_symbol*		rel_symbol;			// Hash symbol for relation
-	struct qli_fld*	rel_fields;			// Field block
-	USHORT			rel_id;				// Relation id
-	USHORT			rel_flags;			// Misc flags
-	USHORT			rel_system_flag;	// System flag
-	USHORT			rel_max_field_pos;	// highest used field position
-};
-
-// rel_flags
-const USHORT REL_fields	= 1;	// Fields have been fetched
-const USHORT REL_system	= 2;	// Relation is system relation
-const USHORT REL_view	= 4;	// Relation is a view
-
-// Field block
-
-struct qli_fld
-{
-	blk			fld_header;
-	qli_fld*	fld_next;			// Next field in relation
-	qli_rel*	fld_relation;		// Parent relation
-	qli_symbol*	fld_name;			// Field name
-	qli_symbol*	fld_query_name;		// Field query name
-	qli_symbol*	fld_based;			// Name of global field, if we care
-	const TEXT*	fld_edit_string;	// Edit string, if any
-	const TEXT*	fld_query_header;	// Query header, if any
-	USHORT		fld_flags;
-	USHORT		fld_id;				// Field in in database
-	USHORT		fld_dtype;			// Data type of field
-	FLD_LENGTH	fld_length;			// Length of field
-	USHORT		fld_segment_length;	// Segment length for blobs
-	SSHORT		fld_scale;			// Scale factor of field
-	qli_syntax*		fld_validation;		// Validation expression
-	//qli_syntax*	fld_computed;		// Computed by expression. Unused
-	qli_const*	fld_missing;		// Missing value defined in system relation
-	SSHORT		fld_sub_type;		// Subtype for blobs, text and EXACT_NUMERICs.
-	SSHORT		fld_sub_type_missing;	// Subtype missing flag
-	SSHORT      fld_precision;      // Precision for NUMERIC and DECIMAL.
-	USHORT		fld_system_flag;	// System flag
-	double		fld_dummy;			// Force fld_data to a nice boundary word boundary
-	UCHAR		fld_data [1];
-};
-
-// fld_flags
-const USHORT FLD_computed	= 1;
-const USHORT FLD_drop		= 2;
-const USHORT FLD_modify		= 4;
-const USHORT FLD_missing	= 8;
-const USHORT FLD_not_null	= 16;
-const USHORT FLD_add		= 32;
-//const USHORT FLD_unique	= 64;	// Unused
-const USHORT FLD_array		= 128;
-
-// Privileges for SQL metadata
-
-const USHORT PRV_select		= 1;
-const USHORT PRV_insert		= 2;
-const USHORT PRV_delete		= 4;
-const USHORT PRV_update		= 8;
-const USHORT PRV_all		= PRV_select + PRV_insert + PRV_delete + PRV_update;
-const USHORT PRV_grant_option	= 16;
-
-struct qli_lls
-{
-	blk	lls_header;
-	blk* lls_object;
-	qli_lls* lls_next;
-};
-
-// Random string block -- jack of all kludges
-
-struct qli_str
-{
-	blk		str_header;
-	USHORT	str_length;
-	USHORT	str_fluff; // ??? Not used, maybe alignment?
-	TEXT	str_data[2];
-};
-
-// Free block
-
-struct qli_frb
-{
-	blk			frb_header;
-	qli_frb*	frb_next;	// Next free block in pool
-};
-
-// Hunk blocks
-
-struct qli_hnk
-{
-	blk			hnk_header;
-	void*		hnk_address;	// start of memory hunk
-	int			hnk_length;		// length of memory hunk
-	qli_hnk*	hnk_next;		// next memory hunk in structure
-};
-
-// Pool block
-
-struct qli_plb
-{
-	blk			plb_header;
-	USHORT		plb_pool_id;	// pool id
-	qli_frb*	plb_free;		// first free block
-	qli_hnk*	plb_hunks;		// first hunk block
-	qli_lls*	plb_lls;		// avaiable linked list stack nodes
-};
-
-// Equivalence label dsc_missing to field dsc_flags in the dsc structure
-
-#define dsc_missing	dsc_flags
-
-// State flags for dsc_missing
-
-const USHORT DSC_missing	= 1;
-const USHORT DSC_initial	= 2; // Nobody sets this value, at least directly
-
-// Function description
-
-struct qli_fun
-{
-	blk			fun_header;
-	qli_fun*	fun_next;		// Next function in database
-	qli_dbb*	fun_database;
-	qli_symbol*	fun_symbol;		// Associated symbol block
-	qli_symbol*	fun_query_name;
-	dsc			fun_return;		// Return descriptor
-	//USHORT	fun_args;		// Number of arguments. Unused
-	//dsc			fun_arg[1];		// Data type of arguments
-								// If you change this change blk.h too
-};
-
-// Program wide globals
-
-#ifdef QLI_MAIN
-#define EXTERN
-#else
-#define EXTERN	extern
-#endif
-
-EXTERN qli_dbb*	QLI_databases;
-EXTERN qli_plb*	QLI_permanent_pool;
-EXTERN qli_plb*	QLI_default_pool;
-EXTERN qli_fld*	QLI_variables;
-EXTERN TEXT	QLI_prompt_string [32];
-EXTERN TEXT	QLI_cont_string [32];
-EXTERN TEXT	QLI_default_user [MAX_SQL_IDENTIFIER_SIZE];
-EXTERN TEXT	QLI_default_password [MAX_SQL_IDENTIFIER_SIZE];
-EXTERN TEXT	QLI_charset [MAX_SQL_IDENTIFIER_SIZE];
-EXTERN qli_const*	QLI_matching_language;
-
-//EXTERN USHORT	QLI_eof;
-EXTERN bool		QLI_blr;
-EXTERN bool		QLI_skip_line;
-EXTERN bool		QLI_statistics;
-EXTERN bool		QLI_semi;
-EXTERN bool		QLI_abort;
-EXTERN bool		QLI_echo;
-EXTERN bool		QLI_trace;
-EXTERN USHORT	QLI_count;
-#ifdef DEV_BUILD
-EXTERN bool		QLI_explain;
-EXTERN bool		QLI_hex_output;
-#endif
-#ifdef TRUSTED_AUTH
-EXTERN bool		QLI_trusted;
-#endif
-EXTERN bool		QLI_nodb_triggers;
-EXTERN bool		QLI_quit_flag;
-
-EXTERN const char* QLI_error;
-EXTERN bool sw_verify;
-EXTERN bool sw_trace;
-EXTERN USHORT sw_buffers;
-EXTERN USHORT QLI_lines;
-EXTERN USHORT QLI_prompt_count;
-EXTERN bool QLI_reprompt;
-EXTERN USHORT QLI_name_columns;
-EXTERN USHORT QLI_columns;
-
-//EXTERN USHORT   QLI_euc_justify;
-//EXTERN USHORT   QLI_interp;
-
-#include "parse.h"
-
-// from parse.h
-EXTERN qli_tok*		QLI_token;
-EXTERN qli_line*	QLI_line;
-EXTERN TEXT*		QLI_prompt;
-
-#include "exe.h"
-
-// from exe.h
-EXTERN qli_req*	QLI_requests;			// Requests in statement
-
-
-#undef EXTERN
-
-#include "../qli/all_proto.h"
-
-#ifdef DEV_BUILD
-void QLI_validate_desc(const dsc*);
-#else
-inline void QLI_validate_desc(const dsc*) { }
-#endif
-inline void QLI_validate_desc(const dsc& d) { QLI_validate_desc(&d); }
-
-#endif // QLI_DTR_H
-
diff --git a/src/qli/err.cpp b/src/qli/err.cpp
deleted file mode 100644
index 6fe70eef14..0000000000
--- a/src/qli/err.cpp
+++ /dev/null
@@ -1,355 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		err.cpp
- *	DESCRIPTION:	Error handlers
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <setjmp.h>
-#include <stdlib.h>
-#include <string.h>
-#include "gen/iberror.h"
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "../qli/err_proto.h"
-#include "../qli/help_proto.h"
-#include "../qli/lex_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../common/classes/MsgPrint.h"
-
-using MsgFormat::SafeArg;
-
-
-static TEXT ERRQ_message[256];
-
-void ERRQ_bugcheck( USHORT number)
-{
-/**************************************
- *
- *	E R R Q _ b u g c h e c k
- *
- **************************************
- *
- * Functional description
- *	Somebody has screwed up.  Bugcheck.
- *
- **************************************/
-	TEXT s[256];
-
-	ERRQ_msg_format(number, sizeof(s), s);
-	ERRQ_error(9, SafeArg() << s);	// Msg9 INTERNAL: %s
-}
-
-
-void ERRQ_database_error( qli_dbb* dbb, ISC_STATUS* status_vector)
-{
-/**************************************
- *
- *	E R R Q _ d a t a b a s e _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	Print message from database error and unwind.
- *
- **************************************/
-
-	if (dbb)
-	{
-		ERRQ_msg_put(10, dbb->dbb_filename);	// Msg10 ** QLI error from database %s **
-		gds__print_status(status_vector);
-	}
-	else
-	{
-		ERRQ_msg_put(11);	// Msg11 ** QLI error from database **
-		gds__print_status(status_vector);
-	}
-
-	QLI_skip_line = true;
-
-	// if we've really got the database open and get an I/O error,
-	// close up neatly.  If we get an I/O error trying to open the
-	// database, somebody else will clean up
-
-	if (dbb && dbb->dbb_handle && status_vector[1] == isc_io_error)
-		ERRQ_msg_put(458, dbb->dbb_filename);	// Msg458 ** connection to database %s lost **
-
-	Firebird::LongJump::raise();
-}
-
-
-void ERRQ_error(USHORT number, const SafeArg& arg)
-{
-/**************************************
- *
- *	E R R Q _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	An error has occurred.  Put out an error message and
- *	unwind.  If this was called before the unwind path
- *	was established, don't unwind just print error and exit.
- *
- **************************************/
-
-	ERRQ_pending();
-	ERRQ_error_format(number, arg);
-
-	Firebird::LongJump::raise();
-	/*
-	else
-	{
-		ERRQ_pending();
-		ERRQ_exit(FINI_ERROR);
-	}
-	*/
-}
-
-void ERRQ_error(USHORT number, const char* str)
-{
-/**************************************
- *
- *	E R R Q _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	An error has occurred.  Put out an error message and
- *	unwind.  If this was called before the unwind path
- *	was established, don't unwind just print error and exit.
- *
- **************************************/
-
-	ERRQ_error(number, SafeArg() << str);
-}
-
-
-void ERRQ_error_format(USHORT number, const SafeArg& arg)
-{
-/**************************************
- *
- *	E R R Q _ e r r o r _ f o r m a t
- *
- **************************************
- *
- * Functional description
- *	Retrieve a message from the error file and format it
- *      in the standard qli error format, put it where
- *      ERRQ_pending expects to find it.
- **************************************/
-	TEXT s[256];
-
-	fb_msg_format(0, QLI_MSG_FAC, number, sizeof(s), s, arg);
-	fb_msg_format(0, QLI_MSG_FAC, 12, sizeof(ERRQ_message), ERRQ_message, SafeArg() << s);
-	// Msg12 ** QLI error: %s **
-	QLI_error = ERRQ_message;
-	QLI_skip_line = true;
-}
-
-
-void ERRQ_exit( int status)
-{
-/**************************************
- *
- *	E R R Q _ e x i t
- *
- **************************************
- *
- * Functional description
- *	Exit after shutting down a bit.
- *
- **************************************/
-
-	HELP_fini();
-	LEX_fini();
-	exit(status);
-}
-
-
-void ERRQ_msg_format(USHORT number, USHORT length, TEXT* output_string, const SafeArg& arg)
-{
-/**************************************
- *
- *	E R R Q _ m s g _ f o r m a t
- *
- **************************************
- *
- * Functional description
- *	Retrieve a message from the error file and format it
- *
- **************************************/
-
-	fb_msg_format(0, QLI_MSG_FAC, number, length, output_string, arg);
-}
-
-
-void ERRQ_msg_partial(USHORT number, const SafeArg& arg)
-{
-/**************************************
- *
- *	E R R Q _ m s g _ p a r t i a l
- *
- **************************************
- *
- * Functional description
- *	Retrieve a message from the error file, format it, and print it
- *
- **************************************/
-
-	fb_msg_format(0, QLI_MSG_FAC, number, sizeof(ERRQ_message), ERRQ_message, arg);
-	printf("%s", ERRQ_message);
-}
-
-
-void ERRQ_msg_put(USHORT number, const SafeArg& arg)
-{
-/**************************************
- *
- *	E R R Q _ m s g _ p u t
- *
- **************************************
- *
- * Functional description
- *	Retrieve a message from the error file, format it, and print it
- * It's same outcome as ERRQ_msg_partial but with a newline at the end.
- *
- **************************************/
-
-	fb_msg_format(0, QLI_MSG_FAC, number, sizeof(ERRQ_message), ERRQ_message, arg);
-	printf("%s\n", ERRQ_message);
-}
-
-
-void ERRQ_msg_put(USHORT number, const char* str)
-{
-/**************************************
- *
- *	E R R Q _ m s g _ p u t
- *
- **************************************
- *
- * Functional description
- *	Retrieve a message from the error file, format it, and print it
- * It's same outcome as ERRQ_msg_partial but with a newline at the end.
- *
- **************************************/
-
-	fb_msg_format(0, QLI_MSG_FAC, number, sizeof(ERRQ_message), ERRQ_message, SafeArg() << str);
-	printf("%s\n", ERRQ_message);
-}
-
-
-int ERRQ_msg_get( USHORT number, TEXT* output_msg, FB_SIZE_T s_size)
-{
-/**************************************
- *
- *	E R R Q _ m s g _ g e t
- *
- **************************************
- *
- * Functional description
- *	Retrieve a message from the error file
- *
- **************************************/
-	static const SafeArg arg;
-
-	int l = fb_msg_format(0, QLI_MSG_FAC, number, s_size, output_msg, arg);
-	return (l >= 0);
-}
-
-
-void ERRQ_pending()
-{
-/**************************************
- *
- *	E R R Q _ p e n d i n g
- *
- **************************************
- *
- * Functional description
- *	Print out an error message if one is pending.
- *
- **************************************/
-
-	if (QLI_error)
-	{
-		printf("%s\n", QLI_error);
-		QLI_error = NULL;
-	}
-}
-
-
-void ERRQ_print_error(USHORT number, const SafeArg& arg)
-{
-/**************************************
- *
- *	E R R Q _ p r i n t _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	An error has occurred.  Put out an error message and
- *	unwind.
- *
- **************************************/
-
-	ERRQ_error(number, arg);
-}
-
-
-void ERRQ_print_error(USHORT number, const char* str)
-{
-/**************************************
- *
- *	E R R Q _ p r i n t _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	An error has occurred.  Put out an error message and
- *	unwind.
- *
- **************************************/
-
-	ERRQ_error(number, SafeArg() << str);
-}
-
-
-void ERRQ_syntax( USHORT number)
-{
-/**************************************
- *
- *	E R R Q _ s y n t a x
- *
- **************************************
- *
- * Functional description
- *	Syntax error has occurred.  Give some hint of what went
- *	wrong.
- *
- **************************************/
-	TEXT s[256];
-
-	ERRQ_msg_format(number, sizeof(s), s);
-	ERRQ_error(13, SafeArg() << s << QLI_token->tok_string);
-	// Msg13 expected %s, encountered %s
-}
diff --git a/src/qli/err_proto.h b/src/qli/err_proto.h
deleted file mode 100644
index f5bbe2aa88..0000000000
--- a/src/qli/err_proto.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		err_proto.h
- *	DESCRIPTION:	Prototype header file for err.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_ERR_PROTO_H
-#define QLI_ERR_PROTO_H
-
-#include "../common/classes/SafeArg.h"
-
-void	ERRQ_bugcheck(USHORT);
-void	ERRQ_database_error(qli_dbb*, ISC_STATUS*);
-void	ERRQ_error(USHORT, const MsgFormat::SafeArg& arg = MsgFormat::SafeArg());
-void	ERRQ_error(USHORT, const char* str);
-void	ERRQ_error_format(USHORT, const MsgFormat::SafeArg& arg = MsgFormat::SafeArg());
-void	ERRQ_exit (int);
-void	ERRQ_msg_format(USHORT, USHORT, TEXT*, const MsgFormat::SafeArg& arg = MsgFormat::SafeArg());
-int		ERRQ_msg_get(USHORT, TEXT*, FB_SIZE_T s_size);
-void	ERRQ_msg_partial (USHORT, const MsgFormat::SafeArg& arg = MsgFormat::SafeArg());
-void	ERRQ_msg_put (USHORT, const MsgFormat::SafeArg& arg = MsgFormat::SafeArg());
-void	ERRQ_msg_put(USHORT number, const char* str);
-void	ERRQ_pending ();
-void	ERRQ_print_error(USHORT, const MsgFormat::SafeArg& arg = MsgFormat::SafeArg());
-void	ERRQ_print_error(USHORT number, const char* str);
-void	ERRQ_syntax (USHORT);
-
-#endif // QLI_ERR_PROTO_H
-
diff --git a/src/qli/eval.cpp b/src/qli/eval.cpp
deleted file mode 100644
index b8febb699b..0000000000
--- a/src/qli/eval.cpp
+++ /dev/null
@@ -1,1434 +0,0 @@
-/*
- *	PROGRAM:	QLI Command Oriented Query Language
- *	MODULE:		eval.cpp
- *	DESCRIPTION:	Value and boolean expression evaluator
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <string.h>
-#include "ibase.h"
-#include "../qli/dtr.h"
-#include "../qli/exe.h"
-#include "../qli/parse.h"
-#include "../qli/err_proto.h"
-#include "../qli/eval_proto.h"
-#include "../qli/exe_proto.h"
-#include "../qli/lex_proto.h"
-#include "../qli/mov_proto.h"
-#include "../qli/picst_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../yvalve/utl_proto.h"
-#include "../common/classes/UserBlob.h"
-#include "../common/classes/VaryStr.h"
-#include "../common/gdsassert.h"
-#include "../jrd/constants.h"
-
-
-static SLONG execute_any(qli_nod*);
-static DSC* execute_concatenate(qli_nod*, const dsc*, const dsc*);
-static DSC* execute_edit(qli_nod*);
-static DSC* execute_function(qli_nod*);
-static DSC* execute_prompt(qli_nod*);
-static DSC* execute_statistical(qli_nod*);
-static bool like(const UCHAR*, SSHORT, const UCHAR*, SSHORT, const UCHAR);
-static TEXT* make_blob_buffer(FB_API_HANDLE, USHORT *);
-static bool matches(const TEXT*, SSHORT, const TEXT*, SSHORT);
-static bool sleuth(qli_nod*, const dsc*, const dsc*, const dsc*);
-static bool sleuth_check(USHORT, const UCHAR*, const UCHAR* const, const UCHAR*, const UCHAR* const);
-static bool sleuth_class(const USHORT, const UCHAR*, const UCHAR* const, UCHAR);
-static int sleuth_merge(const UCHAR*, const UCHAR*, const UCHAR* const, UCHAR* const);
-static bool string_boolean(qli_nod*);
-static bool string_function(qli_nod*, SSHORT, const TEXT*, SSHORT, const TEXT*);
-
-const USHORT SLEUTH_insensitive	= 1;
-//#define COND_UPPER(c)		((flags & SLEUTH_insensitive) ? UPPER(c) : c)
-inline UCHAR cond_upper(const UCHAR c, const USHORT flags)
-{
-	return (flags & SLEUTH_insensitive) ? UPPER(c) : c;
-}
-
-static const UCHAR special[127] =
-{
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
-		0, 1, 1, 0, 1,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
-};
-
-static TEXT prompt[2][128] = { "", "" };
-
-
-int EVAL_boolean( qli_nod* node)
-{
-/**************************************
- *
- *	E V A L _ b o o l e a n
- *
- **************************************
- *
- * Functional description
- *	Evaluate a boolean expression.
- *
- **************************************/
-	DSC *value1, *value2;
-	int result;
-
-	switch (node->nod_type)
-	{
-	case nod_eql:
-	case nod_neq:
-	case nod_gtr:
-	case nod_geq:
-	case nod_leq:
-	case nod_lss:
-	case nod_between:
-		if (!(value1 = EVAL_value(node->nod_arg[0])) || (value1->dsc_missing & DSC_missing) ||
-			!(value2 = EVAL_value(node->nod_arg[1])) || (value2->dsc_missing & DSC_missing))
-		{
-			return false;
-		}
-		if (node->nod_flags & nod_comparison)
-			result = MOVQ_compare(value1, value2);
-		break;
-
-	case nod_and:
-	case nod_or:
-	case nod_not:
-		result = EVAL_boolean(node->nod_arg[0]);
-		break;
-
-	case nod_containing:
-	case nod_matches:
-	case nod_like:
-	case nod_starts:
-	case nod_sleuth:
-		result = string_boolean(node);
-	}
-
-	switch (node->nod_type)
-	{
-	case nod_eql:
-		return (result == 0);
-	case nod_neq:
-		return (result != 0);
-	case nod_gtr:
-		return (result > 0);
-	case nod_geq:
-		return (result >= 0);
-	case nod_leq:
-		return (result <= 0);
-	case nod_lss:
-		return (result < 0);
-
-	case nod_between:
-		if (result < 0)
-			return false;
-		if (!(value2 = EVAL_value(node->nod_arg[2])) || (value2->dsc_missing & DSC_missing))
-		{
-			return false;
-		}
-		if (MOVQ_compare(value1, value2) > 0)
-			return false;
-		return true;
-
-	case nod_missing:
-		value1 = EVAL_value(node->nod_arg[0]);
-		if (value1)
-			return (value1->dsc_missing & DSC_missing) != 0;
-		return true;
-
-	case nod_and:
-		if (!result)
-			return false;
-		return EVAL_boolean(node->nod_arg[1]);
-
-	case nod_or:
-		if (result)
-			return true;
-		return EVAL_boolean(node->nod_arg[1]);
-
-	case nod_not:
-		return !result;
-
-	case nod_any:
-	case nod_unique:
-		return execute_any(node);
-
-	case nod_sleuth:
-	case nod_containing:
-	case nod_matches:
-	case nod_like:
-	case nod_starts:
-		return result;
-
-	default:
-		ERRQ_bugcheck(28);			// Msg28 EVAL_boolean: not finished
-		return false;
-	}
-}
-
-
-void EVAL_break_compute( qli_nod* node)
-{
-/**************************************
- *
- *	E V A L _ b r e a k _ c o m p u t e
- *
- **************************************
- *
- * Functional description
- *	Compute the value of a statistical expression at control
- *	break.  The only function that needs any work is average.
- *
- **************************************/
-
-	if (node->nod_type == nod_rpt_average && node->nod_arg[e_stt_default])
-	{
-		if (node->nod_desc.dsc_dtype == dtype_long)
-			*(SLONG *) node->nod_desc.dsc_address /= (IPTR) node->nod_arg[e_stt_default];
-		else
-			*(double *) node->nod_desc.dsc_address /= (IPTR) node->nod_arg[e_stt_default];
-	}
-}
-
-
-void EVAL_break_increment( qli_nod* node)
-{
-/**************************************
- *
- *	E V A L _ b r e a k _ i n c r e m e n t
- *
- **************************************
- *
- * Functional description
- *	Initialize a report-local statistical function.
- *
- **************************************/
-	DSC* desc1 = &node->nod_desc;
-
-	// Knock off count as trivial
-
-	if (node->nod_type == nod_rpt_count)
-	{
-		*(SLONG *) node->nod_desc.dsc_address += 1;
-		return;
-	}
-
-	// Evaluate the sub-expression.  If null, don't bother to do anything
-	// more.  If not, bump the number of records involved
-
-	dsc* desc2 = EVAL_value(node->nod_arg[e_stt_value]);
-	if (!desc2)
-		return;
-
-	// If this is the first value, just move it in.
-
-	const SLONG count = (IPTR) node->nod_arg[e_stt_default] + 1;
-	if (count == 1)
-	{
-		if (desc2->dsc_missing)
-			desc1->dsc_missing = DSC_missing;
-		else
-		{
-			desc1->dsc_missing = FALSE;
-			MOVQ_move(desc2, desc1);
-			node->nod_arg[e_stt_default] = (qli_nod*) (IPTR) count;
-		}
-		return;
-	}
-	if (desc2->dsc_missing)
-		return;
-
-	node->nod_arg[e_stt_default] = (qli_nod*) (IPTR) count;
-	desc1->dsc_missing = FALSE;
-
-	// Finish off as per operator
-
-	SSHORT comparison;
-
-	switch (node->nod_type)
-	{
-	case nod_rpt_min:
-	case nod_rpt_max:
-		if (!(comparison = MOVQ_compare(desc2, desc1)))
-			break;
-		if ((comparison > 0 && node->nod_type == nod_rpt_max) ||
-			(comparison < 0 && node->nod_type == nod_rpt_min))
-		{
-			MOVQ_move(desc2, desc1);
-		}
-		break;
-
-	case nod_rpt_total:
-	case nod_rpt_average:
-		if (desc1->dsc_dtype == dtype_long)
-			*(SLONG *) desc1->dsc_address += MOVQ_get_long(desc2, desc1->dsc_scale);
-		else
-			*(double *) desc1->dsc_address += MOVQ_get_double(desc2);
-		break;
-	}
-}
-
-
-void EVAL_break_init( qli_nod* node)
-{
-/**************************************
- *
- *	E V A L _ b r e a k _ i n i t
- *
- **************************************
- *
- * Functional description
- *	Initialize a report-local statistical function.
- *
- **************************************/
-
-	node->nod_arg[e_stt_default] = 0;
-	node->nod_desc.dsc_missing = FALSE;
-
-	if (node->nod_type == nod_rpt_count)
-		*(SLONG *) (node->nod_desc.dsc_address) = 0;
-}
-
-
-dsc* EVAL_parameter(qli_par* parameter)
-{
-/**************************************
- *
- *	E V A L _ p a r a m e t e r
- *
- **************************************
- *
- * Functional description
- *	Compute the descriptor for a parameter.
- *
- **************************************/
-	qli_par* missing_parameter;
-
-	dsc* desc = &parameter->par_desc;
-	desc->dsc_missing = FALSE;
-	qli_msg* message = parameter->par_message;
-
-	if (missing_parameter = parameter->par_missing)
-	{
-		const USHORT* missing_flag = (USHORT*) (message->msg_buffer + missing_parameter->par_offset);
-		desc->dsc_missing = *missing_flag ? DSC_missing : 0;
-	}
-
-	desc->dsc_address = message->msg_buffer + parameter->par_offset;
-	QLI_validate_desc(desc);
-
-	return desc;
-}
-
-
-dsc* EVAL_value(qli_nod* node)
-{
-/**************************************
- *
- *	E V A L _ v a l u e
- *
- **************************************
- *
- * Functional description
- *	Evaluate a value node.
- *
- **************************************/
-	DSC *values[4];
-
-	// Start by evaluating sub-expressions (where appropriate)
-
-	dsc* desc = &node->nod_desc;
-	fb_assert(node->nod_count < 5);
-	qli_nod** ptr = node->nod_arg;
-	const qli_nod* const* const end_ptr = ptr + node->nod_count;
-
-	for (dsc** value = values; ptr < end_ptr; ptr++, value++)
-	{
-		*value = EVAL_value(*ptr);
-		if (node->nod_flags & nod_partial)
-			break;
-	}
-
-	switch (node->nod_type)
-	{
-	case nod_edit_blob:
-		return execute_edit(node);
-
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_total:
-	case nod_rpt_average:
-		if (!(IPTR) node->nod_arg[e_stt_default])
-			desc->dsc_missing = DSC_missing;
-
-	case nod_rpt_count:
-	case nod_constant:
-		return desc;
-
-	case nod_variable:
-		{
-			qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-			desc->dsc_missing = (field->fld_flags & FLD_missing) ? DSC_missing : 0;
-		}
-		return desc;
-
-	case nod_field:
-		return EVAL_value(node->nod_arg[e_fld_reference]);
-
-	case nod_reference:
-		return EVAL_parameter(node->nod_import);
-
-	case nod_null:
-		return desc;
-
-	case nod_add:
-		if ((values[0]->dsc_missing & DSC_missing) || (values[1]->dsc_missing & DSC_missing))
-		{
-			desc->dsc_missing = DSC_missing;
-			return desc;
-		}
-		desc->dsc_missing = FALSE;
-		if (node->nod_flags & nod_date)
-		{
-			double d1 = MOVQ_date_to_double(values[0]) + MOVQ_get_double(values[1]);
-			MOVQ_double_to_date(d1, (SLONG*) desc->dsc_address);
-		}
-		else if (desc->dsc_dtype == dtype_long)
-		{
-			*((SLONG*) desc->dsc_address) =
-				MOVQ_get_long(values[0], desc->dsc_scale) + MOVQ_get_long(values[1], desc->dsc_scale);
-		}
-		else
-			*((double*) desc->dsc_address) = MOVQ_get_double(values[0]) + MOVQ_get_double(values[1]);
-		return desc;
-
-	case nod_subtract:
-		if ((values[0]->dsc_missing & DSC_missing) || (values[1]->dsc_missing & DSC_missing))
-		{
-			desc->dsc_missing = DSC_missing;
-			return desc;
-		}
-		desc->dsc_missing = FALSE;
-		if (node->nod_flags & nod_date)
-		{
-			*((double*) desc->dsc_address) =
-				MOVQ_date_to_double(values[0]) - MOVQ_date_to_double(values[1]);
-		}
-		else if (desc->dsc_dtype == dtype_long)
-		{
-			*((SLONG*) desc->dsc_address) =
-				MOVQ_get_long(values[0], desc->dsc_scale) - MOVQ_get_long(values[1], desc->dsc_scale);
-		}
-		else
-			*((double*) desc->dsc_address) = MOVQ_get_double(values[0]) - MOVQ_get_double(values[1]);
-		return desc;
-
-	case nod_divide:
-		if ((values[0]->dsc_missing & DSC_missing) || (values[1]->dsc_missing & DSC_missing))
-		{
-			desc->dsc_missing = DSC_missing;
-			return desc;
-		}
-		desc->dsc_missing = FALSE;
-		*((double*) desc->dsc_address) = MOVQ_get_double(values[0]) / MOVQ_get_double(values[1]);
-		return desc;
-
-	case nod_multiply:
-		if ((values[0]->dsc_missing & DSC_missing) || (values[1]->dsc_missing & DSC_missing))
-		{
-			desc->dsc_missing = DSC_missing;
-			return desc;
-		}
-		desc->dsc_missing = FALSE;
-		if (desc->dsc_dtype == dtype_long)
-		{
-			*((SLONG*) desc->dsc_address) =
-				MOVQ_get_long(values[0], values[0]->dsc_scale) *
-				MOVQ_get_long(values[1], values[1]->dsc_scale);
-		}
-		else
-			*((double*) desc->dsc_address) = MOVQ_get_double(values[0]) * MOVQ_get_double(values[1]);
-		return desc;
-
-	case nod_negate:
-		if (values[0]->dsc_missing & DSC_missing)
-		{
-			desc->dsc_missing = DSC_missing;
-			return desc;
-		}
-		desc->dsc_missing = FALSE;
-		switch (desc->dsc_dtype)
-		{
-		case dtype_short:
-			*((SSHORT*) desc->dsc_address) = -MOVQ_get_long(values[0], desc->dsc_scale);
-			break;
-
-		case dtype_long:
-			*((SLONG*) desc->dsc_address) = -MOVQ_get_long(values[0], desc->dsc_scale);
-			break;
-
-		// lets throw arithmetic not supported until fixed
-        //case dtype_int64:
-		//	*((SINT64*) desc->dsc_address) = -MOVQ_get_long(values[0], desc->dsc_scale);
-		//	break;
-
-		case dtype_real:
-			*((float*) desc->dsc_address) = -MOVQ_get_double(values[0]);
-			break;
-
-		case dtype_double:
-			*((double*) desc->dsc_address) = -MOVQ_get_double(values[0]);
-			break;
-
-		default:
-			IBERROR(30);		// Msg30 data type not supported for arithmetic
-		}
-		return desc;
-
-	case nod_prompt:
-		if (!prompt[0][0])
-		{
-			ERRQ_msg_get(499, prompt[0], sizeof(prompt[0]));	// Msg499 Re-enter
-			ERRQ_msg_get(500, prompt[1], sizeof(prompt[1]));	// Msg500 Enter
-		}
-		return execute_prompt(node);
-
-	case nod_concatenate:
-		return execute_concatenate(node, values[0], values[1]);
-
-	case nod_function:
-		return execute_function(node);
-
-	case nod_max:
-	case nod_min:
-	case nod_count:
-	case nod_average:
-	case nod_total:
-	case nod_from:
-		return execute_statistical(node);
-
-	case nod_running_count:
-		*(SLONG*) (desc->dsc_address) += 1;
-		return desc;
-
-	case nod_running_total:
-		{
-			dsc* desc2 = EVAL_value(node->nod_arg[e_stt_value]);
-			if (desc2)
-			{
-				if (desc2->dsc_missing & DSC_missing)
-					return desc;
-				if (desc->dsc_dtype == dtype_long)
-					*(SLONG*) desc->dsc_address += MOVQ_get_long(desc2, desc->dsc_scale);
-				else
-					*(double*) desc->dsc_address += MOVQ_get_double(desc2);
-			}
-		}
-		return desc;
-
-	case nod_format:
-		{
-			UCHAR* p = desc->dsc_address;
-			PIC_edit(values[0], (pics*) node->nod_arg[e_fmt_picture], (TEXT**) &p, desc->dsc_length);
-			desc->dsc_length = p - desc->dsc_address;
-		}
-		return desc;
-
-	case nod_user_name:
-		IBERROR(31);			// Msg31 user name is supported only in RSEs temporarily
-
-	case nod_parameter:
-	case nod_position:
-	case nod_substr:
-	case nod_via:
-
-	default:
-		ERRQ_bugcheck(29);			// Msg29 EVAL_value: not finished
-		return NULL;
-	}
-}
-
-
-static SLONG execute_any( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ a n y
- *
- **************************************
- *
- * Functional description
- *	Execute an ANY expression.  This may require that a request get
- *	started, a message sent, and a message received for each
- *	record.  At the other end of the spectrum, there may be
- *	absolutely nothing to do.
- *
- **************************************/
-	qli_msg* message;
-
-	// If there is a request associated  with the node, start it and possibly
-	// send a message along with it.
-
-	qli_req* request = (qli_req*) node->nod_arg[e_any_request];
-	if (request)
-		EXEC_start_request(request, (qli_msg*) node->nod_arg[e_any_send]);
-	else if (message = (qli_msg*) node->nod_arg[e_any_send])
-		EXEC_send(message);
-
-	message = (qli_msg*) node->nod_arg[e_any_receive];
-	EXEC_receive(message, 0);
-
-	return MOVQ_get_long(EVAL_parameter(node->nod_import), 0);
-}
-
-
-static dsc* execute_concatenate( qli_nod* node, const dsc* value1, const dsc* value2)
-{
-/**************************************
- *
- *	e x e c u t e _ c o n c a t e n a t e
- *
- **************************************
- *
- * Functional description
- *	Concatenate two strings.
- *
- **************************************/
-	Firebird::VaryStr<32> temp1;
-	const TEXT* address1;
-	USHORT length1 = MOVQ_get_string(value1, &address1, &temp1, sizeof(temp1));
-
-	Firebird::VaryStr<32> temp2;
-	const TEXT* address2;
-	USHORT length2 = MOVQ_get_string(value2, &address2, &temp2, sizeof(temp2));
-
-	dsc* desc = &node->nod_desc;
-	vary* avary = (vary*) desc->dsc_address;
-	TEXT* p = avary->vary_string;
-	length1 = MIN(length1, desc->dsc_length - 2);
-	length2 = MAX(MIN(length2, desc->dsc_length - 2 - length1), 0);
-	fb_assert(static_cast<ULONG>(length1) + length2 <= MAX_USHORT - 2);
-
-	if (length1)
-	{
-		memcpy(p, address1, length1);
-		p += length1;
-	}
-
-	if (length2)
-		memcpy(p, address2, length2);
-
-	avary->vary_length = length1 + length2;
-
-	return desc;
-}
-
-
-static DSC *execute_edit( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ e d i t
- *
- **************************************
- *
- * Functional description
- *	Edit a blob.  If there's an existing
- *	blob for input, force the descriptor
- *	to quad to get move the id.
- *
- **************************************/
-	qli_dbb* dbb = (qli_dbb*) node->nod_arg[e_edt_dbb];
-	ISC_QUAD* id = (ISC_QUAD*) & node->nod_arg[e_edt_id1];
-
-	dsc* desc = NULL;
-
-	if (node->nod_arg[e_edt_input])
-	{
-		desc = EVAL_value(node->nod_arg[e_edt_input]);
-		if (desc && (desc->dsc_dtype == dtype_blob))
-		{
-			desc->dsc_dtype = dtype_quad;
-			MOVQ_move(desc, &node->nod_desc);
-			desc->dsc_dtype = dtype_blob;
-		}
-	}
-	if (!desc)
-		id->gds_quad_low = id->gds_quad_high = 0;
-
-	const TEXT* field_name = (TEXT*) node->nod_arg[e_edt_name];
-	BLOB_edit(id, dbb->dbb_handle, dbb->dbb_transaction, field_name);
-
-	node->nod_desc.dsc_missing = UserBlob::blobIsNull(*id) ? DSC_missing : 0;
-
-	return &node->nod_desc;
-}
-
-
-static DSC *execute_function( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	Execute a statistical expression.
- *
- **************************************/
-	qli_msg* message;
-
-	// If there is a request associated  with the node, start it and possibly
-	// send a message along with it.
-
-	qli_req* request = (qli_req*) node->nod_arg[e_fun_request];
-	if (request)
-		EXEC_start_request(request, (qli_msg*) node->nod_arg[e_fun_send]);
-	else if (message = (qli_msg*) node->nod_arg[e_fun_send])
-		EXEC_send(message);
-
-	return EXEC_receive((qli_msg*) node->nod_arg[e_fun_receive], node->nod_import);
-}
-
-
-static DSC *execute_prompt( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ p r o m p t
- *
- **************************************
- *
- * Functional description
- *	Execute a prompt and return a descriptor.  If end of file,
- *	abort request; if a singleton tab, return the previous value,
- *	and if a null string, return MISSING.
- *
- **************************************/
-	TEXT string[128], buffer[256];
-
-	ERRQ_pending();
-	bool reprompt = QLI_reprompt;
-	dsc* desc = &node->nod_desc;
-	vary* data = (vary*) desc->dsc_address;
-
-	TEXT* value = (desc->dsc_length - 2 <= static_cast<int>(sizeof(buffer))) ?
-		  buffer : data->vary_string;
-	const int length = (desc->dsc_length - 2 <= static_cast<int>(sizeof(buffer))) ?
-		  sizeof(buffer) : desc->dsc_length - 2;
-
-	for (;;)
-	{
-		++QLI_prompt_count;
-		if (node->nod_arg[e_prm_prompt])
-		{
-			if (reprompt)
-				fb_utils::snprintf(string, sizeof(string), "\07%s %s: ", prompt[0], (TEXT*) node->nod_arg[e_prm_prompt]);
-			else
-				fb_utils::snprintf(string, sizeof(string), "%s %s: ", prompt[1], (TEXT*) node->nod_arg[e_prm_prompt]);
-		}
-		else
-		{
-			if (reprompt)
-				fb_utils::snprintf(string, sizeof(string), "\07%s: ", prompt[0]);	// Msg497 Re-enter
-			else
-				fb_utils::snprintf(string, sizeof(string), "%s: ", prompt[1]);	// Msg498 Enter
-		}
-
-		if (!LEX_get_line(string, value, length))
-		{
-			QLI_abort = true;
-			EXEC_poll_abort();
-		}
-
-		if (value[0] == '\t' && value[1] == '\n')
-			return desc;
-
-		TEXT* p = value + strlen(value);
-		if (p > value && p[-1] == '\n')
-			*--p = 0;
-
-		// Get rid of trailing blanks on non-text data types
-
-		if (desc->dsc_dtype > dtype_varying)
-		{
-			while (p > value && p[-1] == ' ')
-				--p;
-			*p = 0;
-		}
-
-		const int l = p - value;
-		if (l <= desc->dsc_length - 2)
-		{
-			if (value != data->vary_string)
-				memcpy(data->vary_string, value, l);
-			data->vary_length = l;
-			desc->dsc_missing = l ? 0 : DSC_missing;
-			return desc;
-		}
-
-		ERRQ_msg_put(32);	// Msg32 Input value is too long
-		reprompt = true;
-	}
-}
-
-
-static DSC *execute_statistical( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ s t a t i s t i c a l
- *
- **************************************
- *
- * Functional description
- *	Execute a statistical expression.
- *
- **************************************/
-	qli_msg* message;
-
-	// If there is a request associated  with the node, start it and possibly
-	// send a message along with it.
-
-	qli_req* request = (qli_req*) node->nod_arg[e_stt_request];
-	if (request)
-		EXEC_start_request(request, (qli_msg*) node->nod_arg[e_stt_send]);
-	else if (message = (qli_msg*) node->nod_arg[e_stt_send])
-		EXEC_send(message);
-
-	return EXEC_receive((qli_msg*) node->nod_arg[e_stt_receive], node->nod_import);
-}
-
-static bool like(const UCHAR* p1, SSHORT l1, const UCHAR* p2, SSHORT l2, const UCHAR escape_char)
-{
-/**************************************
- *
- *	l i k e
- *
- **************************************
- *
- * Functional description
- *	Return true if a string (p1, l1) matches a given pattern (p2, l2).
- *	The character '_' in the pattern may match any single character
- *	in the the string, and the character '%' may match any sequence
- *	of characters.
- *      Japanese version operates on short-based buffer,
- *      instead of char-based.
- *
- **************************************/
-	bool escape = false;
-
-	while (--l2 >= 0)
-	{
-		const UCHAR c = *p2++;
-		if (escape_char && !escape && c == escape_char)
-		{
-			escape = true;
-			continue;
-		}
-		if (!escape && c == '%')
-		{
-			if (l2 == 0)
-				return true;
-			while (l1)
-			{
-				if (like(p1++, l1--, p2, l2, escape_char))
-					return true;
-			}
-			return false;
-		}
-		if (--l1 < 0)
-			return false;
-		if ((escape || c != '_') && c != *p1)
-			return false;
-		escape = false;
-		p1++;
-	}
-
-	return l1 ? false : true;
-}
-
-
-static TEXT* make_blob_buffer(FB_API_HANDLE blob, USHORT* length)
-{
-/**************************************
- *
- *	m a k e _ b l o b _ b u f f e r
- *
- **************************************
- *
- * Functional description
- *	For a blob, get the max segment length,
- *	check that the buffer allocated is at least
- *	that length, and, if not, allocate a bigger one.
- *
- **************************************/
-	SLONG size, segment_count, max_segment;
-
-	gds__blob_size(&blob, &size, &segment_count, &max_segment);
-
-	if (max_segment >= *length)
-	{
-		*length = max_segment;
-		TEXT* buffer = (TEXT*) gds__alloc((SLONG) *length);
-#ifdef DEBUG_GDS_ALLOC
-		// We don't care about QLI specific memory leaks for V4.0
-		gds_alloc_flag_unfreed((void *) buffer);	// QLI: don't care
-#endif
-		return buffer;
-	}
-
-	return 0;
-}
-
-static bool matches(const TEXT* p1, SSHORT l1, const TEXT* p2, SSHORT l2)
-{
-/**************************************
- *
- *	m a t c h e s
- *
- **************************************
- *
- * Functional description
- *	Return true if a string (p1, l1) matches a given pattern (p2, l2).
- *	The character '?' in the pattern may match any single character
- *	in the the string, and the character '*' may match any sequence
- *	of characters.
- *
- **************************************/
-	while (--l2 >= 0)
-	{
-		const TEXT c = *p2++;
-		if (c == '*')
-		{
-			if (l2 == 0)
-				return true;
-			while (l1)
-			{
-				if (matches(p1++, l1--, p2, l2))
-					return true;
-			}
-			return false;
-		}
-		if (--l1 < 0 || (c != '?' && UPPER(c) != UPPER(*p1)))
-			return false;
-		p1++;
-	}
-
-	return l1 ? false: true;
-}
-
-
-static bool sleuth( qli_nod* node, const dsc* desc1, const dsc* desc2, const dsc* desc3)
-{
-/**************************************
- *
- *	s l e u t h
- *
- **************************************
- *
- * Functional description
- *	Return true if a string (p1, l1) matches a given pattern (p2, l2),
- *	using a pattern language defined in p3, l3.
- *
- **************************************/
-
-	// Get operator definition string (control string)
-
-	Firebird::VaryStr<TEMP_STR_LENGTH> temp1;
-	const TEXT* p1;
-	SSHORT l1 = MOVQ_get_string(desc3, &p1, &temp1, TEMP_STR_LENGTH);
-
-	// Get address and length of search string
-
-	Firebird::VaryStr<TEMP_STR_LENGTH> temp2;
-	const TEXT* p2;
-	SSHORT l2 = MOVQ_get_string(desc2, &p2, &temp2, TEMP_STR_LENGTH);
-
-	// Merge search and control strings
-
-	UCHAR control[256];
-	l2 = sleuth_merge((const UCHAR*) p2, (const UCHAR*) p1, (const UCHAR*) (p1 + l1), control);
-
-	// If source is not a blob, do a simple search
-
-	if (desc1->dsc_dtype != dtype_blob)
-	{
-		l1 = MOVQ_get_string(desc1, &p1, &temp1, TEMP_STR_LENGTH);
-		return sleuth_check(0, (const UCHAR*) p1, (const UCHAR*) (p1 + l1), control, control + l2);
-	}
-
-	// Source string is a blob, things get interesting
-
-	bool result = false;
-
-	FB_API_HANDLE blob = EXEC_open_blob(node->nod_arg[0]);
-
-	TEXT fixed_buffer[512];
-	USHORT buffer_length = sizeof(fixed_buffer);
-
-	TEXT* buffer = make_blob_buffer( blob, &buffer_length);
-	if (!buffer)
-		buffer = fixed_buffer;
-
-	ISC_STATUS_ARRAY status_vector;
-	while (!isc_get_segment(status_vector, &blob, (USHORT*) &l1, buffer_length, buffer))
-		if (sleuth_check(0, (UCHAR*) buffer, (UCHAR*) (buffer + l1), control, control + l2))
-		{
-			result = true;
-			break;
-		}
-
-	if (buffer != fixed_buffer)
-		gds__free(buffer);
-
-	if (isc_close_blob(status_vector, &blob))
-	{
-		qli_ctx* context = (qli_ctx*) node->nod_arg[e_fld_context];
-		qli_req* request = context->ctx_request;
-		qli_dbb* dbb = request->req_database;
-		ERRQ_database_error(dbb, status_vector);
-	}
-
-	return result;
-}
-
-static bool sleuth_check(USHORT flags,
-						 const UCHAR* search, const UCHAR* const end_search,
-						 const UCHAR* match, const UCHAR* const end_match)
-{
-/**************************************
- *
- *	s l e u t h _ c h e c k
- *
- **************************************
- *
- * Functional description
- *	Evaluate the "sleuth" search operator.
- *
- **************************************/
-	while (match < end_match)
-	{
-		UCHAR c = *match++;
-		if ((c == '@' && (c = *match++)) || !special[c])
-		{
-			c = cond_upper(c, flags);
-			if (match >= end_match || *match != '*')
-			{
-				if (search >= end_search)
-					return false;
-				const UCHAR d = *search++;
-				if (c != cond_upper(d, flags))
-					return false;
-			}
-			else
-			{
-				++match;
-				for (;;)
-				{
-					if (sleuth_check(flags, search, end_search, match, end_match))
-						return true;
-					if (search < end_search)
-					{
-						const UCHAR d = *search++;
-						if (c != cond_upper(d, flags))
-							return false;
-					}
-					else
-						return false;
-				}
-			}
-		}
-		else if (c == '?')
-		{
-			if (match >= end_match || *match != '*')
-			{
-				if (search >= end_search)
-					return false;
-				search++;
-			}
-			else
-			{
-				if (++match >= end_match)
-					return true;
-				for (;;)
-				{
-					if (sleuth_check(flags, search, end_search, match, end_match))
-						return true;
-					if (++search >= end_search)
-						return false;
-				}
-			}
-		}
-		else if (c == '[')
-		{
-			const UCHAR* char_class = match;
-			while (*match++ != ']')
-			{
-				if (match >= end_match)
-					return false;
-			}
-
-			const UCHAR* const end_class = match - 1;
-			if (match >= end_match || *match != '*')
-			{
-				if (!sleuth_class(flags, char_class, end_class, *search++))
-					return false;
-			}
-			else
-			{
-				++match;
-				for (;;)
-				{
-					if (sleuth_check(flags, search, end_search, match, end_match))
-						return true;
-					if (search < end_search)
-					{
-						if (!sleuth_class(flags, char_class, end_class, *search++))
-							return false;
-					}
-					else
-						return false;
-				}
-			}
-		}
-		else if (c == '+')
-		{
-			c = *match++;
-			if (c == 'S' || c == 's')
-				flags &= ~SLEUTH_insensitive;
-		}
-		else if (c == '-')
-		{
-			c = *match++;
-			if (c == 'S' || c == 's')
-				flags |= SLEUTH_insensitive;
-		}
-	}
-
-	if (search < end_search)
-		return false;
-
-	return true;
-}
-
-
-static bool sleuth_class( const USHORT flags,
-						const UCHAR* char_class, const UCHAR* const end_class,
-						UCHAR character)
-{
-/**************************************
- *
- *	s l e u t h _ c l a s s
- *
- **************************************
- *
- * Functional description
- *	See if a character is a member of a class.
- *
- **************************************/
-	bool result = true;
-	character = cond_upper(character, flags);
-
-	if (*char_class == '~')
-	{
-		++char_class;
-		result = false;
-	}
-
-	while (char_class < end_class)
-	{
-		const UCHAR c = *char_class++;
-		if (c == '@')
-		{
-			if (*char_class++ == character)
-				return true;
-		}
-		else if (*char_class == '-')
-		{
-			char_class += 2;
-			if (character >= c && character <= char_class[-1])
-				return result;
-		}
-		else if (character == c)
-			return result;
-	}
-
-	return !result;
-}
-
-
-static int sleuth_merge(const UCHAR* match,
-						const UCHAR* control, const UCHAR* const end_control,
-						UCHAR* const combined)
-{
-/**************************************
- *
- *	s l e u t h _ m e r g e
- *
- **************************************
- *
- * Functional description
- *	Merge the matching pattern and control strings to give a cannonical
- *	matching pattern.  Return the length of the combined string.
- *
- * 	What this routine does is to take the language template, strip off
- *	the prefix and put it in the output string, then parse the definitions
- *	into an array of character pointers.  The index array is the defined
- *	character.   The routine then takes the actual match pattern and uses
- *	the characters in it to index into the definitions to produce an equivalent
- *	pattern in the cannonical language.
- *
- *	The silly loop setting *v++ to zero initializes the array up to the
- *	highest character defined (also max_op).  Believe it or not, that part
- *	is not a bug.
- *
- **************************************/
-	UCHAR* comb = combined;
-	UCHAR* vector[128];
-	UCHAR** v = vector;
-	UCHAR temp[256];
-	UCHAR* t = temp;
-
-	// Parse control string into substitution strings and initializing string
-
-	while (control < end_control)
-	{
-		UCHAR c = *control++;
-		if (*control == '=')
-		{
-			UCHAR** end_vector = vector + c;
-			while (v <= end_vector)
-				*v++ = 0;
-			*end_vector = t;
-			++control;
-			while (control < end_control)
-			{
-				c = *control++;
-				if ((t[-1] == '@') || ((c != ',') && (c != ')')))
-					*t++ = c;
-				else
-					break;
-			}
-			*t++ = 0;
-		}
-		else if (c == '@' && control < end_control)
-			*comb++ = *control++;
-		else if (c == ')')
-			break;
-		else if (c != '(')
-			*comb++ = c;
-	}
-
-	const UCHAR max_op = v - vector;
-
-	// Interpret matching string, substituting where appropriate
-
-	UCHAR c;
-	while (c = *match++)
-	{
-	    const UCHAR* p;
-
-		// if we've got a defined character, slurp the definition
-		if (c <= max_op && (p = vector[c]))
-		{
-			while (*p)
-				*comb++ = *p++;
-			// if we've got the definition of a quote character, slurp the next character too
-			if (comb[-1] == '@' && *match)
-				*comb++ = *match++;
-		}
-		// at this point we've got a non-match, but as it might be one of ours, quote it.
-		else
-		{
-			if (special[c] && comb[-1] != '@')
-				*comb++ = '@';
-			*comb++ = c;
-		}
-	}
-
-	// Put in trailing stuff
-
-	while (control < end_control)
-		*comb++ = *control++;
-
-	return comb - combined;
-}
-
-
-static bool string_boolean( qli_nod* node)
-{
-/**************************************
- *
- *	s t r i n g _ b o o l e a n
- *
- **************************************
- *
- * Functional description
- *	Perform one of the complex string functions CONTAINING, MATCHES,
- *	or STARTS WITH.
- *
- **************************************/
-	const DSC *desc1, *desc2, *desc3;
-
-	if (!(desc1 = EVAL_value(node->nod_arg[0])) || (desc1->dsc_missing & DSC_missing) ||
-		!(desc2 = EVAL_value(node->nod_arg[1])) || (desc2->dsc_missing & DSC_missing) ||
-		(node->nod_arg[2] && (!(desc3 = EVAL_value(node->nod_arg[2])) ||
-							  (desc3->dsc_missing & DSC_missing))))
-	{
-		return false;
-	}
-
-	if (node->nod_type == nod_sleuth)
-		return sleuth(node, desc1, desc2, desc3);
-
-	// Get address and length of strings
-
-	const TEXT* p2;
-	Firebird::VaryStr<TEMP_STR_LENGTH> temp2;
-	SSHORT l2 = MOVQ_get_string(desc2, &p2, &temp2, TEMP_STR_LENGTH);
-
-	// If source is not a blob, do a simple search
-
-	if (desc1->dsc_dtype != dtype_blob)
-	{
-		Firebird::VaryStr<TEMP_STR_LENGTH> temp1;
-		const TEXT* p1;
-		SSHORT l1 = MOVQ_get_string(desc1, &p1, &temp1, TEMP_STR_LENGTH);
-		return string_function(node, l1, p1, l2, p2);
-	}
-
-	// Source string is a blob, things get interesting
-
-	bool result = false;
-	FB_API_HANDLE blob = EXEC_open_blob(node->nod_arg[0]);
-
-    TEXT fixed_buffer[512];
-	USHORT buffer_length = sizeof(fixed_buffer);
-
-	TEXT* buffer = make_blob_buffer( blob, &buffer_length);
-	if (!buffer)
-		buffer = fixed_buffer;
-
-	ISC_STATUS_ARRAY status_vector;
-	SSHORT l3 = 0;
-	while (!isc_get_segment(status_vector, &blob, (USHORT*) &l3, buffer_length, buffer))
-	{
-		if (string_function(node, l3, buffer, l2, p2))
-		{
-			result = true;
-			break;
-		}
-	}
-
-	if (buffer != fixed_buffer)
-		gds__free(buffer);
-
-	if (isc_close_blob(status_vector, &blob))
-	{
-		qli_ctx* context = (qli_ctx*) node->nod_arg[e_fld_context];
-		qli_req* request = context->ctx_request;
-		qli_dbb* database = request->req_database;
-		ERRQ_database_error(database, status_vector);
-	}
-
-	return result;
-}
-
-
-static bool string_function(qli_nod* node,
-						   SSHORT l1, const TEXT* p1, SSHORT l2, const TEXT* p2)
-{
-/**************************************
- *
- *	s t r i n g _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	Perform one of the complex string functions CONTAINING, MATCHES,
- *	or STARTS WITH.
- *
- **************************************/
-
-	// Handle "STARTS WITH"
-
-	if (node->nod_type == nod_starts)
-	{
-		if (l1 < l2)
-			return false;
-
-		if (l2)
-			return memcmp(p1, p2, l2) == 0;
-
-		return true;
-	}
-
-	// Handle CONTAINS
-
-	if (node->nod_type == nod_containing)
-	{
-		while (l1 >= l2)
-		{
-			--l1;
-			const TEXT* q1 = p1++;
-			const TEXT* q2 = p2;
-			SSHORT l = l2;
-			TEXT c1, c2;
-			do {
-				if (--l < 0)
-					return true;
-				c1 = *q1++;
-				c2 = *q2++;
-			} while (UPPER(c1) == UPPER(c2));
-		}
-		return false;
-	}
-
-	// Handle LIKE
-
-	if (node->nod_type == nod_like)
-	{
-		TEXT c1 = 0;
-		Firebird::VaryStr<16> temp;
-		const TEXT* q1 = NULL;
-		if (node->nod_count > 2 &&
-			MOVQ_get_string(EVAL_value(node->nod_arg[2]), &q1, &temp, sizeof(temp)))
-		{
-			c1 = *q1;
-		}
-		if (like((const UCHAR*) p1, l1, (const UCHAR*) p2, l2, c1))
-			return true;
-		return false;
-	}
-
-	// Handle MATCHES
-
-	return node->nod_type == nod_matches && matches(p1, l1, p2, l2);
-}
-
-
diff --git a/src/qli/eval_proto.h b/src/qli/eval_proto.h
deleted file mode 100644
index 03071e23db..0000000000
--- a/src/qli/eval_proto.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		eval_proto.h
- *	DESCRIPTION:	Prototype header file for eval.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_EVAL_PROTO_H
-#define QLI_EVAL_PROTO_H
-
-struct qli_nod;
-struct dsc;
-
-int		EVAL_boolean (qli_nod*);
-void	EVAL_break_compute (qli_nod*);
-void	EVAL_break_increment (qli_nod*);
-void	EVAL_break_init (qli_nod*);
-dsc*	EVAL_parameter (qli_par*);
-dsc*	EVAL_value (qli_nod*);
-
-#endif // QLI_EVAL_PROTO_H
-
diff --git a/src/qli/exe.cpp b/src/qli/exe.cpp
deleted file mode 100644
index e1ec994ab7..0000000000
--- a/src/qli/exe.cpp
+++ /dev/null
@@ -1,1202 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		exe.cpp
- *	DESCRIPTION:	Execution phase
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <setjmp.h>
-
-#include "ibase.h"
-#include "../yvalve/why_proto.h"
-#include "../qli/dtr.h"
-#include "../qli/exe.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/eval_proto.h"
-#include "../qli/exe_proto.h"
-#include "../qli/report.h"
-#include "../qli/forma_proto.h"
-#include "../qli/mov_proto.h"
-#include "../qli/repor_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../yvalve/utl_proto.h"
-#include "../common/classes/UserBlob.h"
-#include "../common/classes/VaryStr.h"
-#include "../common/os/os_utils.h"
-
-using MsgFormat::SafeArg;
-
-
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#ifdef HAVE_VFORK_H
-#include <vfork.h>
-#endif
-
-#ifdef HAVE_STRING_H
-#include <string.h>
-#endif
-
-const char* FOPEN_WRITE_TYPE	= "w";
-
-static DSC *assignment(qli_nod*, DSC *, qli_nod*, qli_nod*, qli_par*);
-static void commit_retaining(qli_nod*);
-static bool copy_blob(qli_nod*, qli_par*);
-static void db_error(qli_req*, ISC_STATUS *);
-static void execute_abort(qli_nod*);
-static void execute_assignment(qli_nod*);
-static void execute_for(qli_nod*);
-static void execute_modify(qli_nod*);
-static void execute_output(qli_nod*);
-static void execute_print(qli_nod*);
-static void execute_repeat(qli_nod*);
-static void execute_store(qli_nod*);
-static void map_data(qli_msg*);
-static void print_counts(qli_req*);
-static void set_null(qli_msg*);
-static void transaction_state(qli_nod*, qli_dbb*);
-
-// definitions for SET COUNT
-
-const int COUNT_ITEMS	= 4;
-
-static const SCHAR count_info[] =
-{
-	isc_info_req_select_count,
-	isc_info_req_insert_count,
-	isc_info_req_update_count,
-	isc_info_req_delete_count
-};
-
-
-void EXEC_abort()
-{
-/**************************************
- *
- *	E X E C _ a b o r t
- *
- **************************************
- *
- * Functional description
- *	An asynchrous abort has been requested.  Request that all
- *	requests be unwound and set flag.
- *
- **************************************/
-	ISC_STATUS_ARRAY status_vector;
-
-	for (qli_dbb* database = QLI_databases; database; database = database->dbb_next)
-	{
-		if (database->dbb_handle)
-		{
-			if (fb_cancel_operation(status_vector, &database->dbb_handle, fb_cancel_raise) == 0)
-			{
-				QLI_abort = true;
-			}
-		}
-	}
-
-}
-
-
-void EXEC_execute( qli_nod* node)
-{
-/**************************************
- *
- *	E X E C _ e x e c u t e
- *
- **************************************
- *
- * Functional description
- *	Execute a node.
- *
- **************************************/
-	if (QLI_abort)
-		EXEC_poll_abort();
-
-	if (node)
-	{
-		switch (node->nod_type)
-		{
-		case nod_abort:
-			execute_abort(node);
-
-		case nod_assign:
-			execute_assignment(node);
-			return;
-
-		case nod_commit_retaining:
-			commit_retaining(node);
-			return;
-
-		case nod_erase:
-			{
-				qli_msg* message = (qli_msg*) node->nod_arg[e_era_message];
-				if (message)
-					EXEC_send(message);
-			}
-			return;
-
-		case nod_for:
-			execute_for(node);
-			return;
-
-		case nod_list:
-			{
-				qli_nod** ptr = node->nod_arg;
-				for (USHORT i = 0; i < node->nod_count; i++)
-					EXEC_execute(*ptr++);
-			}
-			return;
-
-		case nod_modify:
-			execute_modify(node);
-			return;
-
-		case nod_output:
-			execute_output(node);
-			return;
-
-		case nod_print:
-			execute_print(node);
-			return;
-
-		case nod_repeat:
-			execute_repeat(node);
-			return;
-
-		case nod_store:
-			execute_store(node);
-			return;
-
-		case nod_if:
-			if (EVAL_boolean(node->nod_arg[e_if_boolean]))
-			{
-				EXEC_execute(node->nod_arg[e_if_true]);
-				return;
-			}
-			if (node->nod_arg[e_if_false])
-			{
-				EXEC_execute(node->nod_arg[e_if_false]);
-				return;
-			}
-			return;
-
-		case nod_report_loop:
-			RPT_report(node);
-			return;
-
-		default:
-			ERRQ_bugcheck(33);		// Msg33 EXEC_execute: not implemented
-		}
-	}
-}
-
-
-FB_API_HANDLE EXEC_open_blob( qli_nod* node)
-{
-/**************************************
- *
- *	E X E C _ o p e n _ b l o b
- *
- **************************************
- *
- * Functional description
- *	Given a blob field node, open and return the blob.
- *
- **************************************/
-	dsc* desc = EVAL_value(node);
-	if (!desc)
-		return 0;
-
-	// Starting from the print item, work our way back to the database block
-
-	if (node->nod_type == nod_reference)
-		node = node->nod_arg[0];
-
-	if (node->nod_type != nod_field)
-		ERRQ_bugcheck(34);			// Msg34 print_blob: expected field node
-
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_fld_context];
-	qli_req* request = context->ctx_request;
-	qli_dbb* dbb = request->req_database;
-	FB_API_HANDLE blob = 0;
-
-	// Format blob parameter block
-	UCHAR bpb[20];
-	UCHAR* p = bpb;
-	*p++ = isc_bpb_version1;
-	*p++ = isc_bpb_source_type;
-	*p++ = 2;
-	*p++ = desc->dsc_sub_type;
-	*p++ = desc->dsc_sub_type >> 8;
-	*p++ = isc_bpb_target_type;
-	*p++ = 1;
-	*p++ = 1;
-
-	const USHORT bpb_length = p - bpb;
-
-	ISC_STATUS_ARRAY status_vector;
-	if (isc_open_blob2(status_vector, &dbb->dbb_handle, &dbb->dbb_transaction,
-						&blob, (ISC_QUAD*) desc->dsc_address, bpb_length, bpb))
-	{
-		ERRQ_database_error(dbb, status_vector);
-	}
-
-	return blob;
-}
-
-
-FILE* EXEC_open_output(qli_nod* node)
-{
-/**************************************
- *
- *	E X E C _ o p e n _ o u t p u t
- *
- **************************************
- *
- * Functional description
- *	Open output stream to re-direct output.
- *
- **************************************/
-	// Evaluate filename and copy to a null terminated string
-
-	dsc* desc = EVAL_value(node->nod_arg[e_out_file]);
-	const TEXT* p = NULL;
-	Firebird::VaryStr<64> temp;
-	SSHORT l = MOVQ_get_string(desc, &p, &temp, sizeof(temp));
-	if (l >= MAXPATHLEN)
-		l = MAXPATHLEN - 1;
-
-	TEXT filename[MAXPATHLEN];
-	if (l)
-		memcpy(filename, p, l);
-
-	filename[l] = 0;
-
-	// If output is to a file, just do it
-
-	if (!node->nod_arg[e_out_pipe])
-	{
-	    FILE* out_file = os_utils::fopen(filename, FOPEN_WRITE_TYPE);
-		if (out_file)
-			return out_file;
-
-		ERRQ_print_error(42, filename);
-		// Msg42 Can't open output file %s
-	}
-
-	// Output is to a file.  Setup file and fork process
-
-#ifdef WIN_NT
-	FILE* out_file = _popen(filename, "w");
-	if (out_file)
-		return out_file;
-#else
-	TEXT* argv[20];
-	TEXT** arg = argv;
-	TEXT** const end = argv + FB_NELEM(argv) - 1; // The last element should be NULL
-	TEXT* pp = filename;
-	while (*pp && arg < end)
-	{
-		*arg++ = pp;
-		while (*pp && *pp != ' ')
-			pp++;
-		if (!*pp)
-			break;
-		*pp++ = 0;
-		while (*pp == ' ')
-			pp++;
-	}
-	*arg = NULL;
-
-	int pair[2];
-	if (pipe(pair) < 0)
-		IBERROR(36);			// Msg36 couldn't create pipe
-
-	if (!vfork())
-	{
-		close(pair[1]);
-		close(0);
-		FB_UNUSED(dup(pair[0]));
-		close(pair[0]);
-		execvp(argv[0], argv);
-		ERRQ_msg_put(43, filename);	// Msg43 Couldn't run %s
-		_exit(-1);
-	}
-
-	close(pair[0]);
-
-	FILE* out_file = fdopen(pair[1], "w");
-	if (out_file)
-		return out_file;
-#endif
-
-	IBERROR(37);				// Msg37 fdopen failed
-	return NULL;
-}
-
-
-void EXEC_poll_abort()
-{
-/**************************************
- *
- *	E X E C _ p o l l _ a b o r t
- *
- **************************************
- *
- * Functional description
- *	Poll for abort flag (actually, most routines will check the
- *	flag before calling to save time).
- *
- **************************************/
-
-	if (!QLI_abort)
-		return;
-
-	IBERROR(38);				// Msg38 execution terminated by signal
-}
-
-
-DSC *EXEC_receive(qli_msg* message, qli_par* parameter)
-{
-/**************************************
- *
- *	E X E C _ r e c e i v e
- *
- **************************************
- *
- * Functional description
- *	Receive a message from a running request.
- *
- **************************************/
-	ISC_STATUS_ARRAY status_vector;
-
-	qli_req* request = message->msg_request;
-
-	if (isc_receive(status_vector, &request->req_handle, message->msg_number,
-					 message->msg_length, message->msg_buffer, 0))
-	{
-		db_error(request, status_vector);
-	}
-
-	if (!parameter)
-		return NULL;
-
-	return EVAL_parameter(parameter);
-}
-
-
-void EXEC_send( qli_msg* message)
-{
-/**************************************
- *
- *	E X E C _ s e n d
- *
- **************************************
- *
- * Functional description
- *	Send a message to a running request.  First, however, map
- *	any data to the message.
- *
- **************************************/
-	ISC_STATUS_ARRAY status_vector;
-
-	qli_req* request = message->msg_request;
-
-	map_data(message);
-	if (isc_send(status_vector, &request->req_handle, message->msg_number,
-				  message->msg_length, message->msg_buffer, 0))
-	{
-		db_error(request, status_vector);
-	}
-}
-
-
-void EXEC_start_request( qli_req* request, qli_msg* message)
-{
-/**************************************
- *
- *	E X E C _ s t a r t _ r e q u e s t
- *
- **************************************
- *
- * Functional description
- *	Start a request running.  If there is a message to be sent, do
- *	a start and send.
- *
- **************************************/
-	ISC_STATUS_ARRAY status_vector;
-
-	if (message)
-	{
-		map_data(message);
-		if (!isc_start_and_send(status_vector, &request->req_handle,
-								 &request->req_database-> dbb_transaction,
-								 message->msg_number, message->msg_length, message->msg_buffer, 0))
-		{
-			return;
-		}
-	}
-	else
-	{
-		if (!isc_start_request(status_vector, &request->req_handle,
-								&request->req_database-> dbb_transaction, 0))
-		{
-			return;
-		}
-	}
-
-	db_error(request, status_vector);
-}
-
-
-void EXEC_top( qli_nod* node)
-{
-/**************************************
- *
- *	E X E C _ t o p
- *
- **************************************
- *
- * Functional description
- *	Execute a node type.
- *
- **************************************/
-
-	EXEC_execute(node);
-}
-
-
-static DSC *assignment(	qli_nod*		from_node,
-						DSC*			to_desc,
-						qli_nod*		validation,
-						qli_nod*		initial,
-						qli_par*		parameter)
-{
-/**************************************
- *
- *	a s s i g n m e n t
- *
- **************************************
- *
- * Functional description
- *	Evaluate an expression and perform an assignment.  If something
- *	goes wrong and there was a prompt, try again.
- *
- **************************************/
-	QLI_reprompt = false;
-	QLI_prompt_count = 0;
-
-	USHORT trash;
-	USHORT* missing_flag = &trash;
-	qli_msg* message = NULL;
-	if (parameter)
-	{
-		message = parameter->par_message;
-		missing_flag = (USHORT *) (message->msg_buffer + parameter->par_offset);
-	}
-
-	try {
-
-		dsc* from_desc = EVAL_value(from_node);
-
-		if (from_desc->dsc_missing & DSC_initial) {
-			from_desc = EVAL_value(initial);
-		}
-
-		// If there is a value present, do any assignment; otherwise null fill
-
-		if (*missing_flag = to_desc->dsc_missing = from_desc->dsc_missing)
-		{
-			if (from_desc->dsc_length)
-				memset(from_desc->dsc_address, 0, from_desc->dsc_length);
-		}
-		else {
-			MOVQ_move(from_desc, to_desc);
-		}
-
-		if (validation && EVAL_boolean(validation) <= 0) {
-			IBERROR(39);			// Msg39 field validation error
-		}
-
-		QLI_reprompt = false;
-		return from_desc;
-
-	}
-	catch (const Firebird::Exception&)
-	{
-		if (QLI_abort || !QLI_prompt_count) {
-			throw;
-		}
-
-		QLI_reprompt = true;
-		QLI_prompt_count = 0;
-		return NULL;
-	}
-}
-
-
-static void commit_retaining( qli_nod* node)
-{
-/**************************************
- *
- *	c o m m i t _ r e t a i n i n g
- *
- **************************************
- *
- * Functional description
- *	Execute commit retaining statement for
- *	one or more named databases or all databases.
- *	If there's more than one, prepare it.
- *
- **************************************/
-
-	// If there aren't any open databases then obviously
-	// there isn't anything to commit.
-
-	if (node->nod_count == 0 && !QLI_databases)
-		return;
-
-	if (node->nod_type == nod_commit_retaining &&
-		((node->nod_count > 1) || (node->nod_count == 0 && QLI_databases->dbb_next)))
-	{
-		node->nod_type = nod_prepare;
-		commit_retaining(node);
-		node->nod_type = nod_commit_retaining;
-	}
-	else if (node->nod_count == 1)
-	{
-		qli_dbb* database = (qli_dbb*) node->nod_arg[0];
-		database->dbb_flags |= DBB_prepared;
-	}
-	else
-		QLI_databases->dbb_flags |= DBB_prepared;
-
-
-	if (node->nod_count == 0)
-	{
-		for (qli_dbb* database = QLI_databases; database; database = database->dbb_next)
-		{
-			if ((node->nod_type == nod_commit_retaining) && !(database->dbb_flags & DBB_prepared))
-			{
-				ERRQ_msg_put(465, database->dbb_symbol->sym_string);
-			}
-			else if (node->nod_type == nod_prepare)
-				database->dbb_flags |= DBB_prepared;
-			if (database->dbb_transaction)
-				transaction_state(node, database);
-		}
-		return;
-	}
-
-    qli_nod** ptr = node->nod_arg;
-	for (const qli_nod* const* const end = ptr + node->nod_count; ptr < end; ptr++)
-	{
-		qli_dbb* database = (qli_dbb*) *ptr;
-		if ((node->nod_type == nod_commit_retaining) && !(database->dbb_flags & DBB_prepared))
-		{
-			ERRQ_msg_put(465, database->dbb_symbol->sym_string);
-		}
-		else if (node->nod_type == nod_prepare)
-			database->dbb_flags |= DBB_prepared;
-		if (database->dbb_transaction)
-			transaction_state(node, database);
-	}
-}
-
-
-
-static bool copy_blob( qli_nod* value, qli_par* parameter)
-{
-/**************************************
- *
- *	 c o p y _ b l o b
- *
- **************************************
- *
- * Functional description
- *	Copy a blob from one database to another.  If the blob can be
- *	successfully assigned, return false and let somebody else just
- *	copy the blob ids.
- *
- **************************************/
-
-	// If assignment isn't from a field, there isn't a blob copy, so
-	// do a dumb assignment.
-
-	if (value->nod_type != nod_field)
-		return false;
-
-	// Find the sending and receiving requests.  If they are the same
-	// and no filtering is necessary, a simple assignment will suffice.
-
-	qli_ctx* context = (qli_ctx*) value->nod_arg[e_fld_context];
-	qli_req* from_request = context->ctx_request;
-	qli_dbb* from_dbb = from_request->req_database;
-	qli_msg* message = parameter->par_message;
-	qli_req* to_request = message->msg_request;
-	qli_dbb* to_dbb = to_request->req_database;
-
-	dsc* from_desc = EVAL_value(value);
-	dsc* to_desc = EVAL_parameter(parameter);
-
-	if (to_dbb == from_dbb &&
-		(!to_desc->dsc_sub_type || from_desc->dsc_sub_type == to_desc->dsc_sub_type))
-	{
-		return false;
-	}
-
-	// We've got a blob copy on our hands.
-
-	if (!from_desc || UserBlob::blobIsNull(*(ISC_QUAD*) from_desc->dsc_address) ||
-		(from_desc->dsc_missing & DSC_missing))
-	{
-		memset(to_desc->dsc_address, 0, sizeof(ISC_QUAD));
-		to_desc->dsc_missing |= DSC_missing;
-		return true;
-	}
-
-	to_desc->dsc_missing &= ~DSC_missing;
-
-	// Format blob parameter block for the existing blob
-
-	UCHAR bpb[20];
-	UCHAR* p = bpb;
-	*p++ = isc_bpb_version1;
-	*p++ = isc_bpb_source_type;
-	*p++ = 2;
-	*p++ = from_desc->dsc_sub_type;
-	*p++ = from_desc->dsc_sub_type >> 8;
-	*p++ = isc_bpb_target_type;
-	*p++ = 2;
-	*p++ = to_desc->dsc_sub_type;
-	*p++ = to_desc->dsc_sub_type >> 8;
-	const USHORT bpb_length = p - bpb;
-
-	ISC_STATUS_ARRAY status_vector;
-	UserBlob to_blob(status_vector);
-	UserBlob from_blob(status_vector);
-
-	if (!to_blob.create(to_dbb->dbb_handle, to_dbb->dbb_transaction,
-						 *(ISC_QUAD*) to_desc->dsc_address))
-	{
-		ERRQ_database_error(to_dbb, status_vector);
-	}
-
-	if (!from_blob.open(from_dbb->dbb_handle, from_dbb->dbb_transaction,
-						*(ISC_QUAD*) from_desc->dsc_address, bpb_length, bpb))
-	{
-		ERRQ_database_error(from_dbb, status_vector);
-	}
-
-	SLONG size, segment_count, max_segment;
-	if (!getBlobSize(from_blob, &size, &segment_count, &max_segment))
-		ERRQ_database_error(from_dbb, status_vector);
-
-    UCHAR fixed_buffer[4096];
-	UCHAR* buffer;
-	USHORT buffer_length;
-	if (max_segment < (SLONG) sizeof(fixed_buffer))
-	{
-		buffer_length = sizeof(fixed_buffer);
-		buffer = fixed_buffer;
-	}
-	else
-	{
-		buffer_length = max_segment;
-		buffer = (UCHAR*) gds__alloc(buffer_length);
-#ifdef DEBUG_GDS_ALLOC
-		// We don't care about QLI specific memory leaks for V4.0
-		gds_alloc_flag_unfreed((void *) buffer);	// QLI: don't care
-#endif
-	}
-
-	FB_SIZE_T length;
-	while (from_blob.getSegment(buffer_length, buffer, length) && !from_blob.getCode())
-	{
-		if (!to_blob.putSegment(length, buffer))
-		{
-			ERRQ_database_error(to_dbb, status_vector);
-		}
-	}
-
-	if (buffer != fixed_buffer)
-		gds__free(buffer);
-
-	if (!from_blob.close())
-		ERRQ_database_error(from_dbb, status_vector);
-
-	if (!to_blob.close())
-		ERRQ_database_error(to_dbb, status_vector);
-
-	return true;
-}
-
-
-static void db_error( qli_req* request, ISC_STATUS * status_vector)
-{
-/**************************************
- *
- *	d b _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	A database error has occurred.  Unless it was the result of
- *	an unwind, generate an error.
- *
- **************************************/
-
-	EXEC_poll_abort();
-	ERRQ_database_error(request->req_database, status_vector);
-}
-
-
-static void execute_abort( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ a b o r t
- *
- **************************************
- *
- * Functional description
- *	Abort a statement.
- *
- **************************************/
-	if (node->nod_count)
-	{
-	    const TEXT* ptr = NULL;
-		Firebird::VaryStr<80> temp;
-		const USHORT l =
-			MOVQ_get_string(EVAL_value(node->nod_arg[0]), &ptr, &temp, sizeof(temp));
-
-		UCHAR msg[128];
-		MOVQ_terminate(ptr, (SCHAR*) msg, l, sizeof(msg));
-		ERRQ_error(40, SafeArg() << msg);
-		// Msg40 Request terminated by statement: %s
-	}
-
-	IBERROR(41);				// Msg41 Request terminated by statement
-}
-
-
-static void execute_assignment( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ a s s i g n m e n t
- *
- **************************************
- *
- * Functional description
- *
- **************************************/
-	if (node->nod_flags & NOD_remote)
-		return;
-
-	qli_nod* to = node->nod_arg[e_asn_to];
-	qli_nod* from = node->nod_arg[e_asn_from];
-	qli_nod* initial = node->nod_arg[e_asn_initial];
-
-	qli_par* parameter;
-	if (to->nod_type == nod_field)
-	{
-		qli_nod* reference = to->nod_arg[e_fld_reference];
-		parameter = reference->nod_import;
-		if (to->nod_desc.dsc_dtype == dtype_blob && from->nod_desc.dsc_dtype == dtype_blob &&
-			copy_blob(from, parameter))
-		{
-			return;
-		}
-	}
-	else
-		parameter = node->nod_import;
-
-	if (parameter)
-		parameter = parameter->par_missing;
-
-	assignment(from, EVAL_value(to), node->nod_arg[e_asn_valid], initial, parameter);
-
-	// propagate the missing flag in variable assignments
-
-	if (to->nod_type == nod_variable)
-	{
-		qli_fld* field = (qli_fld*) to->nod_arg[e_fld_field];
-		if (to->nod_desc.dsc_missing & DSC_missing)
-			field->fld_flags |= FLD_missing;
-		else
-			field->fld_flags &= ~FLD_missing;
-	}
-}
-
-
-static void execute_for( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ f o r
- *
- **************************************
- *
- * Functional description
- *	Execute a FOR loop.  This may require that a request get
- *	started, a message sent, and a message received for each
- *	record.  At the other end of the spectrum, there may be
- *	absolutely nothing to do.
- *
- **************************************/
-
-	// If there is a request associated  with the node, start it and possibly
-	// send a message along with it.
-
-	qli_req* request = (qli_req*) node->nod_arg[e_for_request];
-	if (request)
-		EXEC_start_request(request, (qli_msg*) node->nod_arg[e_for_send]);
-	else
-	{
-	    qli_msg* amessage = (qli_msg*) node->nod_arg[e_for_send];
-		if (amessage)
-			EXEC_send(amessage);
-	}
-
-	// If there isn't a receive message, the body of the loop has been
-	// optimized out of existence.  So skip it.
-
-	qli_msg* message = (qli_msg*) node->nod_arg[e_for_receive];
-	if (!message)
-		goto count;
-
-	// Receive messages in a loop until the end of file field comes up true.
-
-	while (true)
-	{
-		dsc* desc = EXEC_receive(message, (qli_par*) node->nod_arg[e_for_eof]);
-		if (*(USHORT *) desc->dsc_address)
-			break;
-		EXEC_execute(node->nod_arg[e_for_statement]);
-		if (request && request->req_continue)
-			EXEC_send(request->req_continue);
-	}
-
-  count:
-	if (QLI_count)
-		print_counts(request);
-}
-
-
-static void execute_modify( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ m o d i f y
- *
- **************************************
- *
- * Functional description
- *	Execute a modify statement.  This probably involves sending a
- *	message to the running request and executing a sub-statement.
- *
- **************************************/
-	if (node->nod_flags & NOD_remote)
-		return;
-
-	qli_msg* message = (qli_msg*) node->nod_arg[e_mod_send];
-	if (message)
-		set_null(message);
-
-	EXEC_execute(node->nod_arg[e_mod_statement]);
-
-	if (message)
-		EXEC_send(message);
-}
-
-
-static void execute_output( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ o u t p u t
- *
- **************************************
- *
- * Functional description
- *	Open output stream to re-direct output.
- *
- **************************************/
-	qli_prt* print = (qli_prt*) node->nod_arg[e_out_print];
-	print->prt_file = EXEC_open_output(node);
-
-	// Set up error handling
-
-	try {
-		// Finally, execute the query
-		EXEC_execute(node->nod_arg[e_out_statement]);
-		fclose(print->prt_file);
-
-	}
-	catch (const Firebird::Exception&)
-	{
-		if (print->prt_file) {
-			fclose(print->prt_file);
-		}
-		throw;
-	}
-}
-
-
-static void execute_print( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ p r i n t
- *
- **************************************
- *
- * Functional description
- *	Execute a print statement.  Since the loop has been factored
- *	out, this should be easy.
- *
- **************************************/
-
-	if (node->nod_arg[e_prt_header])
-	{
-		FMT_put((TEXT*) node->nod_arg[e_prt_header], (qli_prt*) node->nod_arg[e_prt_output]);
-		node->nod_arg[e_prt_header] = NULL;
-	}
-
-	FMT_print(node->nod_arg[e_prt_list], (qli_prt*) node->nod_arg[e_prt_output]);
-}
-
-
-static void execute_repeat( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ r e p e a t
- *
- **************************************
- *
- * Functional description
- *	Execute a REPEAT statement.  In short, loop.
- *
- **************************************/
-	SLONG count = MOVQ_get_long(EVAL_value(node->nod_arg[e_rpt_value]), 0);
-
-	while (--count >= 0)
-		EXEC_execute(node->nod_arg[e_rpt_statement]);
-}
-
-
-static void execute_store( qli_nod* node)
-{
-/**************************************
- *
- *	e x e c u t e _ s t o r e
- *
- **************************************
- *
- * Functional description
- *	Execute a STORE statement.  This may involve starting
- *	a request, sending a message, and executing a sub-statement.
- *	On the other hand, it may be a mody no-op if the statement
- *	is part of another request and doesn't need any data from
- *	here.
- *
- **************************************/
-	qli_msg* message = (qli_msg*) node->nod_arg[e_sto_send];
-	if (message)
-		set_null(message);
-
-	if (!(node->nod_flags & NOD_remote))
-		EXEC_execute(node->nod_arg[e_sto_statement]);
-
-	// If there is a request associated  with the node, start it and possibly
-	// send a message along with it.
-
-	qli_req* request = (qli_req*) node->nod_arg[e_sto_request];
-	if (request)
-		EXEC_start_request(request, (qli_msg*) node->nod_arg[e_sto_send]);
-	else if (message)
-		EXEC_send(message);
-
-	if (QLI_count)
-		print_counts(request);
-}
-
-
-static void map_data( qli_msg* message)
-{
-/**************************************
- *
- *	m a p _ d a t a
- *
- **************************************
- *
- * Functional description
- *	Map data to a message in preparation for sending.
- *
- **************************************/
-	for (qli_par* parameter = message->msg_parameters; parameter; parameter = parameter->par_next)
-	{
-		dsc* desc = &parameter->par_desc;
-		desc->dsc_address = message->msg_buffer + parameter->par_offset;
-		QLI_validate_desc(desc);
-		qli_par* missing_parameter = parameter->par_missing;
-		if (missing_parameter)
-		{
-			USHORT* missing_flag = (USHORT*) (message->msg_buffer + missing_parameter->par_offset);
-			*missing_flag = (desc->dsc_missing & DSC_missing) ? DSC_missing : 0;
-		}
-
-		qli_nod* from = parameter->par_value;
-		if (desc->dsc_dtype == dtype_blob && copy_blob(from, parameter))
-			continue;
-		assignment(from, desc, 0, 0, parameter->par_missing);
-	}
-}
-
-
-static void print_counts( qli_req* request)
-{
-/**************************************
- *
- *	p r i n t _ c o u n t s
- *
- **************************************
- *
- * Functional description
- *	Print out the count of records affected
- *	by the last statement.
- *
- **************************************/
-	ISC_STATUS_ARRAY status_vector;
-
-	UCHAR count_buffer[COUNT_ITEMS * 7 + 1];
-	if (isc_request_info(status_vector, &request->req_handle, 0,
-						  sizeof(count_info), count_info,
-						  sizeof(count_buffer), (SCHAR*) count_buffer))
-	{
-		return;
-	}
-
-	// print out the counts of any records affected
-
-	int length = 0;
-	for (const UCHAR* c = count_buffer; *c != isc_info_end; c += length)
-	{
-		const UCHAR item = *c++;
-		length = gds__vax_integer(c, 2);
-		c += 2;
-		const ULONG number = gds__vax_integer(c, length);
-
-		if (number)
-			switch (item)
-			{
-			case isc_info_req_select_count:
-				printf("\nrecords selected: %" ULONGFORMAT"\n", number);
-				break;
-
-			case isc_info_req_insert_count:
-				printf("records inserted: %" ULONGFORMAT"\n", number);
-				break;
-
-			case isc_info_req_update_count:
-				printf("records updated: %" ULONGFORMAT"\n", number);
-				break;
-
-			case isc_info_req_delete_count:
-				printf("records deleted: %" ULONGFORMAT"\n", number);
-				break;
-
-			default:
-				return;
-			}
-	}
-}
-
-
-static void set_null( qli_msg* message)
-{
-/**************************************
- *
- *	s e t _ n u l l
- *
- **************************************
- *
- * Functional description
- *	Set all parameters of an outgoing
- *	message to null - this allows conditional
- *	assignments to work in store and modify
- *	statements.
- *
- **************************************/
-	for (qli_par* parameter = message->msg_parameters; parameter; parameter = parameter->par_next)
-	{
-		qli_nod* from = parameter->par_value;
-		if (from->nod_type == nod_field)
-		{
-			dsc* desc = EVAL_value(from);
-			desc->dsc_missing |= DSC_missing;
-		}
-		else
-			from->nod_desc.dsc_missing |= DSC_missing;
-	}
-}
-
-
-
-static void transaction_state( qli_nod* node, qli_dbb* database)
-{
-/**************************************
- *
- *	t r a n s a c t i o n _ s t a t e
- *
- **************************************
- *
- * Functional description
- *
- *	set the state of the working transaction
- *	in a particular database to prepared or
- *	committed.
- *
- **************************************/
-	ISC_STATUS_ARRAY status;
-
-	if (database->dbb_transaction)
-	{
-		if (node->nod_type == nod_commit_retaining)
-		{
-			if (isc_commit_retaining(status, &database->dbb_transaction))
-				ERRQ_database_error(database, status);
-		}
-		else if (node->nod_type == nod_prepare)
-		{
-			if (isc_prepare_transaction(status, &database->dbb_transaction))
-				ERRQ_database_error(database, status);
-		}
-	}
-}
-
-
diff --git a/src/qli/exe.h b/src/qli/exe.h
deleted file mode 100644
index cfc0a11ca1..0000000000
--- a/src/qli/exe.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		exe.h
- *	DESCRIPTION:	Execution struct definitions
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_EXE_H
-#define QLI_EXE_H
-
-// Request Language Block  -- used for BLR, DYN, SDL, etc.
-
-struct qli_rlb
-{
-    blk		rlb_header;
-    UCHAR	*rlb_data;		// Pointer to end of BLR/DYN/SDL
-    UCHAR	*rlb_base;		// Pointer to start of buffer
-    UCHAR	*rlb_limit;		// Upper limit of string
-    USHORT	rlb_length;		// Length of string
-};
-
-// RLB manipulation macros
-const USHORT RLB_BUFFER_SIZE	= 2048;
-const USHORT RLB_SAFETY_MARGIN	= 48;
-
-#define STUFF(blr)	*rlb->rlb_data++ = blr
-#define STUFF_WORD(blr)	{STUFF (blr); STUFF (blr >> 8);}
-
-struct qli_msg; // forward decl.
-
-
-// Request block
-
-struct qli_req
-{
-    blk				req_header;
-    qli_req*		req_next;		// Next request in statement
-    qli_dbb*		req_database;	// Database for request
-    FB_API_HANDLE	req_handle;		// Database request handle
-    qli_rlb*		req_blr;
-    qli_msg*		req_messages;	// Messages associated with request
-    qli_msg*		req_receive;	// Current receive message, if any
-    qli_msg*		req_send;		// Current send message, if any
-    qli_msg*		req_continue;	// Message to continue FOR loop after optional actions
-    USHORT			req_flags;		// Flags for state of request compilation, etc.
-    USHORT			req_context;	// Next available context
-    USHORT			req_msg_number;	// Next available message number
-    USHORT			req_label;		// Next available label
-};
-
-// req_flags
-const USHORT REQ_rse_compiled	= 1;
-const USHORT REQ_project		= 2;	// Set during generation of project clause
-const USHORT REQ_group_by		= 4;	// Set during generation of group by clause
-
-
-struct qli_nod;
-
-// Context node
-
-enum CTX_T {
-    CTX_RELATION,
-    CTX_VARIABLE,
-    CTX_AGGREGATE,
-    //CTX_UNION,
-    CTX_STREAM
-};
-
-struct qli_ctx
-{
-    blk				ctx_header;
-    CTX_T			ctx_type;		// Type of context
-    qli_ctx*		ctx_source;		// Source context for MODIFY
-    qli_ctx*		ctx_primary;	// Primary context
-    qli_symbol*		ctx_symbol;		// Context symbol, if any
-    struct qli_rel*	ctx_relation;	// Relation of context
-    qli_nod*		ctx_stream;		// Stream of context
-    struct qli_fld*	ctx_variable;	// Variable reference
-    qli_req*		ctx_request;	// Request block
-    qli_msg*		ctx_message;	// Message for data
-    qli_nod*		ctx_rse;		// RSE node for root context
-    qli_nod*		ctx_sub_rse;	// RSE node aggregate
-    qli_ctx*		ctx_parent;		// Parent context for map
-    struct qli_map*	ctx_map;		// Map items, if any
-    USHORT			ctx_context;	// Context in request
-};
-
-// Aggregate/union map block
-
-struct qli_map
-{
-    blk			map_header;
-	qli_map*	map_next;			// Next map in item
-    qli_nod*	map_node;			// Value for map item
-    USHORT		map_position;		// Position in map
-};
-
-// Message block
-
-struct qli_msg
-{
-    blk			msg_header;
-    qli_req*	msg_request;		// Parent request
-    //qli_ctx*	msg_context;		// Contexts in message
-    qli_msg*	msg_next;			// Next message in request
-    struct qli_par*	msg_parameters;	// Field instances
-    USHORT		msg_number;			// Message number
-    USHORT		msg_length;			// Message length
-    USHORT		msg_parameter;		// Next parameter number
-    UCHAR*		msg_buffer;			// Message buffer
-};
-
-// Parameter block
-
-struct qli_par
-{
-	blk			par_header;
-	dsc			par_desc;			// Value descriptor
-	qli_par*	par_next;			// Next par block in context
-	qli_msg*	par_message;		// Parent message
-	qli_nod*	par_value;			// Value
-	USHORT		par_parameter;		// Parameter number
-	USHORT		par_offset;			// Offset of parameter in message
-	qli_par*	par_missing;		// Parameter block for missing value
-};
-
-// Print item block
-
-enum itm_t
-{
-    item_value,
-    item_skip,
-    item_column,
-    item_tab,
-    item_space,
-    item_new_page,
-    item_column_header,
-    item_report_header
-};
-
-struct qli_print_item
-{
-    blk			itm_header;
-    qli_nod*	itm_value;
-    const TEXT*	itm_edit_string;
-    struct pics*	itm_picture;	// picture string block
-    const TEXT*	itm_query_header;
-    itm_t		itm_type;
-    USHORT		itm_flags;			// Misc flags and crud
-    UCHAR		itm_dtype;
-    UCHAR		itm_sub_type;
-    USHORT		itm_print_offset;
-    USHORT		itm_print_length;
-    USHORT		itm_header_offset;
-    USHORT		itm_header_length;
-    //USHORT	itm_header_segments;
-    USHORT		itm_count;			// Number of lines to skip
-    //USHORT	itm_column;			// Logical column number
-    FB_API_HANDLE itm_stream;
-    //USHORT		itm_kanji_fragment;	// JPN: last kanji on line border
-    //ISC_STATUS	itm_blob_status;	// JPN: status of the last blob fetch
-};
-
-// itm_flags
-const USHORT ITM_overlapped	= 1;			// Overlapped by another item
-
-// Print Control Block
-
-struct qli_prt
-{
-    blk		prt_header;
-    FILE*	prt_file;		// FILE pointer
-    struct qli_rpt*	prt_report;		// Report block (if report)
-    void	(*prt_new_page)(qli_prt*, bool);	// New page routine, if any
-    USHORT	prt_lines_per_page;
-    SSHORT	prt_lines_remaining;
-    USHORT	prt_page_number;
-};
-
-// General node blocks
-
-struct qli_nod
-{
-    blk			nod_header;
-    nod_t		nod_type;		// Type of node
-    dsc			nod_desc;		// Descriptor
-    qli_par*	nod_import;		// To pass random value
-    qli_par*	nod_export;		// To pass random value
-    SSHORT		nod_count;		// Number of arguments
-    UCHAR		nod_flags;
-    qli_nod* 	nod_arg[1];		// If you change this change blk.h too
-};
-
-// nod_flags
-const UCHAR NOD_local		= 1;	// locally computed expression
-const UCHAR NOD_remote		= 2;
-const UCHAR NOD_parameter2	= 4;	// generate a parameter2 if field
-const UCHAR nod_partial		= 8;
-const UCHAR nod_comparison	= 16;
-const UCHAR nod_date		= 32;	// node is a date operation, regardless
-
-// Execution node positions
-
-const int e_fld_field		= 0;	// field block
-const int e_fld_context		= 1;	// context for field
-const int e_fld_reference	= 2;	// points to parameter
-const int e_fld_subs		= 3;	// subscripts
-const int e_fld_count		= 4;
-
-const int e_for_request		= 0;	// Request to be started
-const int e_for_send		= 1;	// Message to be sent
-const int e_for_receive		= 2;	// Message to be received
-const int e_for_eof			= 3;	// End of file parameter
-const int e_for_rse			= 4;
-const int e_for_statement	= 5;
-const int e_for_count		= 6;
-
-const int e_itm_value		= 0;	// Value of print item
-const int e_itm_edit_string = 1;	// Edit string, if any
-const int e_itm_header		= 2;	// Query header, if any
-const int e_itm_count		= 3;
-
-const int e_rse_first		= 0;	// FIRST clause, if any
-const int e_rse_boolean		= 1;	// Boolean clause, if any
-const int e_rse_sort		= 2;	// Sort clause, if any
-const int e_rse_reduced		= 3;	// Reduced clause, if any
-const int e_rse_context		= 4;	// Context block
-const int e_rse_group_by	= 5;
-const int e_rse_having		= 6;
-const int e_rse_join_type	= 7;
-const int e_rse_count		= 8;
-
-const int e_prt_list		= 0;	// List of print items
-const int e_prt_file_name	= 1;	// Output file name
-const int e_prt_output		= 2;	// Output file
-const int e_prt_header		= 3;	// Header to be printed, if any
-const int e_prt_count		= 4;
-
-const int e_prm_prompt		= 0;	// Prompt string, if any
-const int e_prm_string		= 1;	// String node for data
-const int e_prm_next		= 2;	// Next prompt in statement
-const int e_prm_field		= 3;	// Prototype field, if known
-const int e_prm_count		= 4;
-
-const int e_sto_context		= 0;
-const int e_sto_statement	= 1;
-const int e_sto_request		= 2;
-const int e_sto_send		= 3;
-const int e_sto_count		= 4;
-
-const int e_asn_to			= 0;
-const int e_asn_from		= 1;
-const int e_asn_initial		= 2;
-const int e_asn_valid		= 3;	// Always second-to-last
-const int e_asn_count		= 4;
-
-const int e_mod_send		= 0;
-const int e_mod_statement	= 1;	// Sub-statement
-const int e_mod_request		= 2;	// Parent request for statement
-const int e_mod_count		= 3;
-
-const int e_era_context		= 0;
-const int e_era_request		= 1;	// Parent request for erase
-const int e_era_message		= 2;	// Message to be sent, if any
-const int e_era_count		= 3;
-
-const int e_any_request		= 0;	// Request to be started
-const int e_any_send		= 1;	// Message to be sent
-const int e_any_receive		= 2;	// Message to be received
-const int e_any_rse			= 3;
-const int e_any_count		= 4;
-
-const int e_rpt_value		= 0;
-const int e_rpt_statement	= 1;
-const int e_rpt_count		= 2;
-
-const int e_if_boolean		= 0;
-const int e_if_true			= 1;
-const int e_if_false		= 2;
-const int e_if_count		= 3;
-
-const int e_edt_input		= 0;
-const int e_edt_dbb			= 1;
-const int e_edt_id1			= 2;
-const int e_edt_id2			= 3;
-const int e_edt_name		= 4;
-const int e_edt_count		= 5;
-
-const int e_out_statement	= 0;
-const int e_out_file		= 1;
-const int e_out_pipe		= 2;
-const int e_out_print		= 3;
-const int e_out_count		= 4;
-
-const int e_fmt_value		= 0;
-const int e_fmt_edit		= 1;
-const int e_fmt_picture		= 2;
-const int e_fmt_count		= 3;
-
-// Statistical expression
-
-const int e_stt_rse			= 0;
-const int e_stt_value		= 1;
-const int e_stt_default		= 2;
-const int e_stt_request		= 3;	// Request to be started
-const int e_stt_send		= 4;	// Message to be sent
-const int e_stt_receive		= 5;	// Message to be received
-const int e_stt_count		= 6;
-
-const int e_map_context		= 0;
-const int e_map_map			= 1;
-const int e_map_count		= 2;
-
-const int e_ffr_form		= 0;
-const int e_ffr_statement	= 1;
-const int e_ffr_count		= 2;
-
-const int e_fup_form		= 0;
-const int e_fup_fields		= 1;
-const int e_fup_tag			= 2;
-const int e_fup_count		= 3;
-
-const int e_ffl_form		= 0;
-const int e_ffl_field		= 1;
-const int e_ffl_string		= 2;
-const int e_ffl_count		= 3;
-
-const int e_men_statements	= 0;
-const int e_men_labels		= 1;
-const int e_men_string		= 2;
-const int e_men_menu		= 4;
-const int e_men_count		= 5;
-
-const int e_fun_args		= 0;
-const int e_fun_function	= 1;
-const int e_fun_request		= 2;	// Request to be started
-const int e_fun_send		= 3;	// Message to be sent
-const int e_fun_receive		= 4;	// Message to be received
-const int e_fun_count		= 5;
-
-const int e_syn_statement	= 0;
-const int e_syn_send		= 1;
-const int e_syn_count		= 2;
-
-#endif // QLI_EXE_H
-
diff --git a/src/qli/exe_proto.h b/src/qli/exe_proto.h
deleted file mode 100644
index 85895f63ee..0000000000
--- a/src/qli/exe_proto.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		exe_proto.h
- *	DESCRIPTION:	Prototype header file for exe.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_EXE_PROTO_H
-#define QLI_EXE_PROTO_H
-
-void	EXEC_abort();
-void	EXEC_execute(qli_nod*);
-FB_API_HANDLE	EXEC_open_blob(qli_nod*);
-FILE*	EXEC_open_output(qli_nod*);
-void	EXEC_poll_abort();
-dsc*	EXEC_receive(qli_msg*, qli_par*);
-void	EXEC_send(qli_msg*);
-void	EXEC_start_request(qli_req*, qli_msg*);
-void	EXEC_top(qli_nod*);
-
-#endif // QLI_EXE_PROTO_H
-
diff --git a/src/qli/expan_proto.h b/src/qli/expan_proto.h
deleted file mode 100644
index 19b1dea98e..0000000000
--- a/src/qli/expan_proto.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		expan_proto.h
- *	DESCRIPTION:	Prototype header file for expand.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_EXPAN_PROTO_H
-#define QLI_EXPAN_PROTO_H
-
-qli_nod*	EXP_expand(qli_syntax*);
-
-#endif // QLI_EXPAN_PROTO_H
-
diff --git a/src/qli/expand.cpp b/src/qli/expand.cpp
deleted file mode 100644
index 487ec6a022..0000000000
--- a/src/qli/expand.cpp
+++ /dev/null
@@ -1,3040 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		expand.cpp
- *	DESCRIPTION:	Expand syntax tree -- first phase of compiler
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <string.h>
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "../qli/compile.h"
-#include "../qli/exe.h"
-#include "../qli/report.h"
-#include "../qli/all_proto.h"
-#include "../qli/comma_proto.h"
-#include "../qli/compi_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/expan_proto.h"
-#include "../qli/help_proto.h"
-#include "../qli/meta_proto.h"
-#include "../qli/show_proto.h"
-
-using MsgFormat::SafeArg;
-
-
-static bool compare_names(const qli_name*, const qli_symbol*);
-static bool compare_symbols(const qli_symbol*, const qli_symbol*);
-static qli_symbol* copy_symbol(const qli_symbol*);
-static void declare_global(qli_fld*, qli_syntax*);
-static qli_syntax* decompile_field(qli_fld*, qli_ctx*);
-static qli_name* decompile_symbol(qli_symbol*);
-static qli_nod* expand_assignment(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_any(qli_syntax*, qli_lls*);
-static qli_nod* expand_boolean(qli_syntax*, qli_lls*);
-static void expand_control_break(qli_brk**, qli_lls*);
-static void expand_distinct(qli_nod*, qli_nod*);
-static void expand_edit_string(qli_nod*, qli_print_item*);
-static qli_nod* expand_erase(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_expression(qli_syntax*, qli_lls*);
-static qli_nod* expand_field(qli_syntax*, qli_lls*, qli_syntax*);
-static qli_nod* expand_for(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_function(qli_syntax*, qli_lls*);
-static qli_nod* expand_group_by(qli_syntax*, qli_lls*, qli_ctx*);
-static qli_nod* expand_modify(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_output(qli_syntax*, qli_lls*, qli_prt**);
-static qli_nod* expand_print(qli_syntax*, qli_lls*, qli_lls*);
-static qli_print_item* expand_print_item(qli_syntax*, qli_lls*);
-static qli_nod* expand_print_list(qli_syntax*, qli_lls*);
-static qli_nod* expand_report(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_restructure(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_rse(qli_syntax*, qli_lls**);
-static qli_nod* expand_sort(qli_syntax*, qli_lls*, qli_nod*);
-static qli_nod* expand_statement(qli_syntax*, qli_lls*, qli_lls*);
-static qli_nod* expand_store(qli_syntax*, qli_lls*, qli_lls*);
-static void expand_values(qli_syntax*, qli_lls*);
-static qli_ctx* find_context(const qli_name*, qli_lls*);
-static int generate_fields(qli_ctx*, qli_lls*, qli_syntax*);
-static int generate_items(const qli_syntax*, qli_lls*, qli_lls*, qli_nod*);
-static bool global_agg(const qli_syntax*, const qli_syntax*);
-static bool invalid_nod_field(const qli_nod*, const qli_nod*);
-static bool invalid_syn_field(const qli_syntax*, const qli_syntax*);
-static qli_nod* make_and(qli_nod*, qli_nod*);
-static qli_nod* make_assignment(qli_nod*, qli_nod*, qli_lls*);
-static qli_nod* make_field(qli_fld*, qli_ctx*);
-static qli_nod* make_list(qli_lls*);
-static qli_nod* make_node(nod_t, USHORT);
-static qli_nod* negate(qli_nod*);
-static qli_nod* possible_literal(qli_syntax*, qli_lls*, bool);
-static qli_nod* post_map(qli_nod*, qli_ctx*);
-static qli_fld* resolve(qli_syntax*, qli_lls*, qli_ctx**);
-static void resolve_really(qli_fld*, const qli_syntax*);
-
-static qli_lls* global_output_stack;
-
-
-qli_nod* EXP_expand( qli_syntax* node)
-{
-/**************************************
- *
- *	E X P _ e x p a n d
- *
- **************************************
- *
- * Functional description
- *	Expand a syntax tree into something richer and more complete.
- *
- **************************************/
-	switch (node->syn_type)
-	{
-	case nod_commit:
-	case nod_prepare:
-	case nod_rollback:
-		CMD_transaction(node);
-		return NULL;
-
-	case nod_copy_proc:
-		CMD_copy_procedure(node);
-		return NULL;
-
-	case nod_declare:
-		declare_global((qli_fld*) node->syn_arg[0], node->syn_arg[1]);
-		return NULL;
-
-	case nod_define:
-		CMD_define_procedure(node);
-		return NULL;
-
-	case nod_delete_proc:
-		CMD_delete_proc(node);
-		return NULL;
-
-	case nod_def_database:
-	case nod_sql_database:
-		MET_ready(node, true);
-		return NULL;
-
-	case nod_def_field:
-		MET_define_field((qli_dbb*) node->syn_arg[0], (qli_fld*) node->syn_arg[1]);
-		return NULL;
-
-	case nod_def_index:
-		MET_define_index(node);
-		return NULL;
-
-	case nod_def_relation:
-		MET_define_relation((qli_rel*)node->syn_arg[0], (qli_rel*) node->syn_arg[1]);
-		return NULL;
-
-	case nod_del_relation:
-		MET_delete_relation((qli_rel*)node->syn_arg[0]);
-		return NULL;
-
-	case nod_del_field:
-		MET_delete_field((qli_dbb*)node->syn_arg[0], (qli_name*) node->syn_arg[1]);
-		return NULL;
-
-	case nod_del_index:
-		MET_delete_index((qli_dbb*)node->syn_arg[0], (qli_name*) node->syn_arg[1]);
-		return NULL;
-
-	case nod_del_database:
-		MET_delete_database((qli_dbb*)node->syn_arg[0]);
-		return NULL;
-
-	case nod_edit_proc:
-		CMD_edit_proc(node);
-		return NULL;
-	case nod_extract:
-		node->syn_arg[1] = (qli_syntax*) expand_output(node->syn_arg[1], 0, 0);
-		CMD_extract(node);
-		return NULL;
-
-	case nod_finish:
-		CMD_finish(node);
-		return NULL;
-
-	case nod_help:
-		HELP_help(node);
-		return NULL;
-
-	case nod_mod_field:
-		MET_modify_field((qli_dbb*)node->syn_arg[0], (qli_fld*) node->syn_arg[1]);
-		return NULL;
-
-	case nod_mod_relation:
-		MET_modify_relation((qli_rel*) node->syn_arg[0], (qli_fld*) node->syn_arg[1]);
-		return NULL;
-
-	case nod_mod_index:
-		MET_modify_index(node);
-		return NULL;
-
-	case nod_ready:
-		MET_ready(node, false);
-		return NULL;
-
-	case nod_rename_proc:
-		CMD_rename_proc(node);
-		return NULL;
-
-	case nod_set:
-		CMD_set(node);
-		return NULL;
-
-	case nod_show:
-		SHOW_stuff(node);
-		return NULL;
-
-	case nod_shell:
-		CMD_shell(node);
-		return NULL;
-
-	case nod_sql_grant:
-		MET_sql_grant(node);
-		return NULL;
-
-	case nod_sql_revoke:
-		MET_sql_revoke(node);
-		return NULL;
-
-	case nod_sql_cr_table:
-		MET_define_sql_relation((qli_rel*) node->syn_arg[0]);
-		return NULL;
-
-    //case nod_sql_cr_view:
-	//	MET_sql_cr_view (node);
-	//	GEN_release();
-	//	return NULL;
-
-	case nod_sql_al_table:
-		MET_sql_alter_table((qli_rel*) node->syn_arg[0], (qli_fld*) node->syn_arg[1]);
-		return NULL;
-	} // end switch, no default case for error
-
-	// If there are any variables, make up a context now
-
-	global_output_stack = NULL;
-	qli_lls* right = NULL;
-	qli_lls* left = NULL;
-
-	if (QLI_variables)
-	{
-		qli_ctx* context = (qli_ctx*) ALLOCD(type_ctx);
-		context->ctx_type = CTX_VARIABLE;
-		context->ctx_variable = QLI_variables;
-		ALLQ_push((blk*) context, &right);
-		ALLQ_push((blk*) context, &left);
-	}
-
-	qli_nod* expanded = expand_statement(node, right, left);
-	if (!expanded)
-		return NULL;
-
-	while (global_output_stack)
-	{
-		qli_nod* output = (qli_nod*) ALLQ_pop(&global_output_stack);
-		output->nod_arg[e_out_statement] = expanded;
-		expanded = output;
-	}
-
-	return expanded;
-}
-
-
-static bool compare_names( const qli_name* name, const qli_symbol* symbol)
-{
-/**************************************
- *
- *	c o m p a r e _ n a m e s
- *
- **************************************
- *
- * Functional description
- *	Compare a name node to a symbol.  If they are equal, return true.
- *
- **************************************/
-	if (!symbol)
-		return false;
-
-	const int l = name->nam_length;
-	if (l != symbol->sym_length)
-		return false;
-
-	if (l)
-		return memcmp(symbol->sym_string, name->nam_string, l) == 0;
-
-	return true;
-}
-
-
-static bool compare_symbols( const qli_symbol* symbol1, const qli_symbol* symbol2)
-{
-/**************************************
- *
- *	c o m p a r e _ s y m b o l s
- *
- **************************************
- *
- * Functional description
- *	Compare two symbols (either may be 0).
- *
- **************************************/
-	if (!symbol1 || !symbol2)
-		return false;
-
-	const int l = symbol1->sym_length;
-	if (l != symbol2->sym_length)
-		return false;
-
-	if (l)
-		return memcmp(symbol1->sym_string, symbol2->sym_string, l) == 0;
-
-	return true;
-}
-
-
-static qli_symbol* copy_symbol( const qli_symbol* old)
-{
-/**************************************
- *
- *	c o p y _ s y m b o l
- *
- **************************************
- *
- * Functional description
- *	Copy a symbol into the permanent pool.
- *
- **************************************/
-	qli_symbol* new_sym = (qli_symbol*) ALLOCPV(type_sym, old->sym_length);
-	new_sym->sym_length = old->sym_length;
-	new_sym->sym_type = old->sym_type;
-	new_sym->sym_string = new_sym->sym_name;
-	strcpy(new_sym->sym_name, old->sym_name);
-
-	return new_sym;
-}
-
-
-static void declare_global( qli_fld* variable, qli_syntax* field_node)
-{
-/**************************************
- *
- *	d e c l a r e _ g l o b a l
- *
- **************************************
- *
- * Functional description
- *	Copy a variable block into the permanent pool as a field.
- *	Resolve BASED_ON references.
- *	Allocate all strings off the field block.
- *
- **************************************/
-
-	// If it's based_on, flesh it out & check datatype.
-
-	if (field_node)
-	{
-		if (field_node->syn_type == nod_index)
-			field_node = field_node->syn_arg[s_idx_field];
-		resolve_really(variable, field_node);
-		if (variable->fld_dtype == dtype_blob)
-			IBERROR(137);		// Msg137 variables may not be based on blob fields.
-	}
-
-	// Get rid of any other variables of the same name
-
-	qli_fld* field;
-	for (qli_fld** ptr = &QLI_variables; field = *ptr; ptr = &field->fld_next)
-		if (!strcmp(field->fld_name->sym_string, variable->fld_name->sym_string))
-		{
-			*ptr = field->fld_next;
-			ALLQ_release((qli_frb*) field->fld_name);
-			if (field->fld_query_name)
-				ALLQ_release((qli_frb*) field->fld_query_name);
-			ALLQ_release((qli_frb*) field);
-			break;
-		}
-
-	// Next, copy temporary field block into permanent pool.  Fold edit_string
-	//   query_header into main block to save space and complexity.
-
-	const TEXT* q;
-	USHORT l = variable->fld_length;
-	if (q = variable->fld_edit_string)
-		l += static_cast<USHORT>(strlen(q));
-	if (q = variable->fld_query_header)
-		l += static_cast<USHORT>(strlen(q));
-
-	qli_fld* new_fld = (qli_fld*) ALLOCPV(type_fld, l);
-	new_fld->fld_name = copy_symbol(variable->fld_name);
-	new_fld->fld_dtype = variable->fld_dtype;
-	new_fld->fld_length = variable->fld_length;
-	new_fld->fld_scale = variable->fld_scale;
-	new_fld->fld_sub_type = variable->fld_sub_type;
-	new_fld->fld_sub_type_missing = variable->fld_sub_type_missing;
-	new_fld->fld_flags = variable->fld_flags | FLD_missing;
-
-	// Copy query_name, edit string, query header
-
-	TEXT* p = (TEXT*) new_fld->fld_data + new_fld->fld_length;
-	if (q = variable->fld_edit_string)
-	{
-		new_fld->fld_edit_string = p;
-		while (*p++ = *q++);
-	}
-	if (variable->fld_query_name)
-		new_fld->fld_query_name = copy_symbol(variable->fld_query_name);
-	if (q = variable->fld_query_header)
-	{
-		new_fld->fld_query_header = p;
-		while (*p++ = *q++);
-	}
-
-	// Link new variable into variable chain
-
-	new_fld->fld_next = QLI_variables;
-	QLI_variables = new_fld;
-}
-
-
-static qli_syntax* decompile_field( qli_fld* field, qli_ctx* context)
-{
-/**************************************
- *
- *	d e c o m p i l e _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Take a perfectly good, completely compiled
- *	field block and regress to a qli_syntax node and
- *	and a qli_name block.
- *	(Needed to support SQL idiocies)
- *
- **************************************/
-	const int args = context ? 2 : 1;
-
-	qli_syntax* node = (qli_syntax*) ALLOCDV(type_syn, args);
-	node->syn_type = nod_field;
-	node->syn_count = args;
-
-	qli_name* name = decompile_symbol(field->fld_name);
-	node->syn_arg[0] = (qli_syntax*) name;
-
-	if (context)
-	{
-		node->syn_arg[1] = node->syn_arg[0];
-		if (context->ctx_symbol)
-			name = decompile_symbol(context->ctx_symbol);
-		else
-			name = decompile_symbol(context->ctx_relation->rel_symbol);
-		node->syn_arg[0] = (qli_syntax*) name;
-	}
-
-	return node;
-}
-
-
-static qli_name* decompile_symbol( qli_symbol* symbol)
-{
-/**************************************
- *
- *	d e c o m p i l e _ s y m b o l
- *
- **************************************
- *
- * Functional description
- *	Turn a symbol back into a name
- *	(Needed to support SQL idiocies)
- *
- **************************************/
-	const int l = symbol->sym_length;
-
-	qli_name* name = (qli_name*) ALLOCDV(type_nam, l);
-	name->nam_length = l;
-	name->nam_symbol = symbol;
-	if (l)
-		memcpy(name->nam_string, symbol->sym_string, l);
-
-	/*
-	TEXT* p = name->nam_string;
-	const TEXT* q = symbol->sym_string;
-
-	if (l)
-		do {
-			const TEXT c = *q++;
-			*p++ = c; //UPPER(c);
-
-		} while (--l);
-	*/
-
-	return name;
-}
-
-
-static qli_nod* expand_assignment( qli_syntax* input, qli_lls* right, qli_lls* left)
-{
-/**************************************
- *
- *	e x p a n d _ a s s i g n m e n t
- *
- **************************************
- *
- * Functional description
- *	Expand an assigment statement.  All in all, not too tough.
- *
- **************************************/
-	qli_nod* node = make_node(input->syn_type, e_asn_count);
-	qli_nod* to = expand_expression(input->syn_arg[s_asn_to], left);
-	node->nod_arg[e_asn_to] = to;
-	qli_nod* from = expand_expression(input->syn_arg[s_asn_from], right);
-	node->nod_arg[e_asn_from] = from;
-
-	if (to->nod_type == nod_field || to->nod_type == nod_variable)
-	{
-		qli_fld* field = (qli_fld*) to->nod_arg[e_fld_field];
-		if (field->fld_flags & FLD_computed)
-		{
-			ERRQ_print_error(138, field->fld_name->sym_string);
-			// Msg138 can't do assignment to computed field
-		}
-		if (from->nod_type == nod_prompt)
-			from->nod_arg[e_prm_field] = to->nod_arg[e_fld_field];
-		if (field->fld_validation)
-			node->nod_arg[e_asn_valid] = expand_expression(field->fld_validation, left);
-	}
-
-	if (!node->nod_arg[e_asn_valid])
-		--node->nod_count;
-
-	return node;
-}
-
-
-static qli_nod* expand_any( qli_syntax* input, qli_lls* stack)
-{
-/**************************************
- *
- *	e x p a n d _ a n y
- *
- **************************************
- *
- * Functional description
- *	Expand an any expression.  This would be trivial were it not
- *	for a funny SQL case when an expression needs to be checked
- *	for existence.
- *
- **************************************/
-	qli_nod* node = make_node(input->syn_type, e_any_count);
-	node->nod_count = 0;
-	qli_nod* rse = expand_rse(input->syn_arg[0], &stack);
-	node->nod_arg[e_any_rse] = rse;
-
-	if (input->syn_count >= 2 && input->syn_arg[1])
-	{
-		qli_nod* boolean = make_node(nod_missing, 1);
-		boolean->nod_arg[0] = expand_expression(input->syn_arg[1], stack);
-		qli_nod* negation = make_node(nod_not, 1);
-		negation->nod_arg[0] = boolean;
-		rse->nod_arg[e_rse_boolean] = make_and(rse->nod_arg[e_rse_boolean], negation);
-	}
-
-	return node;
-}
-
-
-static qli_nod* expand_boolean( qli_syntax* input, qli_lls* stack)
-{
-/**************************************
- *
- *	e x p a n d _ b o o l e a n
- *
- **************************************
- *
- * Functional description
- *	Expand a statement.
- *
- **************************************/
-	// Make node and process arguments
-
-	qli_nod* node = make_node(input->syn_type, input->syn_count);
-	qli_nod** ptr = node->nod_arg;
-	qli_nod* value = expand_expression(input->syn_arg[0], stack);
-	*ptr++ = value;
-
-	for (int i = 1; i < input->syn_count; i++, ptr++)
-	{
-		if (!(*ptr = possible_literal(input->syn_arg[i], stack, true)))
-			*ptr = expand_expression(input->syn_arg[i], stack);
-	}
-
-	// Try to match any prompts against fields to determine prompt length
-
-	if (value->nod_type != nod_field)
-		return node;
-
-	qli_fld* field = (qli_fld*) value->nod_arg[e_fld_field];
-	ptr = &node->nod_arg[1];
-
-	for (int i = 1; i < node->nod_count; i++, ptr++)
-	{
-		if ((*ptr)->nod_type == nod_prompt)
-			(*ptr)->nod_arg[e_prm_field] = (qli_nod*) field;
-	}
-
-	return node;
-}
-
-
-static void expand_control_break( qli_brk** ptr, qli_lls* right)
-{
-/**************************************
- *
- *	e x p a n d _ c o n t r o l _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Work on a report writer control break.  This is called recursively
- *	to handle multiple breaks.
- *
- **************************************/
-	qli_brk* list = NULL;
-
-	qli_brk* control;
-	while (control = *ptr)
-	{
-		*ptr = control->brk_next;
-		control->brk_next = list;
-		list = control;
-		if (control->brk_field)
-			control->brk_field = (qli_syntax*) expand_expression(control->brk_field, right);
-		if (control->brk_line)
-			control->brk_line = (qli_syntax*) expand_print_list(control->brk_line, right);
-	}
-
-	*ptr = list;
-}
-
-
-static void expand_distinct( qli_nod* rse, qli_nod* node)
-{
-/**************************************
- *
- *	e x p a n d _ d i s t i n c t
- *
- **************************************
- *
- * Functional description
- *	We have run into a distinct count.  Add a reduced
- *	clause to it's parent.
- *
- **************************************/
-	if (rse->nod_arg[e_rse_reduced])
-		return;
-
-	qli_lls* stack = NULL;
-	ALLQ_push((blk*) node, &stack);
-	ALLQ_push(0, &stack);
-	qli_nod* list = make_list(stack);
-	rse->nod_arg[e_rse_reduced] = list;
-	list->nod_count = 1;
-}
-
-
-static void expand_edit_string( qli_nod* node, qli_print_item* item)
-{
-/**************************************
- *
- *	e x p a n d _ e d i t _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Default edit_string and query_header.
- *
- **************************************/
-	switch (node->nod_type)
-	{
-	case nod_min:
-	case nod_rpt_min:
-	case nod_agg_min:
-		if (!item->itm_query_header)
-			item->itm_query_header = "MIN";
-
-	case nod_total:
-	case nod_running_total:
-	case nod_rpt_total:
-	case nod_agg_total:
-		if (!item->itm_query_header)
-			item->itm_query_header = "TOTAL";
-
-	case nod_average:
-	case nod_rpt_average:
-	case nod_agg_average:
-		if (!item->itm_query_header)
-			item->itm_query_header = "AVG";
-
-	case nod_max:
-	case nod_rpt_max:
-	case nod_agg_max:
-		if (!item->itm_query_header)
-			item->itm_query_header = "MAX";
-		expand_edit_string(node->nod_arg[e_stt_value], item);
-		return;
-
-	case nod_count:
-	case nod_running_count:
-	case nod_rpt_count:
-	case nod_agg_count:
-		if (!item->itm_edit_string)
-			item->itm_edit_string = "ZZZ,ZZZ,ZZ9";
-		if (!item->itm_query_header)
-			item->itm_query_header = "COUNT";
-		break;
-
-	case nod_map:
-		{
-			qli_map* map = (qli_map*) node->nod_arg[e_map_map];
-			expand_edit_string(map->map_node, item);
-		}
-		return;
-
-	case nod_field:
-	case nod_variable:
-		break;
-
-	case nod_function:
-		{
-			qli_fun* function = (qli_fun*) node->nod_arg[e_fun_function];
-			if (!item->itm_query_header)
-				item->itm_query_header = function->fun_symbol->sym_string;
-		}
-		return;
-
-	default:
-		return;
-	}
-
-	// Handle fields
-
-	qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-
-	if (!item->itm_edit_string)
-		item->itm_edit_string = field->fld_edit_string;
-
-	if (!item->itm_query_header)
-		if (!(item->itm_query_header = field->fld_query_header))
-			item->itm_query_header = field->fld_name->sym_string;
-}
-
-
-static qli_nod* expand_erase( qli_syntax* input, qli_lls* right, qli_lls* /*left*/)
-{
-/**************************************
- *
- *	e x p a n d _ e r a s e
- *
- **************************************
- *
- * Functional description
- *	Expand a statement.
- *
- **************************************/
-	qli_nod* loop = NULL;
-
-	// If there is an rse, make up a FOR loop
-
-	if (input->syn_arg[s_era_rse])
-	{
-		loop = make_node(nod_for, e_for_count);
-		loop->nod_arg[e_for_rse] = expand_rse(input->syn_arg[s_era_rse], &right);
-	}
-
-	// Loop thru contexts counting them.
-	int count = 0;
-	qli_ctx* context = NULL;
-	for (qli_lls* contexts = right; contexts; contexts = contexts->lls_next)
-	{
-		context = (qli_ctx*) contexts->lls_object;
-		if (context->ctx_variable)
-			continue;
-		count++;
-		if (context->ctx_rse)
-			break;
-	}
-
-	if (count == 0)
-		IBERROR(139);			// Msg139 no context for ERASE
-	else if (count > 1)
-		IBERROR(140);			// Msg140 can't erase from a join
-
-	// Make up node big enough to hold fixed fields plus all contexts
-
-	qli_nod* node = make_node(nod_erase, e_era_count);
-	node->nod_arg[e_era_context] = (qli_nod*) context;
-
-	if (!loop)
-		return node;
-
-	loop->nod_arg[e_for_statement] = node;
-
-	return loop;
-}
-
-
-static qli_nod* expand_expression( qli_syntax* input, qli_lls* stack)
-{
-/**************************************
- *
- *	e x p a n d _ e x p r e s s i o n
- *
- **************************************
- *
- * Functional description
- *	Expand an expression.
- *
- **************************************/
-	qli_nod* node;
-	qli_ctx* context;
-	qli_syntax* value;
-
-	switch (input->syn_type)
-	{
-	case nod_field:
-		return expand_field(input, stack, 0);
-
-	case nod_null:
-	case nod_user_name:
-		return make_node(input->syn_type, 0);
-
-	case nod_any:
-	case nod_unique:
-		return expand_any(input, stack);
-
-	case nod_max:
-	case nod_min:
-	case nod_count:
-	case nod_average:
-	case nod_total:
-	case nod_from:
-
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_count:
-	case nod_rpt_average:
-	case nod_rpt_total:
-
-	case nod_running_total:
-	case nod_running_count:
-		node = make_node(input->syn_type, e_stt_count);
-		if (value = input->syn_arg[s_stt_rse])
-			node->nod_arg[e_stt_rse] = expand_rse(value, &stack);
-		if (value = input->syn_arg[s_stt_value])
-			node->nod_arg[e_stt_value] = expand_expression(value, stack);
-		if (value = input->syn_arg[s_stt_default])
-			node->nod_arg[e_stt_default] = expand_expression(value, stack);
-		if (input->syn_arg[s_prt_distinct] && node->nod_arg[e_stt_rse] && node->nod_arg[e_stt_value])
-		{
-			expand_distinct(node->nod_arg[e_stt_rse], node->nod_arg[e_stt_value]);
-		}
-		// count2 next 2 lines go
-		if (input->syn_type == nod_count)
-			node->nod_arg[e_stt_value] = 0;
-		return node;
-
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_count:
-	case nod_agg_average:
-	case nod_agg_total:
-		node = make_node(input->syn_type, e_stt_count);
-		for (; stack; stack = stack->lls_next)
-		{
-			context = (qli_ctx*) stack->lls_object;
-			if (context->ctx_type == CTX_AGGREGATE)
-				break;
-		}
-		if (!stack)
-			ERRQ_print_error(454);
-			// could not resolve context for aggregate
-/* count2
-	if (value = input->syn_arg [s_stt_value])
-	    {
-	    node->nod_arg [e_stt_value] = expand_expression (value, stack->lls_next);
-	    if (input->syn_arg [s_prt_distinct])
-		expand_distinct (context->ctx_sub_rse, node->nod_arg [e_stt_value]);
-	    }
-*/
-		if ((value = input->syn_arg[s_stt_value]) &&
-			(input->syn_arg[s_prt_distinct] || (input->syn_type != nod_agg_count)))
-		{
-			node->nod_arg[e_stt_value] = expand_expression(value, stack->lls_next);
-			if (input->syn_arg[s_prt_distinct] ||
-				(input->syn_type == nod_agg_count && context->ctx_sub_rse))
-			{
-				expand_distinct(context->ctx_sub_rse, node->nod_arg[e_stt_value]);
-			}
-		}
-		return post_map(node, context);
-
-	case nod_index:
-		value = input->syn_arg[s_idx_field];
-		if (value->syn_type != nod_field)
-			IBERROR(466);		// Msg466 Only fields may be subscripted
-		return expand_field(value, stack, input->syn_arg[s_idx_subs]);
-
-	case nod_list:
-	case nod_upcase:
-	case nod_lowcase:
-
-	case nod_and:
-	case nod_or:
-	case nod_not:
-	case nod_missing:
-	case nod_add:
-	case nod_subtract:
-	case nod_multiply:
-	case nod_divide:
-	case nod_negate:
-	case nod_concatenate:
-	case nod_substr:
-		break;
-
-	case nod_eql:
-	case nod_neq:
-	case nod_gtr:
-	case nod_geq:
-	case nod_leq:
-	case nod_lss:
-	case nod_between:
-	case nod_matches:
-	case nod_sleuth:
-	case nod_like:
-	case nod_starts:
-	case nod_containing:
-		return expand_boolean(input, stack);
-
-	case nod_edit_blob:
-		node = make_node(input->syn_type, e_edt_count);
-		node->nod_count = 0;
-		if (input->syn_arg[0])
-		{
-			node->nod_count = 1;
-			node->nod_arg[0] = expand_expression(input->syn_arg[0], stack);
-		}
-		return node;
-
-	case nod_format:
-		node = make_node(input->syn_type, e_fmt_count);
-		node->nod_count = 1;
-		node->nod_arg[e_fmt_value] = expand_expression(input->syn_arg[s_fmt_value], stack);
-		node->nod_arg[e_fmt_edit] = (qli_nod*) input->syn_arg[s_fmt_edit];
-		return node;
-
-	case nod_function:
-		return expand_function(input, stack);
-
-	case nod_constant:
-		{
-			node = make_node(input->syn_type, 0);
-			qli_const* constant = (qli_const*) input->syn_arg[0];
-			node->nod_desc = constant->con_desc;
-		}
-		return node;
-
-	case nod_prompt:
-		node = make_node(input->syn_type, e_prm_count);
-		node->nod_arg[e_prm_prompt] = (qli_nod*) input->syn_arg[0];
-		return node;
-
-	case nod_star:
-		{
-			qli_name* name = (qli_name*) input->syn_arg[0];
-			ERRQ_print_error(141, name->nam_string);
-			// Msg141 can't be used when a single element is required
-		}
-
-	default:
-		ERRQ_bugcheck(135);			// Msg135 expand_expression: not yet implemented
-	}
-
-	node = make_node(input->syn_type, input->syn_count);
-	qli_nod** ptr = node->nod_arg;
-
-	for (int i = 0; i < input->syn_count; i++)
-		*ptr++ = expand_expression(input->syn_arg[i], stack);
-
-	return node;
-}
-
-
-static qli_nod* expand_field( qli_syntax* input, qli_lls* stack, qli_syntax* subs)
-{
-/**************************************
- *
- *	e x p a n d _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Expand a field reference.  Error if it can't be resolved.
- *	If the field belongs to a group by SQL expression, make
- *	sure it goes there.
- *
- **************************************/
-	qli_ctx* context;
-
-	qli_fld* field = resolve(input, stack, &context);
-	if (!field || (subs && (context->ctx_variable)))
-	{
-	    TEXT s[160];
-		TEXT* p = s;
-		const TEXT* const limit = p + sizeof(s) - 1;
-		for (USHORT i = 0; i < input->syn_count; i++)
-		{
-			qli_name* name = (qli_name*) input->syn_arg[i];
-			const TEXT* q = name->nam_string;
-			USHORT l = name->nam_length;
-			if (p < limit)
-			{
-				if (l)
-					do {
-						*p++ = *q++;
-					} while (--l && p < limit);
-				*p++ = '.';
-			}
-		}
-		*--p = 0;
-		if (field)
-			ERRQ_print_error(467, s);
-			// Msg467 "%s" is not a field and so may not be subscripted
-		else
-			ERRQ_print_error(142, s);
-			// Msg142 "%s" is undefined or used out of context
-	}
-
-	qli_nod* node = make_field(field, context);
-	if (subs)
-		node->nod_arg[e_fld_subs] = expand_expression(subs, stack);
-
-	qli_ctx* parent = NULL;
-	qli_lls* save_stack = stack;
-	for (; stack; stack = stack->lls_next)
-	{
-		parent = (qli_ctx*) stack->lls_object;
-		if (parent->ctx_type == CTX_AGGREGATE)
-			break;
-	}
-
-	if (!parent)
-		return node;
-
-	if (context->ctx_parent != parent)
-	{
-		// The parent context may be hidden because we are part of
-		// a stream context.  Check out this possibility.
-
-		for (; save_stack; save_stack = save_stack->lls_next)
-		{
-			qli_ctx* stream_context = (qli_ctx*) save_stack->lls_object;
-			if (stream_context->ctx_type != CTX_STREAM ||
-				stream_context->ctx_stream->nod_type != nod_rse)
-			{
-				continue;
-			}
-
-			qli_ctx** ptr = (qli_ctx**) stream_context->ctx_stream->nod_arg + e_rse_count;
-			const qli_ctx* const* const end = ptr + stream_context->ctx_stream->nod_count;
-			for (; ptr < end; ptr++)
-				if (*ptr == context)
-					break;
-			if (ptr < end && stream_context->ctx_parent == parent)
-				break;
-		}
-
-		if (!save_stack)
-			return node;
-	}
-
-	return post_map(node, parent);
-}
-
-
-static qli_nod* expand_for( qli_syntax* input, qli_lls* right, qli_lls* left)
-{
-/**************************************
- *
- *	e x p a n d _ f o r
- *
- **************************************
- *
- * Functional description
- *	Expand a statement.
- *
- **************************************/
-	qli_nod* node = make_node(input->syn_type, e_for_count);
-	node->nod_arg[e_for_rse] = expand_rse(input->syn_arg[s_for_rse], &right);
-	node->nod_arg[e_for_statement] = expand_statement(input->syn_arg[s_for_statement], right, left);
-
-	return node;
-}
-
-
-static qli_nod* expand_function( qli_syntax* input, qli_lls* stack)
-{
-/**************************************
- *
- *	e x p a n d _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	Expand a functionn reference.
- *	For a field or expression reference
- *	tied to a relation in a database
- *	use only that database.  For a variable
- *      reference, use any database that matches.
- *
- **************************************/
-	qli_symbol* symbol = 0;
-	qli_fun* function = 0;
-	qli_dbb* database = 0;
-
-	qli_nod* node = make_node(input->syn_type, e_fun_count);
-	node->nod_count = 1;
-	qli_ctx* context;
-	if (stack && (context = (qli_ctx*) stack->lls_object) && (context->ctx_type == CTX_RELATION))
-	{
-		if (context->ctx_primary)
-			context = context->ctx_primary;
-		database = context->ctx_relation->rel_database;
-		for (symbol = (qli_symbol*) input->syn_arg[s_fun_function]; symbol;
-			symbol = symbol->sym_homonym)
-		{
-			if (symbol->sym_type == SYM_function)
-			{
-				function = (qli_fun*) symbol->sym_object;
-				if (function->fun_database == database)
-					break;
-			}
-		}
-	}
-	else
-		for (database = QLI_databases; database; database = database->dbb_next)
-		{
-			for (symbol = (qli_symbol*) input->syn_arg[s_fun_function]; symbol;
-				 symbol = symbol->sym_homonym)
-			{
-				if (symbol->sym_type == SYM_function)
-				{
-					function = (qli_fun*) symbol->sym_object;
-					if (function->fun_database == database)
-						break;
-				}
-			}
-			if (symbol)
-				break;
-		}
-
-
-	if (!symbol)
-	{
-		symbol = (qli_symbol*) input->syn_arg[s_fun_function];
-		ERRQ_error(412, SafeArg() << symbol->sym_string << database->dbb_filename);
-	}
-
-	node->nod_arg[e_fun_function] = (qli_nod*) function;
-
-	node->nod_arg[e_fun_args] = expand_expression(input->syn_arg[s_fun_args], stack);
-
-	return node;
-}
-
-
-static qli_nod* expand_group_by( qli_syntax* input, qli_lls* stack, qli_ctx* context)
-{
-/**************************************
- *
- *	e x p a n d _ g r o u p _ b y
- *
- **************************************
- *
- * Functional description
- *	Expand a GROUP BY clause.
- *
- **************************************/
-	qli_nod* node = make_node(input->syn_type, input->syn_count);
-	qli_nod** ptr2 = node->nod_arg;
-
-	qli_syntax** ptr = input->syn_arg;
-	for (const qli_syntax* const* const end = ptr + input->syn_count; ptr < end; ptr++, ptr2++)
-	{
-		*ptr2 = expand_expression(*ptr, stack);
-		post_map(*ptr2, context);
-	}
-
-	return node;
-}
-
-
-static qli_nod* expand_modify( qli_syntax* input, qli_lls* right, qli_lls* left)
-{
-/**************************************
- *
- *	e x p a n d _ m o d i f y
- *
- **************************************
- *
- * Functional description
- *	Expand a statement.
- *
- **************************************/
-	qli_nod* loop = NULL;
-
-	// If there is an rse, make up a FOR loop
-
-	if (input->syn_arg[s_mod_rse])
-	{
-		loop = make_node(nod_for, e_for_count);
-		loop->nod_arg[e_for_rse] = expand_rse(input->syn_arg[s_mod_rse], &right);
-	}
-
-    qli_lls* contexts;
-
-	// Loop thru contexts counting them.
-	USHORT count = 0;
-	for (contexts = right; contexts; contexts = contexts->lls_next)
-	{
-		qli_ctx* context = (qli_ctx*) contexts->lls_object;
-		if (context->ctx_variable)
-			continue;
-		++count;
-		if (context->ctx_rse)
-			break;
-	}
-
-	if (!count)
-		IBERROR(148);			// Msg148 no context for modify
-
-	// Make up node big enough to hold fixed fields plus all contexts
-
-	qli_nod* node = make_node(nod_modify, (int) e_mod_count + count);
-	node->nod_count = count;
-	qli_nod** ptr = &node->nod_arg[e_mod_count];
-
-	// Loop thru contexts augmenting left context
-
-	for (contexts = right; contexts; contexts = contexts->lls_next)
-	{
-		qli_ctx* context = (qli_ctx*) contexts->lls_object;
-		if (context->ctx_variable)
-			continue;
-		qli_ctx* new_context = (qli_ctx*) ALLOCD(type_ctx);
-		*ptr++ = (qli_nod*) new_context;
-		new_context->ctx_type = CTX_RELATION;
-		new_context->ctx_source = context;
-		new_context->ctx_symbol = context->ctx_symbol;
-		new_context->ctx_relation = context->ctx_relation;
-		ALLQ_push((blk*) new_context, &left);
-		if (context->ctx_rse)
-			break;
-	}
-
-	// Process sub-statement, list of fields, or, sigh, none of the above
-
-	qli_syntax* syn_list;
-	if (input->syn_arg[s_mod_statement])
-		node->nod_arg[e_mod_statement] = expand_statement(input->syn_arg[s_mod_statement], right, left);
-	else if (syn_list = input->syn_arg[s_mod_list])
-	{
-		qli_nod* list = make_node(nod_list, syn_list->syn_count);
-		node->nod_arg[e_mod_statement] = list;
-
-		ptr = list->nod_arg;
-		qli_syntax** syn_ptr = syn_list->syn_arg;
-		for (USHORT i = 0; i < syn_list->syn_count; i++, syn_ptr++)
-		{
-			*ptr++ = make_assignment(expand_expression((qli_syntax*) *syn_ptr, left),
-									(qli_nod*) *syn_ptr, right);
-		}
-	}
-	else
-		IBERROR(149);			// Msg149 field list required for modify
-
-	if (!loop)
-		return node;
-
-	loop->nod_arg[e_for_statement] = node;
-
-	return loop;
-}
-
-
-static qli_nod* expand_output( qli_syntax* input, qli_lls* right, qli_prt** print)
-{
-/**************************************
- *
- *	e x p a n d _ o u t p u t
- *
- **************************************
- *
- * Functional description
- *	Handle the presence (or absence) of an output specification clause.
- *
- **************************************/
-	if (print)
-		*print = (qli_prt*) ALLOCD(type_prt);
-
-	if (!input)
-		return NULL;
-
-	qli_nod* output = make_node(nod_output, e_out_count);
-	ALLQ_push((blk*) output, &global_output_stack);
-
-    qli_nod* node = possible_literal(input->syn_arg[s_out_file], right, false);
-	if (!node)
-		node = expand_expression(input->syn_arg[s_out_file], right);
-
-	output->nod_arg[e_out_file] = node;
-	output->nod_arg[e_out_pipe] = (qli_nod*) input->syn_arg[s_out_pipe];
-
-	if (print)
-		output->nod_arg[e_out_print] = (qli_nod*) * print;
-
-	return output;
-}
-
-
-static qli_nod* expand_print( qli_syntax* input, qli_lls* right, qli_lls* /*left*/)
-{
-/**************************************
- *
- *	e x p a n d _ p r i n t
- *
- **************************************
- *
- * Functional description
- *	Expand a statement.
- *
- **************************************/
-	qli_syntax* syn_rse = input->syn_arg[s_prt_rse];
-	qli_lls* new_right = right;
-
-	// If an output file or pipe is present, make up an output node
-
-	qli_prt* print;
-	expand_output(input->syn_arg[s_prt_output], right, &print);
-
-	// If a record select expression is present, expand it and build a FOR
-	// statement.
-
-	qli_nod* loop = NULL;
-	qli_nod* rse = NULL;
-	if (syn_rse)
-	{
-		loop = make_node(nod_for, e_for_count);
-		loop->nod_arg[e_for_rse] = rse = expand_rse(syn_rse, &new_right);
-	}
-
-	// If there were any print items, process them now.  Look first for things that
-	// look like items, but are actually lists.  If there aren't items of any kind,
-	// pick up all fields in the relations from the record selection expression.
-	qli_lls* items = NULL;
-	USHORT count = 0;
-	qli_syntax* syn_list = input->syn_arg[s_prt_list];
-	if (syn_list)
-	{
-        qli_syntax** sub = syn_list->syn_arg;
-		for (const qli_syntax* const* const end = sub + syn_list->syn_count; sub < end; sub++)
-		{
-			const qli_syntax* syn_item;
-			if (((*sub)->syn_type == nod_print_item) &&
-				(syn_item = (*sub)->syn_arg[s_itm_value]) && (syn_item->syn_type == nod_star))
-			{
-				count += generate_items(syn_item, new_right, (qli_lls*) &items, rse);
-			}
-			else
-			{
-				ALLQ_push((blk*) expand_print_item(*sub, new_right), &items);
-				count++;
-			}
-		}
-	}
-	else if (syn_rse && (syn_list = syn_rse->syn_arg[s_rse_reduced]))
-	{
-        qli_syntax** sub = syn_list->syn_arg;
-		for (const qli_syntax* const* const end = sub + syn_list->syn_count; sub < end; sub += 2)
-		{
-			qli_print_item* item = (qli_print_item*) ALLOCD(type_itm);
-			item->itm_type = item_value;
-			item->itm_value = expand_expression(*sub, new_right);
-			expand_edit_string(item->itm_value, item);
-			ALLQ_push((blk*) item, &items);
-			count++;
-		}
-	}
-	else
-		for (; new_right; new_right = new_right->lls_next)
-		{
-			qli_ctx* context = (qli_ctx*) new_right->lls_object;
-			qli_rel* relation = context->ctx_relation;
-			if (!relation || context->ctx_sub_rse)
-				continue;
-			for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-			{
-				if ((field->fld_system_flag && field->fld_system_flag != relation->rel_system_flag) ||
-					field->fld_flags & FLD_array)
-				{
-					continue;
-				}
-				qli_nod* node = make_field(field, context);
-				if (rse && rse->nod_arg[e_rse_group_by] &&
-					invalid_nod_field(node, rse->nod_arg[e_rse_group_by]))
-				{
-					continue;
-				}
-				qli_print_item* item = (qli_print_item*) ALLOCD(type_itm);
-				item->itm_type = item_value;
-				item->itm_value = make_field(field, context);
-				expand_edit_string(item->itm_value, item);
-				ALLQ_push((blk*) item, &items);
-				count++;
-			}
-			if (rse = context->ctx_rse)
-				break;
-		}
-
-	// If no print object showed up, complain!
-
-	if (!count)
-		IBERROR(150);			// Msg150 No items in print list
-
-	// Build new print statement.  Unlike the syntax node, the print statement
-	// has only print items in it.
-
-	qli_nod* node = make_node(input->syn_type, e_prt_count);
-	qli_nod* list = make_list(items);
-	node->nod_arg[e_prt_list] = list;
-	node->nod_arg[e_prt_output] = (qli_nod*) print;
-
-	// If DISTINCT was requested, make up a reduced list.
-
-	if (rse && input->syn_arg[s_prt_distinct])
-	{
-		qli_nod* reduced = make_node(nod_list, list->nod_count * 2);
-		reduced->nod_count = 0;
-		qli_nod** ptr = reduced->nod_arg;
-		for (USHORT i = 0; i < list->nod_count; i++)
-		{
-			qli_print_item* item = (qli_print_item*) list->nod_arg[i];
-			if (item->itm_value)
-			{
-				*ptr++ = item->itm_value;
-				ptr++;
-				reduced->nod_count++;
-			}
-		}
-		if (reduced->nod_count)
-			rse->nod_arg[e_rse_reduced] = reduced;
-	}
-
-	// If a FOR loop was generated, splice it in here.
-
-	if (loop)
-	{
-		loop->nod_arg[e_for_statement] = node;
-		node = loop;
-		if (input->syn_arg[s_prt_order])
-			rse->nod_arg[e_rse_sort] = expand_sort(input->syn_arg[s_prt_order], new_right, list);
-	}
-
-	return node;
-}
-
-
-static qli_print_item* expand_print_item( qli_syntax* syn_item, qli_lls* right)
-{
-/**************************************
- *
- *	e x p a n d _ p r i n t _ i t e m
- *
- **************************************
- *
- * Functional description
- *	Expand a print item.  A print item can either be a value or a format
- *	specifier.
- *
- **************************************/
-	qli_print_item* item = (qli_print_item*) ALLOCD(type_itm);
-
-	switch (syn_item->syn_type)
-	{
-	case nod_print_item:
-		{
-			item->itm_type = item_value;
-			qli_syntax* syn_expr = syn_item->syn_arg[s_itm_value];
-			qli_nod* node = item->itm_value = expand_expression(syn_expr, right);
-			item->itm_edit_string = (TEXT*) syn_item->syn_arg[s_itm_edit_string];
-			item->itm_query_header = (TEXT*) syn_item->syn_arg[s_itm_header];
-			expand_edit_string(node, item);
-			return item;
-		}
-
-	case nod_column:
-		item->itm_type = item_column;
-		break;
-
-	case nod_tab:
-		item->itm_type = item_tab;
-		break;
-
-	case nod_space:
-		item->itm_type = item_space;
-		break;
-
-	case nod_skip:
-		item->itm_type = item_skip;
-		break;
-
-	case nod_new_page:
-		item->itm_type = item_new_page;
-		break;
-
-	case nod_column_header:
-		item->itm_type = item_column_header;
-		break;
-
-	case nod_report_header:
-		item->itm_type = item_report_header;
-		break;
-
-	}
-
-	item->itm_count = (IPTR) syn_item->syn_arg[0];
-	return item;
-}
-
-
-static qli_nod* expand_print_list( qli_syntax* input, qli_lls* stack)
-{
-/**************************************
- *
- *	e x p a n d _ p r i n t _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Expand a print list.
- *
- **************************************/
-	qli_lls* items = NULL;
-	qli_syntax** ptr = input->syn_arg;
-
-	for (const qli_syntax* const* const end = ptr + input->syn_count; ptr < end; ptr++)
-	{
-		ALLQ_push((blk*) expand_print_item(*ptr, stack), &items);
-	}
-
-	return make_list(items);
-}
-
-
-static qli_nod* expand_report( qli_syntax* input, qli_lls* right, qli_lls* /*left*/)
-{
-/**************************************
- *
- *	e x p a n d _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Expand a report specification.
- *
- **************************************/
-	qli_prt* print;
-
-	// Start by processing record selection expression
-
-	expand_output(input->syn_arg[s_prt_output], right, &print);
-	qli_rpt* report = print->prt_report = (qli_rpt*) input->syn_arg[s_prt_list];
-
-	if (!(print->prt_lines_per_page = report->rpt_lines))
-		print->prt_lines_per_page = QLI_lines;
-
-	if (!report->rpt_columns)
-		report->rpt_columns = QLI_columns;
-
-	qli_nod* loop = make_node(nod_report_loop, e_for_count);
-	loop->nod_arg[e_for_rse] = expand_rse(input->syn_arg[s_prt_rse], &right);
-	qli_nod* node = make_node(nod_report, e_prt_count);
-	loop->nod_arg[e_for_statement] = node;
-
-	node->nod_arg[e_prt_list] = (qli_nod*) report;
-	node->nod_arg[e_prt_output] = (qli_nod*) print;
-
-	// Process clauses where they exist
-
-	expand_control_break(&report->rpt_top_rpt, right);
-	expand_control_break(&report->rpt_top_page, right);
-	expand_control_break(&report->rpt_top_breaks, right);
-
-	qli_syntax* sub = (qli_syntax*) report->rpt_detail_line;
-	if (sub)
-		report->rpt_detail_line = expand_print_list(sub, right);
-
-	expand_control_break(&report->rpt_bottom_breaks, right);
-	expand_control_break(&report->rpt_bottom_page, right);
-	expand_control_break(&report->rpt_bottom_rpt, right);
-
-	return loop;
-}
-
-
-static qli_nod* expand_restructure( qli_syntax* input, qli_lls* right, qli_lls* /*left*/)
-{
-/**************************************
- *
- *	e x p a n d _ r e s t r u c t u r e
- *
- **************************************
- *
- * Functional description
- *	Transform a restructure statement into a FOR <rse> STORE.
- *
- **************************************/
-
-	// Make a FOR loop to drive the restructure
-
-	qli_nod* loop = make_node(nod_for, e_for_count);
-	loop->nod_arg[e_for_rse] = expand_rse(input->syn_arg[s_asn_from], &right);
-
-	// Make a STORE node.
-
-	qli_nod* node = make_node(nod_store, e_sto_count);
-	loop->nod_arg[e_for_statement] = node;
-	qli_syntax* rel_node = input->syn_arg[s_asn_to];
-	qli_ctx* context = (qli_ctx*) ALLOCD(type_ctx);
-	node->nod_arg[e_sto_context] = (qli_nod*) context;
-	context->ctx_type = CTX_RELATION;
-	context->ctx_rse = (qli_nod*) -1;
-	qli_rel* relation = context->ctx_relation = (qli_rel*) rel_node->syn_arg[s_rel_relation];
-
-	// If we don't already know about the relation, find out now.
-
-	if (!(relation->rel_flags & REL_fields))
-		MET_fields(relation);
-
-	// Match fields in target relation against fields in the input rse.  Fields
-	// may match on either name or query name.
-
-	qli_lls* stack = NULL;
-
-	for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-		if (!(field->fld_flags & FLD_computed))
-		{
-			for (qli_lls* search = right; search; search = search->lls_next)
-			{
-				qli_ctx* ctx = (qli_ctx*) search->lls_object;
-
-				// First look for an exact field name match
-
-				qli_fld* fld;
-				for (fld = ctx->ctx_relation->rel_fields; fld; fld = fld->fld_next)
-				{
-					if (compare_symbols(field->fld_name, fld->fld_name))
-						break;
-				}
-				// Next try, target field name matching source query name
-
-				if (!fld)
-					for (fld = ctx->ctx_relation->rel_fields; fld; fld = fld->fld_next)
-					{
-						if (compare_symbols(field->fld_name, fld->fld_query_name))
-							break;
-					}
-				// If nothing yet, look for any old match
-
-				if (!fld)
-					for (fld = ctx->ctx_relation->rel_fields; fld; fld = fld->fld_next)
-					{
-						if (compare_symbols(field-> fld_query_name, fld->fld_name) ||
-							compare_symbols(field->fld_query_name, fld->fld_query_name))
-						{
-								break;
-						}
-					}
-
-				if (fld)
-				{
-					qli_nod* assignment = make_node(nod_assign, e_asn_count);
-					assignment->nod_count = e_asn_count - 1;
-					assignment->nod_arg[e_asn_to] = make_field(field, context);
-					assignment->nod_arg[e_asn_from] = make_field(fld, ctx);
-					ALLQ_push((blk*) assignment, &stack);
-					goto found_field;
-				}
-
-				if (ctx->ctx_rse)
-					break;
-			}
-			found_field:;
-		}
-
-	node->nod_arg[e_sto_statement] = make_list(stack);
-
-	return loop;
-}
-
-
-static qli_nod* expand_rse( qli_syntax* input, qli_lls** stack)
-{
-/**************************************
- *
- *	e x p a n d _ r s e
- *
- **************************************
- *
- * Functional description
- *	Expand a record selection expression, returning an updated context
- *	stack.
- *
- **************************************/
-	qli_lls* old_stack = *stack;
-	qli_lls* new_stack = *stack;
-	qli_nod* boolean = NULL;
-	qli_nod* node = make_node(input->syn_type, (int) e_rse_count + input->syn_count);
-	node->nod_count = input->syn_count;
-	qli_nod** ptr2 = &node->nod_arg[e_rse_count];
-
-	// Decide whether or not this is a GROUP BY, real or imagined
-	// If it is, disallow normal field type references
-
-	qli_ctx* parent_context = NULL;
-	qli_nod* parent_rse = NULL;
-
-	if (input->syn_arg[s_rse_group_by] || input->syn_arg[s_rse_having])
-		parent_context = (qli_ctx*) ALLOCD(type_ctx);
-	qli_syntax* list = input->syn_arg[s_rse_list];
-	if (list)
-	{
-		for (USHORT i = 0; i < list->syn_count; i++)
-		{
-			const qli_syntax* value = list->syn_arg[i];
-			const qli_syntax* field = value->syn_arg[e_itm_value];
-			if (!field)
-				continue;
-
-			if (global_agg(field, input->syn_arg[s_rse_group_by]))
-			{
-				if (!parent_context)
-					parent_context = (qli_ctx*) ALLOCD(type_ctx);
-			}
-			else if (parent_context)
-			{
-				if (invalid_syn_field(field, input->syn_arg[s_rse_group_by]))
-					IBERROR(451);
-			}
-		}
-	}
-
-	if (parent_context)
-	{
-		parent_context->ctx_type = CTX_AGGREGATE;
-		parent_rse = make_node(nod_rse, e_rse_count + 1);
-		parent_rse->nod_count = 1;
-		parent_rse->nod_arg[e_rse_count] = (qli_nod*) parent_context;
-		parent_context->ctx_sub_rse = node;
-	}
-
-	// Process the FIRST clause before the context gets augmented
-
-	if (input->syn_arg[s_rse_first])
-		node->nod_arg[e_rse_first] = expand_expression(input->syn_arg[e_rse_first], old_stack);
-
-	// Process relations
-
-	qli_syntax** ptr = input->syn_arg + s_rse_count;
-
-	for (USHORT i = 0; i < input->syn_count; i++)
-	{
-		qli_syntax* rel_node = *ptr++;
-		qli_syntax* over = *ptr++;
-		qli_ctx* context = (qli_ctx*) ALLOCD(type_ctx);
-		*ptr2++ = (qli_nod*) context;
-		if (i == 0)
-			context->ctx_rse = node;
-		if (rel_node->syn_type == nod_rse)
-		{
-			context->ctx_type = CTX_STREAM;
-			context->ctx_stream = expand_rse(rel_node, &new_stack);
-		}
-		else
-		{
-			context->ctx_type = CTX_RELATION;
-			qli_rel* relation = context->ctx_relation = (qli_rel*) rel_node->syn_arg[s_rel_relation];
-			if (!(relation->rel_flags & REL_fields))
-				MET_fields(relation);
-			qli_symbol* symbol = context->ctx_symbol = (qli_symbol*) rel_node->syn_arg[s_rel_context];
-			if (symbol)
-				symbol->sym_object = (BLK) context;
-			if (over)
-			{
-				qli_lls* short_stack = NULL;
-				ALLQ_push((blk*) context, &short_stack);
-				for (USHORT j = 0; j < over->syn_count; j++)
-				{
-					qli_syntax* field = over->syn_arg[j];
-					qli_nod* eql_node = make_node(nod_eql, 2);
-					eql_node->nod_arg[0] = expand_expression(field, short_stack);
-					eql_node->nod_arg[1] = expand_expression(field, new_stack);
-					boolean = make_and(eql_node, boolean);
-				}
-				ALLQ_pop(&short_stack);
-			}
-		}
-		ALLQ_push((blk*) context, &new_stack);
-	}
-
-	// Handle explicit boolean
-
-	if (input->syn_arg[e_rse_boolean])
-		boolean = make_and(boolean, expand_expression(input->syn_arg[e_rse_boolean], new_stack));
-
-	// Handle implicit boolean from SQL xxx IN (yyy FROM relation)
-
-	if (input->syn_arg[s_rse_outer])
-	{
-		qli_nod* eql_node = make_node((enum nod_t)(IPTR)input->syn_arg[s_rse_op], 2);
-		eql_node->nod_arg[0] = expand_expression(input->syn_arg[s_rse_outer], old_stack);
-		eql_node->nod_arg[1] = expand_expression(input->syn_arg[s_rse_inner], new_stack);
-		if (input->syn_arg[s_rse_all_flag])
-			eql_node = negate(eql_node);
-		boolean = make_and(eql_node, boolean);
-	}
-
-	node->nod_arg[e_rse_boolean] = boolean;
-
-	if (input->syn_arg[s_rse_sort])
-	{
-		qli_nod* temp = expand_sort(input->syn_arg[e_rse_sort], new_stack, 0);
-		if (parent_rse)
-			parent_rse->nod_arg[e_rse_sort] = temp;
-		else
-			node->nod_arg[e_rse_sort] = temp;
-	}
-
-	if (input->syn_arg[s_rse_reduced])
-		node->nod_arg[e_rse_reduced] = expand_sort(input->syn_arg[e_rse_reduced], new_stack, 0);
-
-	if (input->syn_arg[s_rse_group_by])
-	{
-		parent_rse->nod_arg[e_rse_group_by] =
-			expand_group_by(input->syn_arg[s_rse_group_by], new_stack, parent_context);
-	}
-
-	node->nod_arg[e_rse_join_type] = (qli_nod*) input->syn_arg[s_rse_join_type];
-
-	// If there is a parent context, set it up here
-
-	*stack = new_stack;
-
-	if (!parent_context)
-		return node;
-
-    qli_ctx* context = NULL;
-	ptr2 = node->nod_arg + e_rse_count;
-	for (const qli_nod* const* const end = ptr2 + node->nod_count; ptr2 < end; ptr2++)
-	{
-		context = (qli_ctx*) *ptr2;
-		context->ctx_parent = parent_context;
-	}
-
-	if (!(parent_context->ctx_relation = context->ctx_relation))
-		parent_context->ctx_stream = context->ctx_stream;
-	ALLQ_push((blk*) parent_context, stack);
-
-	if (input->syn_arg[s_rse_having])
-		parent_rse->nod_arg[e_rse_having] = expand_expression(input->syn_arg[s_rse_having], *stack);
-
-	return parent_rse;
-}
-
-
-static qli_nod* expand_sort( qli_syntax* input, qli_lls* stack, qli_nod* list)
-{
-/**************************************
- *
- *	e x p a n d _ s o r t
- *
- **************************************
- *
- * Functional description
- *	Expand a sort or reduced clause.  This is more than a little
- *	kludgy.  For pure undiscipled, pragmatic reasons, the count for
- *	a sort/ reduced clause for a syntax node is twice the number of
- *	actual keys.  For node nodes, however, the count is the accurate
- *	number of keys.  So be careful.
- *
- **************************************/
-	qli_nod* node = make_node(nod_list, input->syn_count);
-	node->nod_count = input->syn_count / 2;
-	qli_nod** ptr = node->nod_arg;
-	qli_syntax** syn_ptr = input->syn_arg;
-
-	for (USHORT i = 0; i < node->nod_count; i++)
-	{
-		qli_syntax* expr = *syn_ptr++;
-		if (expr->syn_type == nod_position)
-		{
-			const IPTR position = (IPTR) expr->syn_arg[0];
-			if (!list || !position || position > list->nod_count)
-				IBERROR(152);	// Msg152 invalid ORDER BY ordinal
-			qli_print_item* item = (qli_print_item*) list->nod_arg[position - 1];
-			*ptr++ = item->itm_value;
-		}
-		else
-			*ptr++ = expand_expression(expr, stack);
-		*ptr++ = (qli_nod*) * syn_ptr++;
-	}
-
-	return node;
-}
-
-
-static qli_nod* expand_statement( qli_syntax* input, qli_lls* right, qli_lls* left)
-{
-/**************************************
- *
- *	e x p a n d _ s t a t e m e n t
- *
- **************************************
- *
- * Functional description
- *	Expand a statement.
- *
- **************************************/
-	qli_nod* node;
-	qli_nod* (*routine) (qli_syntax*, qli_lls*, qli_lls*);
-
-	switch (input->syn_type)
-	{
-	case nod_abort:
-		node = make_node(input->syn_type, input->syn_count);
-		if (input->syn_arg[0])
-			node->nod_arg[0] = expand_expression(input->syn_arg[0], right);
-		return node;
-
-	case nod_assign:
-		routine = expand_assignment;
-		break;
-
-	case nod_commit_retaining:
-		{
-			node = make_node(input->syn_type, input->syn_count);
-			for (USHORT i = 0; i < input->syn_count; i++)
-				node->nod_arg[i] = (qli_nod*) input->syn_arg[i];
-			return node;
-		}
-
-	case nod_erase:
-		routine = expand_erase;
-		break;
-
-	case nod_for:
-		routine = expand_for;
-		break;
-
-	case nod_if:
-		node = make_node(input->syn_type, input->syn_count);
-		node->nod_arg[e_if_boolean] = expand_expression(input->syn_arg[s_if_boolean], right);
-		node->nod_arg[e_if_true] = expand_statement(input->syn_arg[s_if_true], right, left);
-		if (input->syn_arg[s_if_false])
-			node->nod_arg[e_if_false] = expand_statement(input->syn_arg[s_if_false], right, left);
-		else
-			node->nod_count = 2;
-		return node;
-
-	case nod_modify:
-		routine = expand_modify;
-		break;
-
-	case nod_print:
-	case nod_list_fields:
-		routine = expand_print;
-		break;
-
-	case nod_report:
-		routine = expand_report;
-		break;
-
-	case nod_restructure:
-		routine = expand_restructure;
-		break;
-
-	case nod_store:
-		routine = expand_store;
-		break;
-
-	case nod_repeat:
-		node = make_node(input->syn_type, input->syn_count);
-		node->nod_arg[e_rpt_value] = expand_expression(input->syn_arg[s_rpt_value], left);
-		node->nod_arg[e_rpt_statement] =
-			expand_statement(input->syn_arg[s_rpt_statement], right, left);
-		return node;
-
-	case nod_list:
-		{
-			qli_syntax** syn_ptr = input->syn_arg;
-			qli_lls* stack = NULL;
-			for (USHORT i = 0; i < input->syn_count; i++)
-			{
-				qli_syntax* syn_node = *syn_ptr++;
-				if (syn_node->syn_type == nod_declare)
-				{
-					qli_ctx* context = (qli_ctx*) ALLOCD(type_ctx);
-					context->ctx_type = CTX_VARIABLE;
-					qli_syntax* field_node = syn_node->syn_arg[1];
-					if (field_node)
-					{
-						if (field_node->syn_type == nod_index)
-							field_node = field_node->syn_arg[s_idx_field];
-						resolve_really((qli_fld*) syn_node->syn_arg[0], field_node);
-					}
-					context->ctx_variable = (qli_fld*) syn_node->syn_arg[0];
-					ALLQ_push((blk*) context, &right);
-					ALLQ_push((blk*) context, &left);
-				}
-				else if (node = expand_statement(syn_node, right, left))
-					ALLQ_push((blk*) node, &stack);
-			}
-			return make_list(stack);
-		}
-
-	case nod_declare:
-		return NULL;
-
-	default:
-		ERRQ_bugcheck(136);			// Msg136 expand_statement: not yet implemented
-	}
-
-	return (*routine) (input, right, left);
-}
-
-
-static qli_nod* expand_store( qli_syntax* input, qli_lls* right, qli_lls* left)
-{
-/**************************************
- *
- *	e x p a n d _ s t o r e
- *
- **************************************
- *
- * Functional description
- *	Process, yea expand, on a mere STORE statement.  Make us
- *	something neat if nothing looks obvious.
- *
- **************************************/
-	qli_nod* loop = NULL;
-
-	// If there is an rse, make up a FOR loop
-
-	if (input->syn_arg[s_sto_rse])
-	{
-		loop = make_node(nod_for, e_for_count);
-		loop->nod_arg[e_for_rse] = expand_rse(input->syn_arg[s_sto_rse], &right);
-	}
-
-	qli_nod* node = make_node(input->syn_type, e_sto_count);
-
-	qli_syntax* rel_node = input->syn_arg[s_sto_relation];
-	qli_ctx* context = (qli_ctx*) ALLOCD(type_ctx);
-	node->nod_arg[e_sto_context] = (qli_nod*) context;
-	context->ctx_type = CTX_RELATION;
-	context->ctx_rse = (qli_nod*) -1;
-	qli_rel* relation = context->ctx_relation = (qli_rel*) rel_node->syn_arg[s_rel_relation];
-
-	if (!(relation->rel_flags & REL_fields))
-		MET_fields(relation);
-
-	qli_symbol* symbol = context->ctx_symbol = (qli_symbol*) rel_node->syn_arg[s_rel_context];
-	if (symbol)
-		symbol->sym_object = (BLK) context;
-
-	ALLQ_push((blk*) context, &left);
-
-	//  If there are field and value lists, process them
-
-	if (input->syn_arg[s_sto_values])
-	{
-		if (!input->syn_arg[s_sto_fields])
-		{
-			qli_lls* stack = NULL;
-			for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-			{
-				ALLQ_push((blk*) decompile_field(field, 0), &stack);
-			}
-			input->syn_arg[s_sto_fields] = (qli_syntax*) stack;
-		}
-		expand_values(input, right);
-	}
-
-	// Process sub-statement.  If there isn't one, make up a series of assignments.
-
-	if (input->syn_arg[s_sto_statement])
-	{
-		qli_ctx* secondary = (qli_ctx*) ALLOCD(type_ctx);
-		secondary->ctx_type = CTX_RELATION;
-		secondary->ctx_primary = context;
-		ALLQ_push((blk*) secondary, &right);
-		node->nod_arg[e_sto_statement] =
-			expand_statement(input->syn_arg[s_sto_statement], right, left);
-	}
-	else
-	{
-		qli_lls* stack = NULL;
-		for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-		{
-			if (field->fld_flags & FLD_computed)
-				continue;
-			if ((field->fld_system_flag && field->fld_system_flag != relation->rel_system_flag) ||
-				(field->fld_flags & FLD_array))
-			{
-				continue;
-			}
-			qli_nod* assignment = make_assignment(make_field(field, context), 0, 0);
-			ALLQ_push((blk*) assignment, &stack);
-		}
-		node->nod_arg[e_sto_statement] = make_list(stack);
-	}
-
-	if (!loop)
-		return node;
-
-	loop->nod_arg[e_for_statement] = node;
-
-	return loop;
-}
-
-
-static void expand_values( qli_syntax* input, qli_lls* right)
-{
-/**************************************
- *
- *	e x p a n d _ v a l u e s
- *
- **************************************
- *
- * Functional description
- *	We've got a grungy SQL insert, and we have
- *	to make the value list match the field list.
- *	On the way in, we got the right number of
- *	fields.  Now all that's needed is the values
- *	and matching the two lists, and generating
- *	assignments.  If the input is from a select,
- *	things may be harder, and if there are wild cards
- *	things will be harder still.  Wild cards come in
- *	two flavors * and <context>.*.  The first is
- *	a nod_prompt, the second a nod_star.
- *
- **************************************/
-
-	// fields have already been checked and expanded.  Just count them
-
-	qli_lls* fields = (qli_lls*) input->syn_arg[s_sto_fields];
-	qli_lls* stack;
-	int field_count = 0;
-	for (stack = fields; stack; stack = stack->lls_next)
-		field_count++;
-
-	// We're going to want the values in the order listed in the command
-
-	qli_lls* values = (qli_lls*) input->syn_arg[s_sto_values];
-	while (values)
-		ALLQ_push(ALLQ_pop(&values), &stack);
-
-	// now go through, count, and expand where needed
-
-	int value_count = 0;
-	while (stack)
-	{
-		qli_syntax* value = (qli_syntax*) ALLQ_pop(&stack);
-		if (input->syn_arg[s_sto_rse] && value->syn_type == nod_prompt)
-		{
-			if (value->syn_arg[0] == 0)
-			{
-				qli_lls* temp = NULL;
-				for (; right; right = right->lls_next)
-					ALLQ_push(right->lls_object, &temp);
-
-				while (temp)
-				{
-					qli_ctx* context = (qli_ctx*) ALLQ_pop(&temp);
-					value_count +=
-						generate_fields(context, (qli_lls*) &values, input->syn_arg[s_sto_rse]);
-				}
-			}
-			else
-				IBERROR(542);	// this was a prompting expression.  won't do at all
-		}
-		else if (input->syn_arg[s_sto_rse] && (value->syn_type == nod_star))
-		{
-			qli_ctx* context = find_context((const qli_name*) value->syn_arg[0], right);
-			if (!context)
-				IBERROR(154);	// Msg154 unrecognized context
-			value_count += generate_fields(context, (qli_lls*) &values, input->syn_arg[s_sto_rse]);
-		}
-		else
-		{
-			ALLQ_push((blk*) value, &values);
-			value_count++;
-		}
-	}
-
-	// Make assignments from values to fields
-
-	if (field_count != value_count)
-		IBERROR(189);
-		// Msg189 the number of values do not match the number of fields
-
-	qli_syntax* list = (qli_syntax*) ALLOCDV(type_syn, value_count);
-	list->syn_type = nod_list;
-	list->syn_count = value_count;
-	input->syn_arg[s_sto_statement] = list;
-	qli_syntax** ptr = list->syn_arg + value_count;
-
-	while (values)
-	{
-	    qli_syntax* assignment = (qli_syntax*) ALLOCDV(type_syn, s_asn_count);
-		*--ptr = assignment;
-		assignment->syn_type = nod_assign;
-		assignment->syn_count = s_asn_count;
-		assignment->syn_arg[s_asn_to] = (qli_syntax*) ALLQ_pop(&fields);
-		assignment->syn_arg[s_asn_from] = (qli_syntax*) ALLQ_pop(&values);
-	}
-}
-
-
-static qli_ctx* find_context( const qli_name* name, qli_lls* contexts)
-{
-/**************************************
- *
- *	f i n d _ c o n t e x t
- *
- **************************************
- *
- * Functional description
- *	We've got a context name and we need to return
- *	the context block implicated.
- *
- **************************************/
-	for (; contexts; contexts = contexts->lls_next)
-	{
-		qli_ctx* context = (qli_ctx*) contexts->lls_object;
-		const qli_rel* relation = context->ctx_relation;
-		if (compare_names(name, relation->rel_symbol))
-			return context;
-		if (compare_names(name, context->ctx_symbol))
-			return context;
-	}
-	return NULL;
-}
-
-
-static int generate_fields( qli_ctx* context, qli_lls* values, qli_syntax* rse)
-{
-/**************************************
- *
- *	g e n e r a t e _ f i e l d s
- *
- **************************************
- *
- * Functional description
- *	Expand an asterisk expression, which
- *	could be <relation>.* or <alias>.* or <context>.*
- *	into a list of non-expanded field blocks for
- *	input to a store or update.
- *
- **************************************/
-
-	if (context->ctx_type == CTX_VARIABLE)
-		return 0;
-	if (context->ctx_type == CTX_AGGREGATE)
-		return 0;
-
-	qli_syntax* group_list = rse->syn_arg[s_rse_group_by];
-	qli_rel* relation = context->ctx_relation;
-	int count = 0;
-
-	for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-	{
-		if ((field->fld_system_flag && field->fld_system_flag != relation->rel_system_flag) ||
-			(field->fld_flags & FLD_array))
-		{
-			continue;
-		}
-		qli_syntax* value = decompile_field(field, context);
-		if (group_list && invalid_syn_field(value, group_list))
-			continue;
-		ALLQ_push((blk*) value, (qli_lls**) values);
-		count++;
-	}
-
-	return count;
-}
-
-
-static int generate_items(const qli_syntax* symbol, qli_lls* right, qli_lls* items, qli_nod* rse)
-{
-/**************************************
- *
- *	g e n e r a t e _ i t e m s
- *
- **************************************
- *
- * Functional description
- *	Expand an asterisk expression, which
- *	could be <relation>.* or <alias>.* or <context>.*
- *	into a list of reasonable print items.
- *
- *      If the original request included a group by,
- *	include only the grouping fields.
- *
- **************************************/
-	qli_nod* group_list = rse ? rse->nod_arg[e_rse_group_by] : NULL;
-
-	// first identify the relation or context
-
-	const qli_name* name;
-	if (symbol->syn_count == 1)
-		name = (qli_name*) symbol->syn_arg[0];
-	else
-		IBERROR(153);
-		// Msg153 asterisk expressions require exactly one qualifying context
-
-	qli_ctx* context = find_context(name, right);
-	if (!context)
-		IBERROR(154);			// Msg154 unrecognized context
-
-	qli_rel* relation = context->ctx_relation;
-	int count = 0;
-	for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-	{
-		if ((field->fld_system_flag && field->fld_system_flag != relation->rel_system_flag) ||
-			(field->fld_flags & FLD_array))
-		{
-			continue;
-		}
-		qli_nod* node = make_field(field, context);
-		if (group_list && invalid_nod_field(node, group_list))
-			continue;
-		qli_print_item* item = (qli_print_item*) ALLOCD(type_itm);
-		item->itm_type = item_value;
-		item->itm_value = make_field(field, context);
-		expand_edit_string(item->itm_value, item);
-		ALLQ_push((blk*) item, (qli_lls**) items);
-		++count;
-	}
-
-	return count;
-}
-
-
-static bool global_agg( const qli_syntax* item, const qli_syntax* group_list)
-{
-/**************************************
- *
- *	g l o b a l _ a g g
- *
- **************************************
- *
- * Functional description
- *	We've got a print list item that may contain
- *	a sql global aggregate.  If it does, we're
- *	going to make the whole thing a degenerate
- *	group by.  Anyway.  Look for aggregates buried
- *	deep within printable things.
- *
- *	This recurses.  If it finds a mixture of normal
- *	and aggregates it complains.
- *
- **************************************/
-	bool normal_field = false;
-	bool aggregate = false;
-
-	switch (item->syn_type)
-	{
-	case nod_agg_average:
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_total:
-	case nod_agg_count:
-	case nod_running_total:
-	case nod_running_count:
-		return true;
-
-	case nod_upcase:
-	case nod_lowcase:
-	case nod_add:
-	case nod_subtract:
-	case nod_multiply:
-	case nod_divide:
-	case nod_negate:
-	case nod_concatenate:
-	case nod_substr:
-		{
-			const qli_syntax* const* ptr = item->syn_arg;
-			for (const qli_syntax* const* const end = ptr + item->syn_count; ptr < end; ptr++)
-			{
-				if ((*ptr)->syn_type == nod_constant)
-					continue;
-				if (global_agg(*ptr, group_list))
-					aggregate = true;
-				else if (!group_list || invalid_syn_field(*ptr, group_list))
-					normal_field = true;
-			}
-		}
-
-	default:
-		break;
-	}
-
-	if (normal_field && aggregate)
-		IBERROR(451);
-
-	return aggregate;
-}
-
-
-static bool invalid_nod_field( const qli_nod* node, const qli_nod* list)
-{
-/**************************************
- *
- *	i n v a l i d _ n o d _ f i e l d
- *
- **************************************
- *
- * Functional description
- *
- *	Validate that an expanded field / context
- *	pair is in a specified list.  Thus is used
- *	in one instance to check that a simple field selected
- *	through a grouping rse is a grouping field -
- *	thus a valid field reference.
- *
- **************************************/
-	if (!list)
-		return true;
-
-	bool invalid = false;
-
-	if (node->nod_type == nod_field)
-	{
-		const qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-		const qli_ctx* context = (qli_ctx*) node->nod_arg[e_fld_context];
-		const qli_nod* const* ptr = list->nod_arg;
-		for (const qli_nod* const* const end = ptr + list->nod_count; ptr < end; ptr++)
-		{
-			if (field == (qli_fld*) (*ptr)->nod_arg[e_fld_field] &&
-				context == (qli_ctx*) (*ptr)->nod_arg[e_fld_context])
-			{
-				return false;
-			}
-		}
-		return true;
-	}
-	else
-	{
-		const qli_nod* const* ptr = node->nod_arg;
-		for (const qli_nod* const* const end = ptr + node->nod_count; ptr < end; ptr++)
-		{
-			switch ((*ptr)->nod_type)
-			{
-			case nod_field:
-			case nod_add:
-			case nod_subtract:
-			case nod_multiply:
-			case nod_divide:
-			case nod_negate:
-			case nod_concatenate:
-			case nod_substr:
-			case nod_format:
-			case nod_choice:
-			case nod_function:
-			case nod_upcase:
-			case nod_lowcase:
-				invalid |= invalid_nod_field(*ptr, list);
-			}
-		}
-	}
-
-	return invalid;
-}
-
-
-static bool invalid_syn_field( const qli_syntax* syn_node, const qli_syntax* list)
-{
-/**************************************
- *
- *	i n v a l i d _ s y n _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Make sure an unexpanded simple field selected
- *	through a grouping rse is a grouping field -
- *	thus a valid field reference.  For the sake of
- *      argument, we'll match qualified to unqualified
- *	reference, but qualified reference must match
- *	completely.
- *
- *	One more thought.  If this miserable thing is
- *	a wild card, let it through and expand it
- *	correctly later.
- *
- **************************************/
-	if (syn_node->syn_type == nod_star)
-		return false;
-
-	if (!list)
-		return true;
-
-	bool invalid = false;
-
-	if (syn_node->syn_type == nod_field)
-	{
-		const qli_name* fctx = NULL;
-		const qli_name* fname = (qli_name*) syn_node->syn_arg[0];
-		if (syn_node->syn_count == 2)
-		{
-			fctx = fname;
-			fname = (qli_name*) syn_node->syn_arg[1];
-		}
-
-		for (SSHORT count = list->syn_count; count;)
-		{
-			const qli_name* gctx = NULL;
-			const qli_syntax* element = list->syn_arg[--count];
-			const qli_name* gname = (qli_name*) element->syn_arg[0];
-			if (element->syn_count == 2)
-			{
-				gctx = gname;
-				gname = (qli_name*) element->syn_arg[1];
-			}
-			if (!strcmp(fname->nam_string, gname->nam_string))
-			{
-				if (!gctx || !fctx || !strcmp(fctx->nam_string, gctx->nam_string))
-				{
-					return false;
-				}
-			}
-		}
-		return true;
-	}
-	else
-	{
-		const qli_syntax* const* ptr = syn_node->syn_arg;
-		for (const qli_syntax* const* const end = ptr + syn_node->syn_count; ptr < end; ptr++)
-		{
-			switch ((*ptr)->syn_type)
-			{
-			case nod_field:
-			case nod_add:
-			case nod_subtract:
-			case nod_multiply:
-			case nod_divide:
-			case nod_negate:
-			case nod_concatenate:
-			case nod_substr:
-			case nod_format:
-			case nod_choice:
-			case nod_function:
-			case nod_upcase:
-			case nod_lowcase:
-				invalid |= invalid_syn_field(*ptr, list);
-			}
-		}
-	}
-
-	return invalid;
-}
-
-
-static qli_nod* make_and( qli_nod* expr1, qli_nod* expr2)
-{
-/**************************************
- *
- *	m a k e _ a n d
- *
- **************************************
- *
- * Functional description
- *	Combine two expressions, each possible null, into at most
- *	a single boolean.
- *
- **************************************/
-	if (!expr1)
-		return expr2;
-
-	if (!expr2)
-		return expr1;
-
-	qli_nod* node = make_node(nod_and, 2);
-	node->nod_arg[0] = expr1;
-	node->nod_arg[1] = expr2;
-
-	return node;
-}
-
-
-static qli_nod* make_assignment( qli_nod* target, qli_nod* initial, qli_lls* right)
-{
-/**************************************
- *
- *	m a k e _ a s s i g n m e n t
- *
- **************************************
- *
- * Functional description
- *	Generate a prompt and assignment to a field.
- *
- **************************************/
-	qli_fld* field = (qli_fld*) target->nod_arg[e_fld_field];
-	qli_lls* stack = NULL;
-	ALLQ_push((blk*) target->nod_arg[e_fld_context], &stack);
-
-	qli_nod* prompt;
-
-	if (field->fld_dtype == dtype_blob)
-	{
-		prompt = make_node(nod_edit_blob, e_edt_count);
-		prompt->nod_count = 0;
-		prompt->nod_arg[e_edt_name] = (qli_nod*) field->fld_name->sym_string;
-		if (initial)
-		{
-			prompt->nod_count = 1;
-			prompt->nod_arg[e_edt_input] = expand_expression((qli_syntax*) initial, right);
-		}
-	}
-	else
-	{
-		prompt = make_node(nod_prompt, e_prm_count);
-		prompt->nod_arg[e_prm_prompt] = (qli_nod*) field->fld_name->sym_string;
-		prompt->nod_arg[e_prm_field] = (qli_nod*) field;
-	}
-
-	qli_nod* assignment = make_node(nod_assign, e_asn_count);
-	assignment->nod_arg[e_asn_to] = target;
-	assignment->nod_arg[e_asn_from] = prompt;
-
-	if (field->fld_validation)
-		assignment->nod_arg[e_asn_valid] = expand_expression(field->fld_validation, stack);
-	else
-		--assignment->nod_count;
-
-	ALLQ_pop(&stack);
-
-	return assignment;
-}
-
-
-static qli_nod* make_field( qli_fld* field, qli_ctx* context)
-{
-/**************************************
- *
- *	m a k e _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Make a field block.  Not too tough.
- *
- **************************************/
-	qli_nod* node = make_node(nod_field, e_fld_count);
-	node->nod_count = 0;
-	node->nod_arg[e_fld_field] = (qli_nod*) field;
-	node->nod_arg[e_fld_context] = (qli_nod*) context;
-
-	if (context->ctx_variable)
-		node->nod_type = nod_variable;
-
-	return node;
-}
-
-
-static qli_nod* make_list( qli_lls* stack)
-{
-/**************************************
- *
- *	m a k e _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Dump a stack of junk into a list node.  Best count
- *	them first.
- *
- **************************************/
-	qli_lls* temp = stack;
-	USHORT count = 0;
-
-	while (temp)
-	{
-		count++;
-		temp = temp->lls_next;
-	}
-
-	qli_nod* node = make_node(nod_list, count);
-	qli_nod** ptr = &node->nod_arg[count];
-
-	while (stack)
-		*--ptr = (qli_nod*) ALLQ_pop(&stack);
-
-	return node;
-}
-
-
-static qli_nod* make_node( nod_t type, USHORT count)
-{
-/**************************************
- *
- *	m a k e _ n o d e
- *
- **************************************
- *
- * Functional description
- *	Allocate a node and fill in some basic stuff.
- *
- **************************************/
-	qli_nod* node = (qli_nod*) ALLOCDV(type_nod, count);
-	node->nod_type = type;
-	node->nod_count = count;
-
-	return node;
-}
-
-
-static qli_nod* negate( qli_nod* expr)
-{
-/**************************************
- *
- *	n e g a t e
- *
- **************************************
- *
- * Functional description
- *	Build negation of expression.
- *
- **************************************/
-	qli_nod* node = make_node(nod_not, 1);
-	node->nod_arg[0] = expr;
-
-	return node;
-}
-
-
-static qli_nod* possible_literal(qli_syntax* input, qli_lls* stack, bool upper_flag)
-{
-/**************************************
- *
- *	p o s s i b l e _ l i t e r a l
- *
- **************************************
- *
- * Functional description
- *	Check to see if a value node is an unresolved name.  If so,
- *	transform it into a constant expression.  This is used to
- *	correct "informalities" in relational expressions.
- *
- **************************************/
-	qli_ctx* context;
-
-	// If the value isn't a field, is qualified, or can be resolved,
-	// it doesn't qualify for conversion.  Return NULL.
-
-	if (input->syn_type != nod_field || input->syn_count != 1 || resolve(input, stack, &context))
-	{
-		return NULL;
-	}
-
-	const qli_name* name = (qli_name*) input->syn_arg[0];
-	USHORT l = name->nam_length;
-	qli_const* constant = (qli_const*) ALLOCDV(type_con, l);
-	constant->con_desc.dsc_dtype = dtype_text;
-	constant->con_desc.dsc_length = l;
-	constant->con_desc.dsc_address = constant->con_data;
-	QLI_validate_desc(constant->con_desc);
-	TEXT* p = (TEXT*) constant->con_data;
-	const TEXT* q = name->nam_string;
-
-	if (upper_flag)
-	{
-		if (l)
-			do {
-				const TEXT c = *q++;
-				*p++ = UPPER(c);
-			} while (--l);
-	}
-	else if (l)
-		do {
-			const TEXT c = *q++;
-			*p++ = (c >= 'A' && c <= 'Z') ? c - 'A' + 'a' : c;
-
-		} while (--l);
-
-	qli_nod* node = make_node(nod_constant, 0);
-	node->nod_desc = constant->con_desc;
-
-	return node;
-}
-
-
-static qli_nod* post_map( qli_nod* node, qli_ctx* context)
-{
-/**************************************
- *
- *	p o s t _ m a p
- *
- **************************************
- *
- * Functional description
- *	Post an item to a map for a context.
- *
- **************************************/
-	qli_map* map;
-
-	// Check to see if the item has already been posted
-
-	for (map = context->ctx_map; map; map = map->map_next)
-	{
-		if (CMP_node_match(node, map->map_node))
-			break;
-	}
-
-	if (!map)
-	{
-		map = (qli_map*) ALLOCD(type_map);
-		map->map_next = context->ctx_map;
-		context->ctx_map = map;
-		map->map_node = node;
-	}
-
-	qli_nod* new_node = make_node(nod_map, e_map_count);
-	new_node->nod_count = 0;
-	new_node->nod_arg[e_map_context] = (qli_nod*) context;
-	new_node->nod_arg[e_map_map] = (qli_nod*) map;
-	new_node->nod_desc = node->nod_desc;
-
-	return new_node;
-}
-
-
-static qli_fld* resolve( qli_syntax* node, qli_lls* stack, qli_ctx** out_context)
-{
-/**************************************
- *
- *	r e s o l v e
- *
- **************************************
- *
- * Functional description
- *	Resolve a field node against a context stack.  Return both the
- *	field block (by value)  and the corresponding context block (by
- *	reference).  Return NULL if field can't be resolved.
- *
- **************************************/
-	qli_rel* relation;
-
-	// Look thru context stack looking for a context that will resolve
-	// all name segments.  If the context is a secondary context, require
-	// that the context name be given explicitly (used for special STORE
-	// context).
-
-	qli_name** base = (qli_name**) node->syn_arg;
-
-	for (; stack; stack = stack->lls_next)
-	{
-		qli_ctx* context = (qli_ctx*) stack->lls_object;
-		*out_context = context;
-		qli_name** ptr = base + node->syn_count;
-		const qli_name* name = *--ptr;
-
-		switch (context->ctx_type)
-		{
-		case CTX_VARIABLE:
-			if (ptr == base)
-				for (qli_fld* field = context->ctx_variable; field; field = field->fld_next)
-				{
-					if (compare_names(name, field->fld_name) ||
-						compare_names(name, field->fld_query_name))
-					{
-						return field;
-					}
-				}
-			break;
-
-		case CTX_RELATION:
-			if (context->ctx_primary)
-			{
-				*out_context = context = context->ctx_primary;
-				if (!compare_names((qli_name*) node->syn_arg[0], context->ctx_symbol))
-					break;
-			}
-			relation = context->ctx_relation;
-
-			for (qli_fld* field = relation->rel_fields; field; field = field->fld_next)
-				if (compare_names(name, field->fld_name) || compare_names(name, field->fld_query_name))
-				{
-					if (ptr == base)
-						return field;
-
-					name = *--ptr;
-
-					if (compare_names(name, relation->rel_symbol))
-					{
-						if (ptr == base)
-							return field;
-
-						name = *--ptr;
-					}
-
-					if (compare_names(name, context->ctx_symbol))
-					{
-						if (ptr == base)
-							return field;
-					}
-					break;
-				}
-			break;
-		}
-	}
-
-	// We didn't resolve all name segments.  Let somebody else worry about it.
-
-	return NULL;
-}
-
-
-
-static void resolve_really( qli_fld* variable, const qli_syntax* field_node)
-{
-/**************************************
- *
- *	r e s o l v e _ r e a l l y
- *
- **************************************
- *
- * Functional description
- *	Resolve a field reference entirely.
- *
- **************************************/
-
-	// For ease, break down the syntax block.
-	// It should contain at least one name; two names are a  potential ambiguity:
-	// check for a qli_dbb (<db>.<glo_fld>), then for a rel (<rel>.<fld>).
-
-	USHORT offset = field_node->syn_count;
-	const qli_name* fld_name = (qli_name*) field_node->syn_arg[--offset];
-
-	qli_name* rel_name = NULL;
-	//qli_name* db_name = NULL;
-	if (offset)
-	{
-		rel_name = (qli_name*) field_node->syn_arg[--offset];
-		//if (offset)
-		//	db_name = (qli_name*) field_node->syn_arg[--offset];
-	}
-
-    bool resolved = false;
-    bool local = false;
-    qli_fld* field = NULL;
-
-	if (field_node->syn_count == 1)
-		resolved = MET_declare(0, variable, fld_name);
-	else if (field_node->syn_count == 2)
-	{
-		for (qli_symbol* symbol = rel_name->nam_symbol; symbol; symbol = symbol->sym_homonym)
-		{
-			if (symbol->sym_type == SYM_database)
-			{
-				qli_dbb* dbb = (qli_dbb*) symbol->sym_object;
-				resolved = MET_declare(dbb, variable, fld_name);
-				break;			// should be only one db in homonym list
-			}
-		}
-
-		if (!resolved)
-		{
-			for (qli_dbb* dbb = QLI_databases; dbb && !resolved; dbb = dbb->dbb_next)
-				for (qli_symbol* symbol = rel_name->nam_symbol; symbol; symbol = symbol->sym_homonym)
-				{
-					qli_rel* relation;
-					if (symbol->sym_type == SYM_relation &&
-						(relation = (qli_rel*) symbol->sym_object) && relation->rel_database == dbb)
-					{
-						if (!relation->rel_fields)
-							MET_fields(relation);
-						for (field = relation->rel_fields; field; field = field->fld_next)
-						{
-							resolved = local = compare_names(fld_name, field->fld_name);
-							if (resolved)
-								break;
-						}
-						break;	// should be only one rel in homonym list for each db
-					}
-				}
-		}
-	}
-	else
-	{
-		qli_rel* relation = variable->fld_relation;
-		if (!relation->rel_fields)
-			MET_fields(relation);
-		for (field = relation->rel_fields; field; field = field->fld_next)
-		{
-			resolved = local = compare_names(fld_name, field->fld_name);
-			if (resolved)
-				break;
-		}
-	}
-
-	if (!resolved)
-		IBERROR(155);
-		// Msg155 field referenced in BASED ON can not be resolved against readied databases
-
-	if (local)
-	{
-		variable->fld_dtype = field->fld_dtype;
-		variable->fld_length = field->fld_length;
-		variable->fld_scale = field->fld_scale;
-		variable->fld_sub_type = field->fld_sub_type;
-		variable->fld_sub_type_missing = field->fld_sub_type_missing;
-		if (!variable->fld_edit_string)
-			variable->fld_edit_string = field->fld_edit_string;
-		if (!variable->fld_query_header)
-			variable->fld_query_header = field->fld_query_header;
-		if (!variable->fld_query_name)
-			variable->fld_query_name = field->fld_query_name;
-	}
-}
-
-
-
diff --git a/src/qli/forma_proto.h b/src/qli/forma_proto.h
deleted file mode 100644
index ebb77d0459..0000000000
--- a/src/qli/forma_proto.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		forma_proto.h
- *	DESCRIPTION:	Prototype header file for format.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_FORMA_PROTO_H
-#define QLI_FORMA_PROTO_H
-
-int			FMT_expression(qli_nod*);
-TEXT*		FMT_format(qli_lls*);
-qli_nod*	FMT_list(qli_nod*);
-void		FMT_print(qli_nod*, qli_prt*);
-void		FMT_put(const TEXT*, qli_prt*);
-void		FMT_report(qli_rpt*);
-
-#endif // QLI_FORMA_PROTO_H
-
diff --git a/src/qli/format.cpp b/src/qli/format.cpp
deleted file mode 100644
index 3bdd853a44..0000000000
--- a/src/qli/format.cpp
+++ /dev/null
@@ -1,1505 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		format.cpp
- *	DESCRIPTION:	Print planner and formatter
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <string.h>
-#include "../qli/dtr.h"
-#include "../qli/exe.h"
-#include "ibase.h"
-#include "../qli/compile.h"
-#include "../qli/report.h"
-#include "../qli/format.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/eval_proto.h"
-#include "../qli/exe_proto.h"
-#include "../qli/forma_proto.h"
-#include "../qli/mov_proto.h"
-#include "../qli/picst_proto.h"
-
-using MsgFormat::SafeArg;
-
-
-#ifdef DEV_BUILD
-//extern bool QLI_hex_output; decl already done in dtr.h
-
-inline bool is_printable(UCHAR x)
-{
-	return ((x >= ' ') && (x <= 127)) || (x == '\n') || (x == '\t') || (x == '\r') || (x == '\f');
-}
-#endif
-
-static USHORT decompose_header(const SCHAR*, const SCHAR**, USHORT*);
-static void format_index(qli_print_item*, qli_nod*, const bool);
-static TEXT* format_report(qli_vec*, USHORT, USHORT*);
-static void format_value(qli_print_item*, int);
-static TEXT* get_buffer(qli_str**, TEXT*, USHORT);
-static bool match_expr(const qli_nod*, const qli_nod*);
-static void print_blobs(qli_prt*, qli_print_item**, qli_print_item**);
-static int print_line(qli_print_item*, TEXT**);
-static void put_line(qli_prt*, TEXT**, TEXT*, TEXT);
-static void report_break(qli_brk*, qli_vec**, const bool);
-static void report_item(qli_print_item*, qli_vec**, USHORT*);
-static void report_line(qli_nod*, qli_vec**);
-
-static qli_str* global_fmt_buffer;
-static qli_str* global_blob_buffer;
-
-#define BOTTOM_INIT			get_buffer (&global_fmt_buffer, NULL, 1024)
-#define BOTTOM_CHECK(ptr, length)	ptr = get_buffer (&global_fmt_buffer, ptr, length)
-#define BOTTOM_LINE			global_fmt_buffer->str_data
-
-#define BUFFER_INIT			get_buffer (&global_fmt_buffer, NULL, 1024)
-#define BUFFER_CHECK(ptr, length)	ptr = get_buffer (&global_fmt_buffer, ptr, length)
-#define BUFFER_BEGINNING		global_fmt_buffer->str_data
-#define BUFFER_REMAINING(ptr)		(global_fmt_buffer->str_length - (ptr - global_fmt_buffer->str_data))
-
-int FMT_expression( qli_nod* node)
-{
-/**************************************
- *
- *	F M T _ e x p r e s s i o n
- *
- **************************************
- *
- * Functional description
- *	Handle formatting for FORMAT expression.  Return editted
- *	length.
- *
- **************************************/
-	qli_nod* sub = node->nod_arg[e_fmt_value];
-	pics* picture = PIC_analyze((const TEXT*) node->nod_arg[e_fmt_edit], &sub->nod_desc);
-	node->nod_arg[e_fmt_picture] = (qli_nod*) picture;
-
-	if (node->nod_type == nod_reference)
-		node = node->nod_arg[0];
-
-	qli_fld* field;
-	if (!(picture->pic_missing) && (node->nod_type == nod_field) &&
-		(field = (qli_fld*) node->nod_arg[e_fld_field]) && field->fld_missing)
-	{
-		PIC_missing(field->fld_missing, picture);
-	}
-
-	return picture->pic_length;
-}
-
-
-TEXT* FMT_format(qli_lls* stack)
-{
-/**************************************
- *
- *	F M T _ f o r m a t
- *
- **************************************
- *
- * Functional description
- *	Format a print line.  Figure out spacing, print formats, and
- *	headers.  Return a pointer to the header string.
- *
- **************************************/
-	USHORT lengths[10];
-	const TEXT* segments[10];
-
-	// Start by inverting the item stack into an item que
-
-	qli_lls* temp = stack;
-	stack = NULL;
-
-	if (global_fmt_buffer)
-	{
-		ALLQ_release((qli_frb*) global_fmt_buffer);
-		global_fmt_buffer = NULL;
-	}
-
-	while (temp)
-	{
-		qli_print_item* item = (qli_print_item*) ALLQ_pop(&temp);
-		ALLQ_push((blk*) item, &stack);
-	}
-
-	// Make a pass thru print items computing print lengths and header
-	// lengths, and the number of header segments.
-
-	USHORT offset, max_offset, number_segments;
-	number_segments = offset = max_offset = 0;
-	TEXT* bottom = BOTTOM_INIT;
-
-	for (temp = stack; temp; temp = temp->lls_next)
-	{
-		qli_print_item* item = (qli_print_item*) temp->lls_object;
-		switch (item->itm_type)
-		{
-		case item_column:
-			offset = (item->itm_count) ? item->itm_count - 1 : 0;
-			continue;
-
-		case item_skip:
-		case item_new_page:
-			offset = 0;
-			continue;
-
-		case item_space:
-			offset += item->itm_count;
-			continue;
-
-		case item_tab:
-			offset = (offset & ~7) + item->itm_count * 8;
-			continue;
-		}
-
-		qli_nod* value = 0;
-		if (item->itm_type == item_value && (value = item->itm_value))
-		{
-			if (value->nod_type == nod_reference)
-				value = value->nod_arg[0];
-			format_index(item, value, true);
-		}
-
-		if (item->itm_query_header)
-		{
-			if (*item->itm_query_header == '-')
-				item->itm_query_header = NULL;
-			else
-			{
-				const USHORT n = decompose_header(item->itm_query_header, segments, lengths);
-				number_segments = MAX(n, number_segments);
-				USHORT* ptr = lengths;
-				for (USHORT j = 0; j < n; j++, ptr++)
-					item->itm_header_length = MAX(item->itm_header_length, *ptr);
-			}
-		}
-
-		format_value(item, 0);
-
-		// If the item would overflow the line, reset to beginning of line
-
-		if (offset + MAX(item->itm_print_length, item->itm_header_length) > QLI_columns)
-			offset = 0;
-
-		// Before we blindly format the header, make sure there already isn't
-		// header information in the same location
-
-		if (item->itm_query_header)
-		{
-			const USHORT n = MAX(item->itm_print_length, item->itm_header_length);
-			BOTTOM_CHECK(bottom, offset);
-			const TEXT* q = BOTTOM_LINE + offset;
-			while (bottom < q)
-				*bottom++ = ' ';
-			bool flag = true;
-			USHORT l;
-			if (offset && q[-1] != ' ')
-				flag = false;
-			else if (l = MIN(n, bottom - q))
-			{
-				const TEXT* p = bottom;
-				while (--l)
-					if (*p++ != ' ')
-					{
-						flag = false;
-						break;
-					}
-				if (flag && p < bottom && *p != ' ')
-					flag = false;
-			}
-			if (flag && (l = n))
-			{
-				BOTTOM_CHECK(bottom, bottom - BOTTOM_LINE + n);
-				do {
-					*bottom++ = '=';
-				} while (--l);
-			}
-			else
-			{
-				item->itm_query_header = NULL;
-				item->itm_header_length = 0;
-			}
-		}
-
-		// Now that have settled the issue of header, decide where to put
-		// the field and header
-
-		const USHORT n = MAX(item->itm_print_length, item->itm_header_length);
-		item->itm_print_offset = offset + (n - item->itm_print_length) / 2;
-		item->itm_header_offset = offset + n / 2;
-		offset += n + 1;
-		max_offset = MAX(max_offset, offset);
-	}
-
-	// Make another pass checking for overlapping fields
-
-	for (temp = stack; temp; temp = temp->lls_next)
-	{
-		qli_print_item* item = (qli_print_item*) temp->lls_object;
-		if (item->itm_type != item_value)
-			continue;
-		for (qli_lls* temp2 = temp->lls_next; temp2; temp2 = temp2->lls_next)
-		{
-			qli_print_item* item2 = (qli_print_item*) temp2->lls_object;
-			if (item2->itm_type != item_value)
-				continue;
-			if (item2->itm_print_offset < item->itm_print_offset + item->itm_print_length)
-			{
-				item->itm_flags |= ITM_overlapped;
-				break;
-			}
-		}
-	}
-
-	if (number_segments == 0)
-		return NULL;
-
-	// Allocate a string block big enough to hold all lines of the print header
-
-	const ULONG size = (max_offset + 1) * (number_segments + 1) + 2;
-
-	if (size >= 60000)
-		ERRQ_print_error(482, SafeArg() << max_offset << (number_segments + 1));
-
-	qli_str* header = (qli_str*) ALLOCDV(type_str, size);
-	TEXT* p = header->str_data;
-
-	// Generate the various lines of the header line at a time.
-
-	for (USHORT j = 0; j < number_segments; j++)
-	{
-		*p++ = '\n';
-		TEXT* const line = p;
-		for (temp = stack; temp; temp = temp->lls_next)
-		{
-			qli_print_item* item = (qli_print_item*) temp->lls_object;
-			if (item->itm_type != item_value)
-				continue;
-			const USHORT n = decompose_header(item->itm_query_header, segments, lengths);
-			const SSHORT segment = j - (number_segments - n);
-			if (segment < 0)
-				continue;
-			USHORT l = lengths[segment];
-			const TEXT* q = line + item->itm_header_offset - l / 2;
-
-			while (p < q)
-				*p++ = ' ';
-			q = segments[segment];
-			if (l)
-				do {
-					*p++ = *q++;
-				} while (--l);
-		}
-	}
-
-	// Make one last pass to put in underlining of headers
-
-	USHORT len = bottom - BOTTOM_LINE;
-	if (len)
-	{
-		*p++ = '\n';
-		bottom = BOTTOM_LINE;
-		do {
-			*p++ = *bottom++;
-		} while (--len);
-	}
-
-	*p++ = '\n';
-	*p++ = '\n';
-	*p = 0;
-
-	return header->str_data;
-}
-
-
-qli_nod* FMT_list(qli_nod* list)
-{
-/**************************************
- *
- *	F M T _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Rebuild and format a list of stuff for vertical formatting.
- *
- **************************************/
-	qli_print_item** item;
-	const qli_print_item* const* end;
-	qli_symbol* name;
-	qli_fld* field;
-	qli_nod* value;
-
-	qli_nod* new_nod = (qli_nod*) ALLOCDV(type_nod, list->nod_count * 2 + 1);
-	new_nod->nod_type = nod_list;
-	qli_print_item** new_ptr = (qli_print_item**) new_nod->nod_arg;
-	USHORT column = 0;
-
-	for (item = (qli_print_item**) list->nod_arg, end = item + list->nod_count; item < end; item++)
-	{
-		if ((*item)->itm_type != item_value || !(value = (*item)->itm_value))
-			continue;
-		(*item)->itm_flags |= ITM_overlapped;
-		format_value(*item, PIC_suppress_blanks);
-		if (value->nod_type == nod_reference)
-			value = value->nod_arg[0];
-		bool expression = true;
-		if (value->nod_type == nod_field || value->nod_type == nod_variable ||
-			value->nod_type == nod_function)
-		{
-			expression = false;
-			if (value->nod_type != nod_function)
-			{
-				field = (qli_fld*) value->nod_arg[e_fld_field];
-				name = field->fld_name;
-				format_index(*item, value, false);
-			}
-			else
-				name = ((qli_fun*) value->nod_arg[e_fun_function])->fun_symbol;
-		}
-		qli_print_item* new_item = (qli_print_item*) ALLOCD(type_itm);
-		*new_ptr++ = new_item;
-		new_item->itm_type = item_value;
-		new_item->itm_value = value = (qli_nod*) ALLOCDV(type_nod, 0);
-		value->nod_type = nod_constant;
-		value->nod_flags |= NOD_local;
-		value->nod_desc.dsc_dtype = dtype_text;
-		const TEXT* q;
-		if (!expression && (!(q = (*item)->itm_query_header) || *q != '-'))
-		{
-			if (q)
-			{
-				if (*q != '"' && *q != '\'')
-					value->nod_desc.dsc_address = (UCHAR*) q;
-				else
-				{
-					qli_str* header = (qli_str*) ALLOCDV(type_str, static_cast<int>(strlen(q)));
-					TEXT* p = header->str_data;
-					value->nod_desc.dsc_address = (UCHAR*) p; // safe const_cast, see PIC_analyze
-					TEXT c;
-					while (c = *q++)
-					{
-						while (*q != c)
-							*p++ = *q++;
-						*p++ = ' ';
-						q++;
-					}
-					p[-1] = 0;
-				}
-				value->nod_desc.dsc_length = static_cast<USHORT>(strlen((char*) value->nod_desc.dsc_address));
-			}
-			else
-			{
-				value->nod_desc.dsc_length = name->sym_length;
-				value->nod_desc.dsc_address = (UCHAR*) name->sym_string;
-			}
-			QLI_validate_desc(value->nod_desc);
-			column = MAX(column, value->nod_desc.dsc_length);
-			new_item->itm_picture = PIC_analyze(0, &value->nod_desc);
-		}
-		else
-		{
-			const dsc* desc = EVAL_value(value);
-			new_item->itm_picture = PIC_analyze(0, desc);
-		}
-
-		if (!new_item->itm_picture->pic_missing &&
-			value->nod_type == nod_field && field->fld_missing)
-		{
-			PIC_missing(field->fld_missing, new_item->itm_picture);
-		}
-
-		*new_ptr++ = *item;
-	}
-
-	qli_print_item* new_item = (qli_print_item*) ALLOCD(type_itm);
-	*new_ptr++ = new_item;
-	new_item->itm_type = item_skip;
-	new_item->itm_count = 1;
-	column += 2;
-
-	for (item = (qli_print_item**) list->nod_arg, end = item + list->nod_count; item < end; item++)
-	{
-		if ((*item)->itm_type != item_value || !(value = (*item)->itm_value))
-			continue;
-		if (value->nod_type == nod_reference)
-			value = value->nod_arg[0];
-		(*item)->itm_print_offset = column;
-	}
-
-	new_nod->nod_count = new_ptr - (qli_print_item**) new_nod->nod_arg;
-
-	return new_nod;
-}
-
-
-void FMT_print( qli_nod* list, qli_prt* print)
-{
-/**************************************
- *
- *	F M T _ p r i n t
- *
- **************************************
- *
- * Functional description
- *	Format a print line.  Return the number of lines printed.
- *
- **************************************/
-	qli_nod** ptr;
-
-	// Now go thru and make up the first line
-
-	if (!list)
-		return;
-
-	TEXT* buffer = NULL;
-	TEXT* p = BUFFER_INIT;
-	const qli_nod* const* const end = list->nod_arg + list->nod_count;
-
-	for (ptr = list->nod_arg; ptr < end; ptr++)
-	{
-		qli_print_item* item = (qli_print_item*) *ptr;
-
-		// Handle formating directives.  Most have been translated into
-		// column assignments and are no-ops.
-
-		buffer = BUFFER_BEGINNING;
-
-		switch (item->itm_type)
-		{
-		case item_value:
-			break;
-
-		case item_new_page:
-			if (print->prt_new_page)
-			{
-				put_line(print, &p, buffer, '\n');
-				(*print->prt_new_page) (print, false);
-			}
-			else
-			{
-				put_line(print, &p, buffer, '\f');
-				QLI_skip_line = false;
-			}
-			continue;
-
-		case item_skip:
-			{
-				put_line(print, &p, buffer, '\n');
-				print_blobs(print, (qli_print_item**) list->nod_arg, (qli_print_item**) ptr);
-				for (USHORT l = item->itm_count - 1; l > 0; --l)
-					put_line(print, &p, buffer, '\n');
-				QLI_skip_line = false;
-				continue;
-			}
-
-		case item_column_header:
-			{
-				qli_rpt* report = print->prt_report;
-				if (report && report->rpt_column_header)
-					FMT_put(report->rpt_column_header, print);
-				continue;
-			}
-
-		case item_report_header:
-			{
-				qli_rpt* report = print->prt_report;
-				if (report && report->rpt_header)
-					FMT_put(report->rpt_header, print);
-				continue;
-			}
-
-		case item_column:
-		case item_tab:
-		case item_space:
-		default:
-			continue;
-		}
-
-		// Handle print items.  Start by by spacing out to the correct column,
-		// forcing a new line if required.
-
-		BUFFER_CHECK(p, item->itm_print_offset + item->itm_print_length + 2);
-		buffer = BUFFER_BEGINNING;
-		const TEXT* const q = buffer + item->itm_print_offset;
-		if (p > q)
-		{
-			put_line(print, &p, buffer, '\n');
-			print_blobs(print, (qli_print_item**) list->nod_arg, (qli_print_item**) ptr);
-		}
-		while (p < q)
-			*p++ = ' ';
-
-		// Next, handle simple formated values
-
-		if (item->itm_dtype != dtype_blob)
-		{
-			const dsc* desc = EVAL_value(item->itm_value);
-			if (!(desc->dsc_missing & DSC_missing))
-				PIC_edit(desc, item->itm_picture, &p, BUFFER_REMAINING(p));
-			else if (item->itm_picture->pic_missing)
-				PIC_edit(desc, item->itm_picture->pic_missing, &p, BUFFER_REMAINING(p));
-			continue;
-		}
-
-		// Finally, handle blobs
-
-		if (!(item->itm_stream = EXEC_open_blob(item->itm_value)))
-			continue;
-
-		if (print_line(item, &p) != EOF)
-		{
-			if (item->itm_flags & ITM_overlapped)
-			{
-				for (;;)
-				{
-					put_line(print, &p, buffer, '\n');
-					while (p < q)
-						*p++ = ' ';
-					if (print_line(item, &p) == EOF)
-						break;
-				}
-			}
-		}
-	}
-
-	put_line(print, &p, buffer, '\n');
-
-	// Now go back until all blobs have been fetched
-
-	print_blobs(print, (qli_print_item**) list->nod_arg, (qli_print_item**) end);
-
-	// Finish by closing all blobs
-	ISC_STATUS_ARRAY status_vector;
-	for (ptr = list->nod_arg; ptr < end; ptr++)
-	{
-		qli_print_item* item = (qli_print_item*) *ptr;
-		if (item->itm_dtype == dtype_blob && item->itm_stream)
-			isc_close_blob(status_vector, &item->itm_stream);
-	}
-}
-
-
-void FMT_put(const TEXT* line, qli_prt* print)
-{
-/**************************************
- *
- *	F M T _ p u t
- *
- **************************************
- *
- * Functional description
- *	Write out an output file.
- *
- **************************************/
-	for (const TEXT* pnewline = line; *pnewline; pnewline++)
-	{
-		if (*pnewline == '\n' || *pnewline == '\f')
-			--print->prt_lines_remaining;
-	}
-
-	if (print && print->prt_file)
-	{
-		fprintf(print->prt_file, "%s", line);
-	}
-	else
-	{
-#ifdef DEV_BUILD
-		if (QLI_hex_output)
-		{
-			// Hex mode output to assist debugging of multicharset work
-
-			for (const TEXT* p = line; *p; p++)
-			{
-				if (is_printable(*p))
-					fprintf(stdout, "%c", *p);
-				else
-					fprintf(stdout, "[%2.2X]", *(UCHAR*) p);
-			}
-		}
-		else
-#endif
-			fprintf(stdout, "%s", line);
-		QLI_skip_line = true;
-	}
-}
-
-
-void FMT_report( qli_rpt* report)
-{
-/**************************************
- *
- *	F M T _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Format a report.
- *
- **************************************/
-	if (global_fmt_buffer)
-	{
-		ALLQ_release((qli_frb*) global_fmt_buffer);
-		global_fmt_buffer = NULL;
-	}
-
-	USHORT width = report->rpt_columns;
-	qli_vec* columns_vec = (qli_vec*) ALLOCDV(type_vec, 256);
-	columns_vec->vec_count = 256;
-	columns_vec->vec_object[0] = NULL;
-
-	report_break(report->rpt_top_rpt, &columns_vec, false);
-	report_break(report->rpt_top_page, &columns_vec, false);
-	report_break(report->rpt_top_breaks, &columns_vec, false);
-
-	qli_nod* list = report->rpt_detail_line;
-	if (list)
-		report_line(list, &columns_vec);
-
-	report_break(report->rpt_bottom_breaks, &columns_vec, true);
-	report_break(report->rpt_bottom_page, &columns_vec, true);
-	report_break(report->rpt_bottom_rpt, &columns_vec, true);
-
-	report->rpt_column_header = format_report(columns_vec, width, &width);
-
-	// Handle report name, if any
-
-	if (report->rpt_name)
-	{
-		USHORT lengths[16];
-		const TEXT* segments[16];
-		const USHORT n = decompose_header(report->rpt_name, segments, lengths);
-		USHORT i;
-		for (i = 0; i < n; i++)
-			width = MAX(width, lengths[i] + 15);
-
-		qli_str* string = (qli_str*) ALLOCDV(type_str, width * n);
-		TEXT* p = string->str_data;
-		report->rpt_header = p;
-		for (i = 0; i < n; i++)
-		{
-			USHORT column = (width - lengths[i]) / 2;
-			if (column > 0)
-				do {
-					*p++ = ' ';
-				} while (--column);
-			const TEXT* q = segments[i];
-			const TEXT* const end = q + lengths[i];
-			while (q < end)
-				*p++ = *q++;
-			*p++ = '\n';
-		}
-	}
-}
-
-
-static USHORT decompose_header(const SCHAR* string, const SCHAR** segments, USHORT* lengths)
-{
-/**************************************
- *
- *	d e c o m p o s e _ h e a d e r
- *
- **************************************
- *
- * Functional description
- *	Decompose a header string (aka field name) into segments.
- *	Return the address of and length of each segment (in arrays)
- *	and the number of segments.
- *
- **************************************/
-	if (!string)
-		return 0;
-
-	USHORT n = 0;
-
-	// Handle simple name first
-
-	if (*string != '"' && *string != '\'')
-	{
-		while (*string)
-		{
-			*segments = string;
-			while (*string && *string != '_')
-				string++;
-			*lengths++ = string - *segments++;
-			++n;
-			if (*string == '_')
-				string++;
-		}
-	}
-	else
-	{
-		TEXT c;
-		while (c = *string++)
-		{
-			*segments = string;
-			while (*string++ != c);
-			*lengths++ = string - *segments++ - 1;
-			++n;
-		}
-	}
-
-	return n;
-}
-
-
-static void format_index( qli_print_item* item, qli_nod* field, const bool print_flag)
-{
-/**************************************
- *
- *	f o r m a t _ i n d e x
- *
- **************************************
- *
- * Functional description
- *	Format the label of a subscripted item.
- *
- **************************************/
-	qli_nod* args = 0;
-
-	// Don't bother with anything except non-indexed fields.  Also
-	// ignore subscripted fields with user specified query headers.
-
-	{ // scope
-		const TEXT* qh;
-		if (field->nod_type != nod_field || !(args = field->nod_arg[e_fld_subs]) ||
-			((qh = item->itm_query_header) && (*qh == '"' || *qh == '\'')))
-		{
-			return;
-		}
-	} // scope
-
-	// Start the label with the current query header, if any
-
-	USHORT l;
-	const TEXT* q;
-	if (item->itm_query_header)
-	{
-		q = item->itm_query_header;
-		l = static_cast<USHORT>(strlen(item->itm_query_header));
-	}
-	else
-	{
-		q = ((qli_fld*) field->nod_arg[e_fld_field])->fld_name->sym_string;
-		l = ((qli_fld*) field->nod_arg[e_fld_field])->fld_name->sym_length;
-	}
-
-	USHORT length = l + 2;
-	qli_str* str = NULL;
-	TEXT* p = get_buffer(&str, NULL, length + 32);
-	while (l--)
-		*p++ = *q++;
-
-	// Loop through the subscripts, adding to the label
-
-	const TEXT* r;
-	if (print_flag)
-	{
-		r = "_[";
-		length++;
-	}
-	else
-		r = "[";
-
-	TEXT s[32];
-	qli_nod** ptr = args->nod_arg;
-	for (const qli_nod* const* const end = ptr + args->nod_count; ptr < end; ptr++)
-	{
-		qli_nod* subscript = *ptr;
-		switch (subscript->nod_type)
-		{
-		case nod_constant:
-			sprintf(s, "%" SLONGFORMAT, MOVQ_get_long(&subscript->nod_desc, 0));
-			q = s;
-			l = static_cast<USHORT>(strlen(s));
-			break;
-
-		case nod_variable:
-		case nod_field:
-			q = ((qli_fld*) subscript->nod_arg[e_fld_field])->fld_name->sym_string;
-			l = ((qli_fld*) subscript->nod_arg[e_fld_field])->fld_name->sym_length;
-			break;
-
-		default:
-			// Punt on anything but constants, fields, and variables
-
-			ALLQ_release((qli_frb*) str);
-			return;
-		}
-
-		length += l + 1;
-		p = get_buffer(&str, p, length);
-		while (*r)
-			*p++ = *r++;
-		while (l--)
-			*p++ = *q++;
-		r = ",";
-	}
-
-	if (*r == ',')
-		*p++ = ']';
-	*p = 0;
-	item->itm_query_header = str->str_data;
-}
-
-
-static TEXT* format_report( qli_vec* columns_vec, USHORT width, USHORT* max_width)
-{
-/**************************************
- *
- *	f o r m a t _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Format a report.  Figure out spacing, print formats, and
- *	headers.  Return a pointer to the header string.
- *
- **************************************/
-	qli_nod* node;
-	USHORT lengths[10];
-	const TEXT* segments[10];
-
-	// Make a pass thru print items computing print lengths and header
-	// lengths, and the number of header segments.
-
-	USHORT number_segments, offset, max_offset;
-	number_segments = offset = max_offset = 0;
-	TEXT* bottom = BOTTOM_INIT;
-
-	qli_lls** col = (qli_lls**) columns_vec->vec_object;
-	for (const qli_lls* const* const col_end = col + columns_vec->vec_count;
-		col < col_end && *col; col++)
-	{
-		USHORT column_width = 0, max_print_width = 0;
-		bool right_adjust = false;
-		qli_lls* temp;
-		for (temp = *col; temp; temp = temp->lls_next)
-		{
-			qli_print_item* item = (qli_print_item*) temp->lls_object;
-			switch (item->itm_type)
-			{
-			case item_column:
-				offset = (item->itm_count) ? item->itm_count - 1 : 0;
-				continue;
-
-			case item_skip:
-			case item_new_page:
-			case item_report_header:
-			case item_column_header:
-				offset = 0;
-				continue;
-
-			case item_space:
-				offset += item->itm_count;
-				continue;
-
-			case item_tab:
-				offset = (offset & ~7) + item->itm_count * 8;
-				continue;
-
-			case item_value:
-				max_print_width = MAX(max_print_width, item->itm_print_length);
-				node = item->itm_value;
-				if (node->nod_desc.dsc_dtype >= dtype_short &&
-					node->nod_desc.dsc_dtype <= dtype_double)
-					right_adjust = true;
-			}
-
-			if (item->itm_query_header)
-			{
-				const USHORT n = decompose_header(item->itm_query_header, segments, lengths);
-				number_segments = MAX(n, number_segments);
-				USHORT* ptr = lengths;
-				for (USHORT j = 0; j < n; j++, ptr++)
-					item->itm_header_length = MAX(item->itm_header_length, *ptr);
-			}
-
-			format_value(item, 0);
-			const USHORT w = MAX(item->itm_print_length, item->itm_header_length);
-			column_width = MAX(column_width, w);
-		}
-
-		if (offset + column_width > width)
-			offset = 0;
-
-		const USHORT right_offset = column_width - max_print_width / 2;
-
-		for (temp = *col; temp; temp = temp->lls_next)
-		{
-			qli_print_item* item = (qli_print_item*) temp->lls_object;
-			if (item->itm_type != item_value)
-				continue;
-
-			if (right_adjust)
-				item->itm_print_offset = offset + right_offset - item->itm_print_length;
-			else
-				item->itm_print_offset = offset + (column_width - item->itm_print_length) / 2;
-
-			item->itm_header_offset = offset + column_width / 2;
-
-			// Before we blindly format the header, make sure there already isn't
-			// header information in the same location
-
-			if (item->itm_query_header)
-			{
-				BOTTOM_CHECK(bottom, offset);
-				const TEXT* q = BOTTOM_LINE + offset;
-				while (bottom < q)
-					*bottom++ = ' ';
-				bool flag = true;
-				USHORT l;
-				if (offset && q[-1] != ' ')
-					flag = false;
-				else if (l = MIN(column_width, bottom - q))
-				{
-					const TEXT* p = bottom;
-					while (--l)
-						if (*p++ != ' ')
-						{
-							flag = false;
-							break;
-						}
-					if (flag && p < bottom && *p != ' ')
-						flag = false;
-				}
-				if (flag)
-				{
-					BOTTOM_CHECK(bottom, offset + column_width);
-					for (q = BOTTOM_LINE + offset + column_width; bottom < q;)
-						*bottom++ = '=';
-				}
-				else
-					item->itm_query_header = NULL;
-			}
-		}
-		offset += column_width + 1;
-		max_offset = MAX(max_offset, offset);
-	}
-
-	*max_width = max_offset;
-
-	if (number_segments == 0)
-		return NULL;
-
-	// Allocate a string block big enough to hold all lines of the print header
-
-	USHORT len = bottom - BOTTOM_LINE;
-	qli_str* header = (qli_str*) ALLOCDV(type_str,
-						(max_offset + 1) * (number_segments + 1) + 2 + len);
-	TEXT* p = header->str_data;
-
-	// Generate the various lines of the header line at a time.
-
-	for (USHORT j = 0; j < number_segments; j++)
-	{
-		*p++ = '\n';
-		TEXT* const line = p;
-		col = (qli_lls**) columns_vec->vec_object;
-		for (const qli_lls* const* const col_end = col + columns_vec->vec_count;
-			col < col_end && *col; col++)
-		{
-			for (qli_lls* temp = *col; temp; temp = temp->lls_next)
-			{
-				qli_print_item* item = (qli_print_item*) temp->lls_object;
-				if (item->itm_type != item_value)
-					continue;
-				const USHORT n = decompose_header(item->itm_query_header, segments, lengths);
-				SSHORT segment = j - (number_segments - n);
-				if (segment < 0)
-					continue;
-				USHORT l = lengths[segment];
-				const TEXT* q = line + item->itm_header_offset - l / 2;
-				while (p < q)
-					*p++ = ' ';
-				q = segments[segment];
-				if (l)
-					do {
-						*p++ = *q++;
-					} while (--l);
-			}
-		}
-	}
-
-	// Make one last pass to put in underlining of headers
-
-	if (len = bottom - BOTTOM_LINE)
-	{
-		*p++ = '\n';
-		bottom = BOTTOM_LINE;
-		do {
-			*p++ = *bottom++;
-		} while (--len);
-	}
-
-	*p++ = '\n';
-	*p++ = '\n';
-	*p = 0;
-
-	return header->str_data;
-}
-
-
-static void format_value( qli_print_item* item, int flags)
-{
-/**************************************
- *
- *	f o r m a t _ v a l u e
- *
- **************************************
- *
- * Functional description
- *
- **************************************/
-	const qli_nod* node = item->itm_value;
-	const dsc* desc = &node->nod_desc;
-	item->itm_dtype = desc->dsc_dtype;
-	item->itm_sub_type = desc->dsc_sub_type;
-
-	if (desc->dsc_dtype == dtype_blob)
-	{
-		item->itm_print_length = 40;
-		if (node->nod_type == nod_reference)
-			node = node->nod_arg[0];
-		if (node->nod_type == nod_field)
-		{
-			const qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-			if (field->fld_segment_length)
-				item->itm_print_length = field->fld_segment_length;
-		}
-	}
-	else
-	{
-		pics* picture = PIC_analyze(item->itm_edit_string, desc);
-		item->itm_picture = picture;
-
-		if (node->nod_type == nod_reference)
-			node = node->nod_arg[0];
-
-		const qli_fld* field;
-		if (node->nod_type == nod_field)
-		{
-			field = (qli_fld*) node->nod_arg[e_fld_field];
-			if ((field->fld_flags & FLD_array) && !node->nod_arg[e_fld_subs])
-				ERRQ_print_error(480, field->fld_name->sym_string);
-				// msg 480 can not format unsubscripted array %s
-		}
-
-		if (!(item->itm_picture->pic_missing) && (node->nod_type == nod_field) &&
-			(field = (qli_fld*) node->nod_arg[e_fld_field]) && field->fld_missing)
-		{
-			PIC_missing(field->fld_missing, picture);
-		}
-		item->itm_print_length = picture->pic_length;
-		picture->pic_flags |= flags;
-	}
-}
-
-
-static TEXT* get_buffer(qli_str** str, TEXT* ptr, USHORT length)
-{
-/**************************************
- *
- *	g e t _ b u f f e r
- *
- **************************************
- *
- * Functional description
- *	Make sure we have a large enough buffer.
- *	If the current one is too short, copy the
- *	current buffer to the new one.
- *
- **************************************/
-	if (!*str)
-	{
-		*str = (qli_str*) ALLOCPV(type_str, length);
-		(*str)->str_length = length;
-		return (*str)->str_data;
-	}
-
-	if (length <= (*str)->str_length)
-		return ptr ? ptr : (*str)->str_data;
-
-	qli_str* temp_str = (qli_str*) ALLOCPV(type_str, length);
-	temp_str->str_length = length;
-	TEXT* p = temp_str->str_data;
-	const TEXT* q = (*str)->str_data;
-
-	USHORT l;
-	if (ptr && (l = ptr - q))
-		do {
-			*p++ = *q++;
-		} while (--l);
-
-	ALLQ_release((qli_frb*) *str);
-	*str = temp_str;
-
-	return p;
-}
-
-
-static bool match_expr(const qli_nod* node1, const qli_nod* node2)
-{
-/**************************************
- *
- *	m a t c h _ e x p r
- *
- **************************************
- *
- * Functional description
- *	Compare two nodes for equality of value.
- *
- **************************************/
-
-	// If either is missing, they can't match.
-
-	if (!node1 || !node2)
-		return false;
-
-	if (node1->nod_type == nod_reference)
-		node1 = node1->nod_arg[0];
-
-	if (node2->nod_type == nod_reference)
-		node2 = node2->nod_arg[0];
-
-	// A constant more or less matches anything
-
-	if (node1->nod_type == nod_constant)
-		return true;
-
-	// Hasn't matched yet.  Check for statistical expression
-
-	switch (node1->nod_type)
-	{
-	case nod_average:
-	case nod_max:
-	case nod_min:
-	case nod_total:
-
-	case nod_rpt_average:
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_total:
-	case nod_running_total:
-
-	case nod_agg_average:
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_total:
-		return match_expr(node1->nod_arg[e_stt_value], node2);
-	}
-
-	switch (node2->nod_type)
-	{
-	case nod_average:
-	case nod_max:
-	case nod_min:
-	case nod_total:
-
-	case nod_rpt_average:
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_total:
-	case nod_running_total:
-
-	case nod_agg_average:
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_total:
-		return match_expr(node1, node2->nod_arg[e_stt_value]);
-	}
-
-	if (node1->nod_type == node2->nod_type)
-	{
-		if (node1->nod_type == nod_field)
-		{
-			if (node1->nod_arg[e_fld_field] != node2->nod_arg[e_fld_field] ||
-				node1->nod_arg[e_fld_context] != node2->nod_arg[e_fld_context])
-			{
-				return false;
-			}
-			return true;
-		}
-		const qli_nod* const* ptr1 = node1->nod_arg;
-		const qli_nod* const* ptr2 = node2->nod_arg;
-		for (const qli_nod* const* end = ptr1 + node1->nod_count; ptr1 < end; ++ptr1, ++ptr2)
-		{
-			if (!match_expr(*ptr1, *ptr2))
-				return false;
-		}
-		return true;
-	}
-
-	return false;
-}
-
-
-static void print_blobs( qli_prt* print, qli_print_item** first, qli_print_item** last)
-{
-/**************************************
- *
- *	p r i n t _ b l o b s
- *
- **************************************
- *
- * Functional description
- *	Print any blobs still active in item list.
- *
- **************************************/
-	if (QLI_abort)
-		return;
-
-	qli_print_item** ptr;
-
-	USHORT length = 0;
-	for (ptr = first; ptr < last; ptr++)
-	{
-		const qli_print_item* item = *ptr;
-		if (item->itm_dtype == dtype_blob && item->itm_stream)
-			length = MAX(length, item->itm_print_offset + item->itm_print_length + 2);
-	}
-
-
-	TEXT* buffer = get_buffer(&global_blob_buffer, NULL, length);
-
-	while (!QLI_abort)
-	{
-		bool blob_active = false;
-		TEXT* p = buffer;
-		bool do_line = false;
-		for (ptr = first; ptr < last; ptr++)
-		{
-			qli_print_item* item = *ptr;
-			if (item->itm_dtype != dtype_blob || !item->itm_stream)
-				continue;
-			const TEXT* const end = buffer + item->itm_print_offset;
-			while (p < end)
-				*p++ = ' ';
-			const TEXT* const pp = p;
-			const int c = print_line(item, &p);
-			if (c != EOF)
-				blob_active = true;
-			if (pp != p || c == '\n')
-				do_line = true;
-		}
-		if (do_line)
-			put_line(print, &p, buffer, '\n');
-		if (!blob_active)
-			break;
-	}
-}
-
-
-static int print_line( qli_print_item* item, TEXT** ptr)
-{
-/**************************************
- *
- *	p r i n t _ l i n e
- *
- **************************************
- *
- * Functional description
- *	Print a line of a blob or scratch file.  The
- *	last thing printed.
- *
- **************************************/
-	EXEC_poll_abort();
-
-	// If we're already at end of stream, there's nothing to do
-
-	if (!item->itm_stream)
-		return EOF;
-
-	TEXT* p = *ptr;
-	const USHORT l = item->itm_print_length;
-
-	USHORT length;
-	ISC_STATUS_ARRAY status_vector;
-	const ISC_STATUS status = isc_get_segment(status_vector, &item->itm_stream, &length, l, p);
-	if (status && status != isc_segment)
-	{
-		ISC_STATUS* null_status = 0;
-		isc_close_blob(null_status, &item->itm_stream);
-		if (status != isc_segstr_eof)
-			ERRQ_database_error(0, status_vector);
-		return EOF;
-	}
-
-	// If this is not a partial segment and the last character
-	// is a newline, throw away the newline
-
-	if (!status && length && p[length - 1] == '\n')
-		if (length > 1)
-			--length;
-		else
-			p[0] = ' ';
-
-	*ptr = p + length;
-
-	// Return the last character in the segment.
-	// If the segment is null, return a newline.
-
-	return length ? p[length - 1] : '\n';
-}
-
-
-static void put_line( qli_prt* print, TEXT** ptr, TEXT* buffer, TEXT terminator)
-{
-/**************************************
- *
- *	p u t _ l i n e
- *
- **************************************
- *
- * Functional description
- *	Given a file descriptor, a running output pointer, and the address
- *	of the original buffer, write out the current line and reset the
- *	pointer.
- *
- **************************************/
-
-	*(*ptr)++ = terminator;
-	**ptr = 0;
-	FMT_put(buffer, print);
-	*ptr = buffer;
-}
-
-
-static void report_break( qli_brk* control, qli_vec** columns_vec, const bool bottom_flag)
-{
-/**************************************
- *
- *	r e p o r t _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Handle formatting for a chain of control breaks.
- *
- **************************************/
-
-	if (!control)
-		return;
-
-	if (bottom_flag)
-	{
-		if (control->brk_next)
-			report_break(control->brk_next, columns_vec, bottom_flag);
-		if (control->brk_line)
-			report_line((qli_nod*) control->brk_line, columns_vec);
-		return;
-	}
-
-	for (; control; control = control->brk_next)
-	{
-		if (control->brk_line)
-			report_line((qli_nod*) control->brk_line, columns_vec);
-	}
-}
-
-
-static void report_item( qli_print_item* item, qli_vec** columns_vec, USHORT* col_ndx)
-{
-/**************************************
- *
- *	r e p o r t _ i t e m
- *
- **************************************
- *
- * Functional description
- *	Insert a report item into a logical column.  It it fits
- *	someplace reasonable, stick it there.
- *
- **************************************/
-	if (item->itm_query_header && *item->itm_query_header == '-')
-		item->itm_query_header = NULL;
-
-	// If it's a constant, dump it in the next logical column
-
-	qli_nod* node;
-	qli_vec* columns = *columns_vec;
-	if (columns->vec_object[*col_ndx] &&
-		(node = item->itm_value) && node->nod_type == nod_constant)
-	{
-		ALLQ_push((blk*) item, (qli_lls**) (columns->vec_object + *col_ndx));
-		return;
-	}
-
-	// Loop thru remaining logical columns looking for an equivalent
-	// expression.  If we find one, the item beSLONGs in that column;
-	// otherwise, someplace else.
-
-	qli_lls** col = (qli_lls**) (columns->vec_object + *col_ndx);
-	const qli_lls* const* const col_end = (qli_lls**) (columns->vec_object + columns->vec_count);
-	for (; col < col_end && *col; col++)
-		for (qli_lls* temp = *col; temp; temp = temp->lls_next)
-		{
-			qli_print_item* item2 = (qli_print_item*) temp->lls_object;
-			if (match_expr(item->itm_value, item2->itm_value))
-			{
-				ALLQ_push((blk*) item, col);
-				*col_ndx = col - (qli_lls**) columns->vec_object;
-				return;
-			}
-		}
-
-	// Didn't fit -- make a new logical column
-
-	const USHORT new_index = col - (qli_lls**) columns->vec_object;
-	*col_ndx = new_index;
-	if (new_index >= columns->vec_count)
-	{
-		ALLQ_extend((BLK*) columns_vec, new_index + 16);
-		(*columns_vec)->vec_count = new_index + 16;
-	}
-
-	ALLQ_push((blk*) item, (qli_lls**) ((*columns_vec)->vec_object + new_index));
-}
-
-
-static void report_line( qli_nod* list, qli_vec** columns_vec)
-{
-/**************************************
- *
- *	r e p o r t _ l i n e
- *
- **************************************
- *
- * Functional description
- *	Process a report line.
- *
- **************************************/
-	USHORT col_ndx = 0;
-	qli_print_item** ptr = (qli_print_item**) list->nod_arg;
-	for (const qli_print_item* const* const end = ptr + list->nod_count; ptr < end; ptr++)
-	{
-		qli_print_item* item = *ptr;
-		report_item(item, columns_vec, &col_ndx);
-		switch (item->itm_type)
-		{
-		case item_skip:
-		case item_new_page:
-			col_ndx = 0;
-			break;
-		}
-	}
-}
-
-
diff --git a/src/qli/format.h b/src/qli/format.h
deleted file mode 100644
index ba7cc2d878..0000000000
--- a/src/qli/format.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		format.h
- *	DESCRIPTION:	Print formatter definitions
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_FORMAT_H
-#define QLI_FORMAT_H
-
-/* Picture string elements:
-
-    A		any alpha character (interpreted as X)
-    B		blank character
-    CR		credit (sign)
-    D		day of month (digit)
-    DB		debit (sign)
-    E		exponent
-    G		exponent or decimal format, whichever is shorter
-    H		hex digit
-    J		day of year (digit)
-    M		alpha month
-    N		month (numeric)
-    P		AM/PM indicator for time
-    T		time
-    W		weekday (character)
-    X		any character
-    Y		year (digit)
-    Z		digit or leading suppressed digit (blank)
-    9		digit
-    $		fixed or floating insertion
-    *		floating insertion
-    ,		literal character or inserted
-    .		decimal point
-    +		sign (fixed or floating), always present
-    -		sign (fixed or floating), suppressed on positive, or literal
-    ?		separate between real and missing components of edit string
-    "string"	any string
-    (( ))	insert parenthesis if negative
-    /		literal insertion
-    %		literal insertion
-    :		literal insertion
-*/
-
-enum pic_t {
-    pic_alpha = 1,
-    pic_numeric,
-    pic_date,
-    pic_float
-    // , pic_text // unused
-};
-
-// Picture string handling block
-
-struct pics
-{
-    blk		pic_header;
-    USHORT	pic_print_length;	// Print length of picture string
-    const TEXT*	pic_string;		// Address of string
-    const TEXT*	pic_pointer;		// Address of string
-    USHORT	pic_flags;		// Misc. trash
-    USHORT	pic_count;		// Count of repeat characters
-    TEXT	pic_character;		// Last significant character
-    pic_t	pic_type;		// Type of edit
-    USHORT	pic_length;		// Printing columns (MAX of edit_string & missing)
-    USHORT	pic_floats;		// Character of floating things
-    USHORT	pic_digits;		// Digits of number
-    USHORT	pic_hex_digits;		// Hexidecimal digits
-    USHORT	pic_fractions;		// Digits after decimal point
-    USHORT	pic_chars;		// Insertion characters (alpha)
-    USHORT	pic_literals;		// Literal insertion characters
-    USHORT	pic_days;		// Digits of day of month
-    USHORT	pic_weekdays;		// Characters of weekday
-    USHORT	pic_months;		// Characters of alpha month
-    USHORT	pic_nmonths;		// Digits of numeric month
-    USHORT	pic_years;		// Digits of year
-    USHORT	pic_julians;		// Digits of julian days
-    USHORT	pic_decimals;		// Number of decimal points (?!)
-    USHORT	pic_brackets;		// Pairs of deficit brackets
-    USHORT	pic_exponents;		// Exponential indicators
-    USHORT	pic_float_digits;	// Floating digits
-    USHORT	pic_hours;		// hours
-    USHORT	pic_minutes;		// minutes
-    USHORT	pic_seconds;		// seconds
-    USHORT	pic_meridian;		// AM/PM indicator
-    pics*	pic_missing;		// missing value edit string
-};
-
-// pic_flags
-const USHORT PIC_suppress_blanks	= 1;	// Suppress leading blanks
-const USHORT PIC_literal			= 2;	// We're in a quoted string
-const USHORT PIC_signed				= 4;	// This numeric edit string has a sign indicator
-
-#endif // QLI_FORMAT_H
-
diff --git a/src/qli/gener.cpp b/src/qli/gener.cpp
deleted file mode 100644
index 14e0ea35ba..0000000000
--- a/src/qli/gener.cpp
+++ /dev/null
@@ -1,1945 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		gener.cpp
- *	DESCRIPTION:	BLR Generation Module
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- *
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <string.h>
-#include "ibase.h"
-#include "../qli/dtr.h"
-#include "../jrd/align.h"
-#include "../qli/exe.h"
-#include "../qli/compile.h"
-#include "../qli/report.h"
-#include "../qli/all_proto.h"
-#include "../qli/compi_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/gener_proto.h"
-#include "../qli/meta_proto.h"
-#include "../qli/mov_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../common/gdsassert.h"
-
-#ifdef DEV_BUILD
-#include "../jrd/constants.h"
-static void explain(qli_dbb* db, const UCHAR*);
-static void explain_index_tree(qli_dbb* db, int, const TEXT*, const UCHAR**, int*);
-static void explain_printf(int, const TEXT*, const TEXT*);
-#endif
-
-static void gen_any(qli_nod*, qli_req*);
-static void gen_assignment(qli_nod*, qli_req*);
-static void gen_control_break(qli_brk*, qli_req*);
-static void gen_compile(qli_req*);
-static void gen_descriptor(const dsc*, qli_req*);
-static void gen_erase(qli_nod*, qli_req*);
-static void gen_expression(qli_nod*, qli_req*);
-static void gen_field(qli_nod*, qli_req*);
-static void gen_for(qli_nod*, qli_req*);
-static void gen_function(qli_nod*, qli_req*);
-static void gen_if(qli_nod*, qli_req*);
-static void gen_literal(const dsc*, qli_req*);
-static void gen_map(qli_map*, qli_req*);
-static void gen_modify(qli_nod*); //, qli_req*);
-static void gen_parameter(const qli_par*, qli_req*);
-static void gen_print_list(qli_nod*, qli_req*);
-static void gen_report(qli_nod*, qli_req*);
-static void gen_request(qli_req*);
-static void gen_rse(qli_nod*, qli_req*);
-static void gen_send_receive(const qli_msg*, USHORT);
-static void gen_sort(qli_nod*, qli_req*, const UCHAR);
-static void gen_statement(qli_nod*, qli_req*);
-static void gen_statistical(qli_nod*, qli_req*);
-static void gen_store(qli_nod*, qli_req*);
-
-#ifdef DEV_BUILD
-static const SCHAR explain_info[] = { isc_info_access_path };
-#endif
-
-
-qli_nod* GEN_generate( qli_nod* node)
-{
-/**************************************
- *
- *	G E N _ g e n e r a t e
- *
- **************************************
- *
- * Functional description
- *	Generate and compile BLR.
- *
- **************************************/
-
-	gen_statement(node, 0);
-
-	return node;
-}
-
-
-void GEN_release()
-{
-/**************************************
- *
- *	G E N _ r e l e a s e
- *
- **************************************
- *
- * Functional description
- *	Release any compiled requests following execution or abandonment
- *	of a request.  Just recurse around and release requests.
- *
- **************************************/
-	for (; QLI_requests; QLI_requests = QLI_requests->req_next)
-	{
-		if (QLI_requests->req_handle)
-		{
-			ISC_STATUS_ARRAY status_vector;
-			isc_release_request(status_vector, &QLI_requests->req_handle);
-		}
-
-		qli_rlb* rlb = QLI_requests->req_blr;
-		GEN_rlb_release (rlb);
-	}
-}
-
-
-qli_rlb* GEN_rlb_extend(qli_rlb* rlb)
-{
-/**************************************
- *
- *	G E N _ r l b _ e x t e n d
- *
- **************************************
- *
- * Functional description
- *
- *	Allocate a new larger request language buffer
- *	and copy generated request language into it
- *
- **************************************/
-	if (!rlb)
-		rlb = (qli_rlb*) ALLOCD(type_rlb);
-
-	UCHAR* const old_string = rlb->rlb_base;
-	const ULONG len = rlb->rlb_data - rlb->rlb_base;
-	rlb->rlb_length += RLB_BUFFER_SIZE;
-	UCHAR* new_string = (UCHAR*) ALLQ_malloc((SLONG) rlb->rlb_length);
-	if (old_string)
-	{
-		memcpy(new_string, old_string, len);
-		ALLQ_free(old_string);
-	}
-	rlb->rlb_base = new_string;
-	rlb->rlb_data = new_string + len;
-	rlb->rlb_limit = rlb->rlb_data + RLB_BUFFER_SIZE - RLB_SAFETY_MARGIN;
-
-	return rlb;
-}
-
-
-void GEN_rlb_release( qli_rlb* rlb)
-{
-/**************************************
- *
- *	G E N _ r l b _ r e l e a s e
- *
- **************************************
- *
- * Functional description
- *
- *	Release the request language buffer
- *	contents.  The buffer itself will go away
- *	with the default pool.
- *
- **************************************/
-
-	if (!rlb)
-		return;
-
-	if (rlb->rlb_base)
-	{
-		ALLQ_free(rlb->rlb_base);
-		rlb->rlb_base = NULL;
-		rlb->rlb_length = 0;
-		rlb->rlb_data = NULL;
-		rlb->rlb_limit = NULL;
-	}
-}
-
-
-#ifdef DEV_BUILD
-static void explain(qli_dbb* db, const UCHAR* explain_buffer)
-{
-/**************************************
- *
- *	e x p l a i n
- *
- **************************************
- *
- * Functional description
- *	Print out the access path for a blr
- *	request in pretty-printed form.
- *
- **************************************/
-	int level = 0;
-	SCHAR relation_name[MAX_SQL_IDENTIFIER_SIZE];
-	// CVC: This function may have the same bugs as the internal function
-	// used in the engine, that received fixes in FB1 & FB1.5.
-
-	if (*explain_buffer++ != isc_info_access_path)
-		return;
-
-	int buffer_length = (unsigned int) *explain_buffer++;
-	buffer_length += (unsigned int) (*explain_buffer++) << 8;
-
-	while (buffer_length > 0)
-	{
-		buffer_length--;
-		switch (*explain_buffer++)
-		{
-		case isc_info_rsb_begin:
-			explain_printf(level, "isc_info_rsb_begin,\n", 0);
-			level++;
-			break;
-
-		case isc_info_rsb_end:
-			explain_printf(level, "isc_info_rsb_end,\n", 0);
-			level--;
-			break;
-
-		case isc_info_rsb_relation:
-			{
-				explain_printf(level, "isc_info_rsb_relation, ", 0);
-
-				buffer_length--;
-				const FB_SIZE_T length = *explain_buffer++;
-				fb_assert(length < MAX_SQL_IDENTIFIER_SIZE);
-				buffer_length -= length;
-
-				memcpy(relation_name, explain_buffer, length);
-				relation_name[length] = 0;
-				explain_buffer += length;
-				printf("%s,\n", relation_name);
-			}
-			break;
-
-		case isc_info_rsb_type:
-			buffer_length--;
-			explain_printf(level, "isc_info_rsb_type, ", 0);
-			switch (*explain_buffer++)
-			{
-			case isc_info_rsb_unknown:
-				printf("unknown type\n");
-				break;
-
-			case isc_info_rsb_indexed:
-				printf("isc_info_rsb_indexed,\n");
-				level++;
-				explain_index_tree(db, level, relation_name, &explain_buffer, &buffer_length);
-				level--;
-				break;
-
-				// for join types, advance past the count byte
-				// of substreams; we don't need it
-
-			case isc_info_rsb_merge:
-				buffer_length--;
-				printf("isc_info_rsb_merge, %d,\n", *explain_buffer++);
-				break;
-
-			case isc_info_rsb_cross:
-				buffer_length--;
-				printf("isc_info_rsb_cross, %d,\n", *explain_buffer++);
-				break;
-
-			case isc_info_rsb_navigate:
-				printf("isc_info_rsb_navigate,\n");
-				level++;
-				explain_index_tree(db, level, relation_name, &explain_buffer, &buffer_length);
-				level--;
-				break;
-
-			case isc_info_rsb_sequential:
-				printf("isc_info_rsb_sequential,\n");
-				break;
-
-			case isc_info_rsb_sort:
-				printf("isc_info_rsb_sort,\n");
-				break;
-
-			case isc_info_rsb_first:
-				printf("isc_info_rsb_first,\n");
-				break;
-
-			case isc_info_rsb_boolean:
-				printf("isc_info_rsb_boolean,\n");
-				break;
-
-			case isc_info_rsb_union:
-				printf("isc_info_rsb_union,\n");
-				break;
-
-			case isc_info_rsb_aggregate:
-				printf("isc_info_rsb_aggregate,\n");
-				break;
-
-			case isc_info_rsb_ext_sequential:
-				printf("isc_info_rsb_ext_sequential,\n");
-				break;
-
-			case isc_info_rsb_ext_indexed:
-				printf("isc_info_rsb_ext_indexed,\n");
-				break;
-
-			case isc_info_rsb_ext_dbkey:
-				printf("isc_info_rsb_ext_dbkey,\n");
-				break;
-
-			case isc_info_rsb_left_cross:
-				printf("isc_info_rsb_left_cross,\n");
-				break;
-
-			case isc_info_rsb_select:
-				printf("isc_info_rsb_select,\n");
-				break;
-
-			case isc_info_rsb_sql_join:
-				printf("isc_info_rsb_sql_join,\n");
-				break;
-
-			case isc_info_rsb_simulate:
-				printf("isc_info_rsb_simulate,\n");
-				break;
-
-			case isc_info_rsb_sim_cross:
-				printf("isc_info_rsb_sim_cross,\n");
-				break;
-
-			case isc_info_rsb_once:
-				printf("isc_info_rsb_once,\n");
-				break;
-
-			case isc_info_rsb_procedure:
-				printf("isc_info_rsb_procedure,\n");
-				break;
-
-			}
-			break;
-
-		default:
-			explain_printf(level, "unknown info item\n", 0);
-			break;
-		}
-	}
-}
-#endif
-
-
-#ifdef DEV_BUILD
-static void explain_index_tree(qli_dbb* db, int level, const TEXT* relation_name,
-							   const UCHAR** explain_buffer_ptr, int* buffer_length)
-{
-/**************************************
- *
- *	e x p l a i n _ i n d e x _ t r e e
- *
- **************************************
- *
- * Functional description
- *	Print out an index tree access path.
- *
- **************************************/
-
-	const UCHAR* explain_buffer = *explain_buffer_ptr;
-
-	(*buffer_length)--;
-
-	switch (*explain_buffer++)
-	{
-	case isc_info_rsb_and:
-		explain_printf(level, "isc_info_rsb_and,\n", 0);
-		level++;
-		explain_index_tree(db, level, relation_name, &explain_buffer, buffer_length);
-		explain_index_tree(db, level, relation_name, &explain_buffer, buffer_length);
-		level--;
-		break;
-
-	case isc_info_rsb_or:
-		explain_printf(level, "isc_info_rsb_or,\n", 0);
-		level++;
-		explain_index_tree(db, level, relation_name, &explain_buffer, buffer_length);
-		explain_index_tree(db, level, relation_name, &explain_buffer, buffer_length);
-		level--;
-		break;
-
-	case isc_info_rsb_dbkey:
-		explain_printf(level, "isc_info_rsb_dbkey,\n", 0);
-		break;
-
-	case isc_info_rsb_index:
-		{
-			explain_printf(level, "isc_info_rsb_index, ", 0);
-			(*buffer_length)--;
-
-			const FB_SIZE_T length = *explain_buffer++;
-			TEXT index_name[MAX_SQL_IDENTIFIER_SIZE];
-			memcpy(index_name, explain_buffer, length);
-			index_name[length] = 0;
-
-			*buffer_length -= length;
-			explain_buffer += length;
-
-			SCHAR index_info[256];
-			MET_index_info(db, relation_name, index_name, index_info, sizeof(index_info));
-			printf("%s\n", index_info);
-		}
-		break;
-	}
-
-	if (*explain_buffer == isc_info_rsb_end)
-	{
-		explain_buffer++;
-		(*buffer_length)--;
-	}
-
-	*explain_buffer_ptr = explain_buffer;
-}
-#endif
-
-
-
-#ifdef DEV_BUILD
-static void explain_printf(int level, const TEXT* control, const TEXT* string)
-{
-/**************************************
- *
- *	e x p l a i n _ p r i n t f
- *
- **************************************
- *
- * Functional description
- *	Do a printf with formatting.
- *
- **************************************/
-
-	while (level--)
-		printf("   ");
-
-	if (string)
-		printf(control, string);
-	else
-		printf("%s", control);
-}
-#endif
-
-
-static void gen_any( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ a n y
- *
- **************************************
- *
- * Functional description
- *	Generate the BLR for a statistical expresionn.
- *
- **************************************/
-	qli_rlb* rlb;
-
-	// If there is a request associated with the statement, prepare to
-	// generate BLR.  Otherwise assume that a request is alrealdy initialized.
-
-	qli_req* new_request = (qli_req*) node->nod_arg[e_any_request];
-	if (new_request)
-	{
-		request = new_request;
-		gen_request(request);
-		const qli_msg* receive = (qli_msg*) node->nod_arg[e_any_send];
-		if (receive)
-			gen_send_receive(receive, blr_receive);
-		const qli_msg* send = (qli_msg*) node->nod_arg[e_any_receive];
-		gen_send_receive(send, blr_send);
-		rlb = CHECK_RLB(request->req_blr);
-		STUFF(blr_if);
-	}
-	else
-		rlb = CHECK_RLB(request->req_blr);
-
-	STUFF(blr_any);
-	gen_rse(node->nod_arg[e_any_rse], request);
-
-	USHORT value; // not feasible to change it to bool.
-	dsc desc;
-	if (new_request)
-	{
-		desc.dsc_dtype = dtype_short;
-		desc.dsc_length = sizeof(SSHORT);
-		desc.dsc_scale = 0;
-		desc.dsc_sub_type = 0;
-		desc.dsc_address = (UCHAR*) &value;
-		QLI_validate_desc(desc);
-
-		STUFF(blr_assignment);
-		value = TRUE;
-		gen_literal(&desc, request);
-		gen_parameter(node->nod_import, request);
-
-		STUFF(blr_assignment);
-		value = FALSE;
-		gen_literal(&desc, request);
-		gen_parameter(node->nod_import, request);
-		gen_compile(request);
-	}
-}
-
-
-static void gen_assignment( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ a s s i g n m e n t
- *
- **************************************
- *
- * Functional description
- *	Generate an assignment statement.
- *
- **************************************/
-	qli_nod* from = node->nod_arg[e_asn_from];
-
-	// Handle a local expression locally
-
-	if (node->nod_flags & NOD_local)
-	{
-		gen_expression(from, 0);
-		return;
-	}
-
-	// Generate a remote assignment
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	STUFF(blr_assignment);
-	qli_nod* target = node->nod_arg[e_asn_to];
-
-	// If we are referencing a parameter of another request, compile
-	// the request first, the make a reference.  Otherwise, just compile
-	// the expression in the context of this request
-
-	const qli_nod* reference = target->nod_arg[e_fld_reference];
-	if (reference)
-	{
-		gen_expression(from, 0);
-		gen_parameter(reference->nod_import, request);
-	}
-	else
-		gen_expression(from, request);
-
-	qli_nod* validation = node->nod_arg[e_asn_valid];
-	if (validation)
-		gen_expression(validation, 0);
-
-	gen_expression(target, request);
-}
-
-
-static void gen_control_break( qli_brk* control, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ c o n t r o l _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Process report writer control breaks.
- *
- **************************************/
-
-	for (; control; control = control->brk_next)
-	{
-		if (control->brk_field)
-			gen_expression((qli_nod*) control->brk_field, request);
-		if (control->brk_line)
-			gen_print_list((qli_nod*) control->brk_line, request);
-	}
-}
-
-
-static void gen_compile( qli_req* request)
-{
-/**************************************
- *
- *	g e n _ c o m p i l e
- *
- **************************************
- *
- * Functional description
- *	Finish off BLR generation for a request, and get it compiled.
- *
- **************************************/
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-	STUFF(blr_end);
-	STUFF(blr_eoc);
-
-	const USHORT length = rlb->rlb_data - rlb->rlb_base;
-
-	if (QLI_blr)
-		fb_print_blr(rlb->rlb_base, length, 0, 0, 0);
-
-	qli_dbb* dbb = request->req_database;
-
-	ISC_STATUS_ARRAY status_vector;
-	if (isc_compile_request(status_vector, &dbb->dbb_handle, &request->req_handle, length,
-							 (const char*) rlb->rlb_base))
-	{
-		GEN_rlb_release (rlb);
-		ERRQ_database_error(dbb, status_vector);
-	}
-
-#ifdef DEV_BUILD
-	SCHAR explain_buffer[512];
-	if (QLI_explain &&
-		!isc_request_info(status_vector, &request->req_handle, 0,
-						   sizeof(explain_info), explain_info,
-						   sizeof(explain_buffer), explain_buffer))
-	{
-		explain(dbb, (UCHAR*) explain_buffer);
-	}
-#endif
-
-	GEN_rlb_release (rlb);
-}
-
-
-static void gen_descriptor(const dsc* desc, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ d e s c r i p t o r
- *
- **************************************
- *
- * Functional description
- *	Generator a field descriptor.  This is used for generating both
- *	message declarations and literals.
- *
- **************************************/
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	switch (desc->dsc_dtype)
-	{
-
-	case dtype_text:
-		STUFF(blr_text);
-		STUFF_WORD(desc->dsc_length);
-		break;
-
-	case dtype_varying:
-		STUFF(blr_varying);
-		STUFF_WORD((desc->dsc_length - static_cast<USHORT>(sizeof(SSHORT))));
-		break;
-
-	case dtype_cstring:
-		STUFF(blr_cstring);
-		STUFF_WORD(desc->dsc_length);
-		break;
-
-	case dtype_short:
-		STUFF(blr_short);
-		STUFF(desc->dsc_scale);
-		break;
-
-	case dtype_int64:
-		STUFF(blr_int64);
-		STUFF(desc->dsc_scale);
-		break;
-
-	case dtype_long:
-		STUFF(blr_long);
-		STUFF(desc->dsc_scale);
-		break;
-
-	case dtype_blob:
-	case dtype_quad:
-		STUFF(blr_quad);
-		STUFF(desc->dsc_scale);
-		break;
-
-	case dtype_real:
-		STUFF(blr_float);
-		break;
-
-	case dtype_double:
-		STUFF(blr_double);
-		break;
-
-	case dtype_timestamp:
-		STUFF(blr_timestamp);
-		break;
-
-	case dtype_sql_date:
-		STUFF(blr_sql_date);
-		break;
-
-	case dtype_sql_time:
-		STUFF(blr_sql_time);
-		break;
-
-	default:
-		ERRQ_bugcheck(352);			// Msg352 gen_descriptor: dtype not recognized
-	}
-}
-
-
-static void gen_erase( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ e r a s e
- *
- **************************************
- *
- * Functional description
- *	Generate the BLR for an erase statement.  Pretty simple.
- *
- **************************************/
-	const qli_msg* message = (qli_msg*) node->nod_arg[e_era_message];
-	if (message)
-	{
-		request = (qli_req*) node->nod_arg[e_era_request];
-		gen_send_receive(message, blr_receive);
-	}
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_era_context];
-	STUFF(blr_erase);
-	STUFF(context->ctx_context);
-}
-
-
-static void gen_expression(qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ e x p r e s s i o n
- *
- **************************************
- *
- * Functional description
- *	Generate the BLR for a boolean or value expression.
- *
- **************************************/
-	USHORT operatr = 0;
-	qli_rlb* rlb = 0;
-
-	if (node->nod_flags & NOD_local)
-	{
-		request = NULL;
-		//return;
-	}
-	else if (request)
-		rlb = CHECK_RLB(request->req_blr);
-
-	switch (node->nod_type)
-	{
-	case nod_any:
-		gen_any(node, request);
-		return;
-
-	case nod_unique:
-		if (request)
-		{
-			STUFF(blr_unique);
-			gen_rse(node->nod_arg[e_any_rse], request);
-		}
-		return;
-
-	case nod_constant:
-		if (request)
-			gen_literal(&node->nod_desc, request);
-		return;
-
-	case nod_field:
-		gen_field(node, request);
-		return;
-
-	case nod_format:
-		gen_expression(node->nod_arg[e_fmt_value], request);
-		return;
-
-	case nod_map:
-		{
-			qli_map* map = (qli_map*) node->nod_arg[e_map_map];
-			const qli_ctx* context = (qli_ctx*) node->nod_arg[e_map_context];
-			if (context->ctx_request != request && map->map_node->nod_type == nod_field)
-			{
-				gen_field(map->map_node, request);
-				return;
-			}
-			STUFF(blr_fid);
-			STUFF(context->ctx_context);
-			STUFF_WORD(map->map_position);
-			return;
-		}
-
-	case nod_eql:
-		operatr = blr_eql;
-		break;
-
-	case nod_neq:
-		operatr = blr_neq;
-		break;
-
-	case nod_gtr:
-		operatr = blr_gtr;
-		break;
-
-	case nod_geq:
-		operatr = blr_geq;
-		break;
-
-	case nod_leq:
-		operatr = blr_leq;
-		break;
-
-	case nod_lss:
-		operatr = blr_lss;
-		break;
-
-	case nod_containing:
-		operatr = blr_containing;
-		break;
-
-	case nod_matches:
-		operatr = blr_matching;
-		break;
-
-	case nod_sleuth:
-		operatr = blr_matching2;
-		break;
-
-	case nod_like:
-		operatr = (node->nod_count == 2) ? blr_like : blr_ansi_like;
-		break;
-
-	case nod_starts:
-		operatr = blr_starting;
-		break;
-
-	case nod_missing:
-		operatr = blr_missing;
-		break;
-
-	case nod_between:
-		operatr = blr_between;
-		break;
-
-	case nod_and:
-		operatr = blr_and;
-		break;
-
-	case nod_or:
-		operatr = blr_or;
-		break;
-
-	case nod_not:
-		operatr = blr_not;
-		break;
-
-	case nod_add:
-		operatr = blr_add;
-		break;
-
-	case nod_subtract:
-		operatr = blr_subtract;
-		break;
-
-	case nod_multiply:
-		operatr = blr_multiply;
-		break;
-
-	case nod_divide:
-		operatr = blr_divide;
-		break;
-
-	case nod_negate:
-		operatr = blr_negate;
-		break;
-
-	case nod_concatenate:
-		operatr = blr_concatenate;
-		break;
-
-	case nod_substr:
-		operatr = blr_substring;
-		break;
-
-	case nod_function:
-		gen_function(node, request);
-		return;
-
-	case nod_agg_average:
-	case nod_agg_count:
-	case nod_agg_max:
-	case nod_agg_min:
-	case nod_agg_total:
-
-	case nod_average:
-	case nod_count:
-	case nod_max:
-	case nod_min:
-	case nod_total:
-	case nod_from:
-		gen_statistical(node, request);
-		return;
-
-	case nod_rpt_average:
-	case nod_rpt_count:
-	case nod_rpt_max:
-	case nod_rpt_min:
-	case nod_rpt_total:
-
-	case nod_running_total:
-	case nod_running_count:
-		if (node->nod_arg[e_stt_value])
-			gen_expression(node->nod_arg[e_stt_value], request);
-		if (node->nod_export)
-			gen_parameter(node->nod_export, request);
-		request = NULL;
-		break;
-
-	case nod_prompt:
-	case nod_variable:
-		if (node->nod_export)
-			gen_parameter(node->nod_export, request);
-		return;
-
-	case nod_edit_blob:
-	case nod_reference:
-		return;
-
-	case nod_null:
-		operatr = blr_null;
-		break;
-
-	case nod_user_name:
-		operatr = blr_user_name;
-		break;
-
-	case nod_upcase:
-		operatr = blr_upcase;
-		break;
-
-	case nod_lowcase:
-		operatr = blr_lowcase;
-		break;
-
-	default:
-		if (request && node->nod_export)
-		{
-			gen_parameter(node->nod_export, request);
-			return;
-		}
-		ERRQ_bugcheck(353);			// Msg353 gen_expression: not understood
-	}
-
-	if (request)
-	{
-		rlb = CHECK_RLB(request->req_blr);
-		STUFF(operatr);
-	}
-
-	qli_nod** ptr = node->nod_arg;
-	for (qli_nod** const end = ptr + node->nod_count; ptr < end; ptr++)
-		gen_expression(*ptr, request);
-
-	if (!node->nod_desc.dsc_address && node->nod_desc.dsc_length)
-		CMP_alloc_temp(node);
-}
-
-
-static void gen_field( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Compile BLR to handle a field reference.  Things varying
- *	substantially depend on whether the field reference spans
- *	requests or not.
- *
- **************************************/
-	// If there isn't a request specified, this is a reference.
-
-	if (!request)
-		return;
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	const qli_fld* field = (qli_fld*) node->nod_arg[e_fld_field];
-	const qli_ctx* context = (qli_ctx*) node->nod_arg[e_fld_context];
-
-	// If the field referenced is in this request, just generate a field reference.
-
-	if (context->ctx_request == request)
-	{
-		qli_nod* args = node->nod_arg[e_fld_subs];
-		if (args)
-			STUFF(blr_index);
-		STUFF(blr_fid);
-		STUFF(context->ctx_context);
-		STUFF_WORD(field->fld_id);
-		if (args)
-		{
-			STUFF(args->nod_count);
-			qli_nod** ptr = args->nod_arg;
-			for (const qli_nod* const* const end = ptr + args->nod_count; ptr < end; ++ptr)
-			{
-				gen_expression(*ptr, request);
-			}
-		}
-		return;
-	}
-
-	// The field is in a different request.  Make a parameter reference instead.
-
-	gen_parameter(node->nod_export, request);
-}
-
-
-static void gen_for( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ f o r
- *
- **************************************
- *
- * Functional description
- *	Generate BLR for a FOR loop, included synchronization messages.
- *
- **************************************/
-
-	// If there is a request associated with the statement, prepare to
-	// generate BLR.  Otherwise assume that a request is alrealdy initialized.
-
-	if (node->nod_arg[e_for_request])
-	{
-		request = (qli_req*) node->nod_arg[e_for_request];
-		gen_request(request);
-	}
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	// If the statement requires an end of file marker, build a BEGIN/END around
-	// the whole statement.
-
-	const qli_msg* message = (qli_msg*) node->nod_arg[e_for_receive];
-	if (message)
-		STUFF(blr_begin);
-
-	// If there is a message to be sent, build a receive for it
-
-	if (node->nod_arg[e_for_send])
-		gen_send_receive((qli_msg*) node->nod_arg[e_for_send], blr_receive);
-
-	// Generate the FOR loop proper.
-
-	STUFF(blr_for);
-	gen_rse(node->nod_arg[e_for_rse], request);
-	STUFF(blr_begin);
-
-	// If data is to be received (included EOF), build a send
-
-	const qli_par* eof = 0;
-	dsc desc;
-	USHORT value;
-
-	if (message)
-	{
-		gen_send_receive(message, blr_send);
-		STUFF(blr_begin);
-
-		// Build assigments for all values referenced.
-
-		for (const qli_par* parameter = message->msg_parameters; parameter;
-			parameter = parameter->par_next)
-		{
-			if (parameter->par_value)
-			{
-				STUFF(blr_assignment);
-				gen_expression(parameter->par_value, request);
-				gen_parameter(parameter, request);
-			}
-		}
-
-		// Next, make a FALSE for the end of file parameter
-
-		eof = (qli_par*) node->nod_arg[e_for_eof];
-		desc.dsc_dtype = dtype_short;
-		desc.dsc_length = sizeof(SSHORT);
-		desc.dsc_scale = 0;
-		desc.dsc_sub_type = 0;
-		desc.dsc_address = (UCHAR*) &value;
-		QLI_validate_desc(desc);
-
-		STUFF(blr_assignment);
-		value = FALSE;
-		gen_literal(&desc, request);
-		gen_parameter(eof, request);
-
-		STUFF(blr_end);
-	}
-
-	// Build  the body of the loop.
-
-	const qli_msg* continuation = request->req_continue;
-	if (continuation)
-	{
-		STUFF(blr_label);
-		const USHORT label = request->req_label++;
-		STUFF(label);
-		STUFF(blr_loop);
-		STUFF(blr_select);
-		gen_send_receive(continuation, blr_receive);
-		STUFF(blr_leave);
-		STUFF(label);
-	}
-
-	qli_nod* sub = node->nod_arg[e_for_statement];
-	gen_statement(sub, request);
-
-	STUFF(blr_end);
-
-	if (continuation)
-		STUFF(blr_end);
-
-	// Finish off by building a SEND to indicate end of file
-
-	if (message)
-	{
-		gen_send_receive(message, blr_send);
-		STUFF(blr_assignment);
-		value = TRUE;
-		gen_literal(&desc, request);
-		gen_parameter(eof, request);
-		STUFF(blr_end);
-	}
-
-	// If this is our request, compile it.
-
-	if (node->nod_arg[e_for_request])
-		gen_compile(request);
-}
-
-
-static void gen_function( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	Generate blr for a function reference.
- *
- **************************************/
-	qli_req* new_request;
-	qli_rlb* rlb;
-
-	// If there is a request associated with the statement, prepare to
-	// generate BLR.  Otherwise assume that a request is already initialized.
-
-	if (request && (request->req_flags & (REQ_project | REQ_group_by)))
-	{
-		new_request = NULL;
-		rlb = CHECK_RLB(request->req_blr);
-	}
-	else if (new_request = (qli_req*) node->nod_arg[e_fun_request])
-	{
-		request = new_request;
-		gen_request(request);
-		const qli_msg* receive = (qli_msg*) node->nod_arg[e_fun_send];
-		if (receive)
-			gen_send_receive(receive, blr_receive);
-		const qli_msg* send = (qli_msg*) node->nod_arg[e_fun_receive];
-		gen_send_receive(send, blr_send);
-		rlb = CHECK_RLB(request->req_blr);
-		STUFF(blr_assignment);
-	}
-	else
-		rlb = CHECK_RLB(request->req_blr);
-
-	// Generate function body
-
-	STUFF(blr_function);
-	qli_fun* function = (qli_fun*) node->nod_arg[e_fun_function];
-	qli_symbol* symbol = function->fun_symbol;
-	STUFF(symbol->sym_length);
-	for (const UCHAR* p = (UCHAR*) symbol->sym_string; *p;)
-		STUFF(*p++);
-
-	// Generate function arguments
-
-	qli_nod* args = node->nod_arg[e_fun_args];
-	STUFF(args->nod_count);
-
-    qli_nod** ptr = args->nod_arg;
-	for (const qli_nod* const* const end = ptr + args->nod_count; ptr < end; ptr++)
-		gen_expression(*ptr, request);
-
-	if (new_request)
-	{
-		gen_parameter(node->nod_import, request);
-		gen_compile(request);
-	}
-}
-
-
-static void gen_if( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ i f
- *
- **************************************
- *
- * Functional description
- *	Generate code for an IF statement.  Depending
- *	on the environment, this may be either a QLI
- *	context IF or a database context IF.
- *
- **************************************/
-
-	// If the statement is local to QLI, force the sub- statements/expressions to be local also.
-	// If not local, generate BLR.
-
-	if (node->nod_flags & NOD_local)
-	{
-		gen_expression(node->nod_arg[e_if_boolean], 0);
-		gen_statement(node->nod_arg[e_if_true], request);
-		if (node->nod_arg[e_if_false])
-			gen_statement(node->nod_arg[e_if_false], request);
-	}
-	else
-	{
-	    // probably the var is irrelevant, but not the function call,
-	    // as it makes sure there's enough room.
-		qli_rlb* rlb = CHECK_RLB(request->req_blr);
-		STUFF(blr_if);
-		gen_expression(node->nod_arg[e_if_boolean], request);
-		STUFF(blr_begin);
-		gen_statement(node->nod_arg[e_if_true], request);
-		STUFF(blr_end);
-		if (node->nod_arg[e_if_false])
-		{
-			STUFF(blr_begin);
-			gen_statement(node->nod_arg[e_if_false], request);
-			STUFF(blr_end);
-		}
-		else
-			STUFF(blr_end);
-	}
-}
-
-
-static void gen_literal(const dsc* desc, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ l i t e r a l
- *
- **************************************
- *
- * Functional description
- *	Generate a literal value expression.
- *
- **************************************/
-	SLONG value;
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	STUFF(blr_literal);
-	gen_descriptor(desc, request);
-	const UCHAR* p = desc->dsc_address;
-	USHORT l = desc->dsc_length;
-
-	switch (desc->dsc_dtype)
-	{
-	case dtype_short:
-		value = *(SSHORT *) p;
-		STUFF_WORD(value);
-		break;
-
-	case dtype_long:
-	case dtype_sql_time:
-	case dtype_sql_date:
-		value = *(SLONG *) p;
-		STUFF_WORD(value);
-		STUFF_WORD(value >> 16);
-		break;
-    case dtype_int64:
-	case dtype_quad:
-	case dtype_timestamp:
-		value = *(SLONG *) p;
-		STUFF_WORD(value);
-		STUFF_WORD(value >> 16);
-		value = *(SLONG *) (p + 4);
-		STUFF_WORD(value);
-		STUFF_WORD(value >> 16);
-		break;
-
-	default:
-		if (l)
-			do {
-				STUFF(*p++);
-			} while (--l);
-	}
-}
-
-
-static void gen_map(qli_map* map, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ m a p
- *
- **************************************
- *
- * Functional description
- *	Generate a value map for a record selection expression.
- *
- **************************************/
-	qli_map* temp;
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	USHORT count = 0;
-	for (temp = map; temp; temp = temp->map_next)
-	{
-		if (temp->map_node->nod_type != nod_function)
-			temp->map_position = count++;
-	}
-
-	STUFF(blr_map);
-	STUFF_WORD(count);
-
-	for (temp = map; temp; temp = temp->map_next)
-	{
-		if (temp->map_node->nod_type != nod_function)
-		{
-			STUFF_WORD(temp->map_position);
-			gen_expression(temp->map_node, request);
-		}
-	}
-}
-
-
-static void gen_modify( qli_nod* node) //, qli_req* org_request)
-{
-/**************************************
- *
- *	g e n _ m o d i f y
- *
- **************************************
- *
- * Functional description
- *	Generate a MODIFY statement.
- *
- **************************************/
-	qli_req* request = (qli_req*) node->nod_arg[e_mod_request];
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	if (node->nod_arg[e_mod_send])
-		gen_send_receive((qli_msg*) node->nod_arg[e_mod_send], blr_receive);
-
-	qli_nod** ptr = &node->nod_arg[e_mod_count];
-	for (const qli_nod* const* const end = ptr + node->nod_count; ptr < end; ptr++)
-	{
-		qli_ctx* context = (qli_ctx*) *ptr;
-		STUFF(blr_modify);
-		STUFF(context->ctx_source->ctx_context);
-		STUFF(context->ctx_context);
-	}
-	STUFF(blr_begin);
-	gen_statement(node->nod_arg[e_mod_statement], request);
-	STUFF(blr_end);
-}
-
-
-
-static void gen_parameter(const qli_par* parameter, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ p a r a m e t e r
- *
- **************************************
- *
- * Functional description
- *	Generate a simple parameter reference.
- *
- **************************************/
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	const qli_msg* message = parameter->par_message;
-	if (!parameter->par_missing)
-	{
-		STUFF(blr_parameter);
-		STUFF(message->msg_number);
-		STUFF_WORD(parameter->par_parameter);
-	}
-	else
-	{
-		STUFF(blr_parameter2);
-		STUFF(message->msg_number);
-		STUFF_WORD(parameter->par_parameter);
-		STUFF_WORD(parameter->par_missing->par_parameter);
-	}
-}
-
-
-static void gen_print_list( qli_nod* list, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ p r i n t _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Generate BLR for a print list.
- *
- **************************************/
-	qli_nod** ptr = list->nod_arg;
-	for (const qli_nod* const* const end = ptr + list->nod_count; ptr < end; ptr++)
-	{
-		qli_print_item* item = (qli_print_item*) *ptr;
-		if (item->itm_type == item_value)
-			gen_expression(item->itm_value, request);
-	}
-}
-
-
-static void gen_report( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Compile the body of a report specification.
- *
- **************************************/
-	qli_rpt* report = (qli_rpt*) node->nod_arg[e_prt_list];
-
-	gen_control_break(report->rpt_top_rpt, request);
-	gen_control_break(report->rpt_top_page, request);
-	gen_control_break(report->rpt_top_breaks, request);
-
-    qli_nod* list = report->rpt_detail_line;
-	if (list)
-		gen_print_list(list, request);
-
-	gen_control_break(report->rpt_bottom_breaks, request);
-	gen_control_break(report->rpt_bottom_page, request);
-	gen_control_break(report->rpt_bottom_rpt, request);
-}
-
-
-static void gen_request( qli_req* request)
-{
-/**************************************
- *
- *	g e n _ r e q u e s t
- *
- **************************************
- *
- * Functional description
- *	Prepare to generation and compile a request.
- *
- **************************************/
-	qli_par* param;
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	STUFF(blr_version4);
-	STUFF(blr_begin);
-
-	// Build declarations for all messages.
-
-	for (qli_msg* message = request->req_messages; message; message = message->msg_next)
-	{
-		message->msg_length = 0;
-		for (param = message->msg_parameters; param; param = param->par_next)
-		{
-			const dsc* desc = &param->par_desc;
-			param->par_parameter = message->msg_parameter++;
-			const USHORT alignment = type_alignments[desc->dsc_dtype];
-			if (alignment)
-				message->msg_length = FB_ALIGN(message->msg_length, alignment);
-			param->par_offset = message->msg_length;
-			message->msg_length += desc->dsc_length;
-			qli_par* missing_param = param->par_missing;
-			if (missing_param)
-			{
-				missing_param->par_parameter = message->msg_parameter++;
-				message->msg_length = FB_ALIGN(message->msg_length, sizeof(USHORT));
-				desc = &missing_param->par_desc;
-				missing_param->par_offset = message->msg_length;
-				message->msg_length += desc->dsc_length;
-			}
-		}
-
-		STUFF(blr_message);
-		STUFF(message->msg_number);
-		STUFF_WORD(message->msg_parameter);
-
-		qli_str* string = (qli_str*) ALLOCDV(type_str, message->msg_length + FB_DOUBLE_ALIGN - 1);
-		message->msg_buffer = (UCHAR*) FB_ALIGN(string->str_data, FB_DOUBLE_ALIGN);
-
-		for (param = message->msg_parameters; param; param = param->par_next)
-		{
-			gen_descriptor(&param->par_desc, request);
-			qli_par* missing_param = param->par_missing;
-			if (missing_param)
-				gen_descriptor(&missing_param->par_desc, request);
-		}
-	}
-}
-
-
-static void gen_rse( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ r s e
- *
- **************************************
- *
- * Functional description
- *	Generate a record selection expression.
- *
- **************************************/
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	if ((nod_t) (IPTR) node->nod_arg[e_rse_join_type] == nod_nothing)
-		STUFF(blr_rse);
-	else
-		STUFF(blr_rs_stream);
-	STUFF(node->nod_count);
-
-	// Check for aggregate case
-	qli_nod* list;
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_rse_count];
-
-	if (context->ctx_sub_rse)
-	{
-		STUFF(blr_aggregate);
-		STUFF(context->ctx_context);
-		gen_rse(context->ctx_sub_rse, request);
-		STUFF(blr_group_by);
-		if (list = node->nod_arg[e_rse_group_by])
-		{
-			request->req_flags |= REQ_group_by;
-			STUFF(list->nod_count);
-			qli_nod** ptr = list->nod_arg;
-			for (const qli_nod* const* const end = ptr + list->nod_count; ptr < end; ++ptr)
-			{
-				gen_expression(*ptr, request);
-			}
-			request->req_flags &= ~REQ_group_by;
-		}
-		else
-			STUFF(0);
-		gen_map(context->ctx_map, request);
-		if (list = node->nod_arg[e_rse_having])
-		{
-			STUFF(blr_boolean);
-			gen_expression(list, request);
-		}
-		if (list = node->nod_arg[e_rse_sort])
-			gen_sort(list, request, blr_sort);
-		STUFF(blr_end);
-		return;
-	}
-
-	// Make relation clauses for all relations
-
-	qli_nod** ptr = &node->nod_arg[e_rse_count];
-	for (const qli_nod* const* const end = ptr + node->nod_count; ptr < end; ++ptr)
-	{
-		context = (qli_ctx*) *ptr;
-		if (context->ctx_stream)
-			gen_rse(context->ctx_stream, request);
-		else
-		{
-			const qli_rel* relation = context->ctx_relation;
-			STUFF(blr_rid);
-			STUFF_WORD(relation->rel_id);
-			STUFF(context->ctx_context);
-		}
-	}
-
-	// Handle various clauses
-
-	if (list = node->nod_arg[e_rse_first])
-	{
-		STUFF(blr_first);
-		gen_expression(list, request);
-	}
-
-	if (list = node->nod_arg[e_rse_boolean])
-	{
-		STUFF(blr_boolean);
-		gen_expression(list, request);
-	}
-
-	if (list = node->nod_arg[e_rse_sort])
-		gen_sort(list, request, blr_sort);
-
-	if (list = node->nod_arg[e_rse_reduced])
-		gen_sort(list, request, blr_project);
-
-	const nod_t join_type = (nod_t) (IPTR) node->nod_arg[e_rse_join_type];
-	if (join_type != nod_nothing && join_type != nod_join_inner)
-	{
-		STUFF(blr_join_type);
-		switch (join_type)
-		{
-		case nod_join_left:
-			STUFF(blr_left);
-			break;
-		case nod_join_right:
-			STUFF(blr_right);
-			break;
-		default:
-			STUFF(blr_full);
-		}
-	}
-
-	STUFF(blr_end);
-}
-
-
-static void gen_send_receive( const qli_msg* message, USHORT operatr)
-{
-/**************************************
- *
- *	g e n _ s e n d _ r e c e i v e
- *
- **************************************
- *
- * Functional description
- *	Generate a send or receive statement, excluding body.
- *
- **************************************/
-	qli_req* request = message->msg_request;
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-	STUFF(operatr);
-	STUFF(message->msg_number);
-}
-
-
-static void gen_sort( qli_nod* node, qli_req* request, const UCHAR operatr)
-{
-/**************************************
- *
- *	g e n _ s o r t
- *
- **************************************
- *
- * Functional description
- *	Generate sort or reduced clause.
- *
- **************************************/
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	STUFF(operatr);
-	STUFF(node->nod_count);
-
-	request->req_flags |= REQ_project;
-	qli_nod** ptr = node->nod_arg;
-	for (qli_nod** const end = ptr + node->nod_count * 2; ptr < end; ptr += 2)
-	{
-		if (operatr == blr_sort)
-			STUFF(ptr[1] ? blr_descending : blr_ascending);
-		gen_expression(ptr[0], request);
-	}
-	request->req_flags &= ~REQ_project;
-}
-
-
-static void gen_statement( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ s t a t e m e n t
- *
- **************************************
- *
- * Functional description
- *	Generate BLR for statement.
- *
- **************************************/
-	if (request)
-		CHECK_RLB(request->req_blr);
-
-	switch (node->nod_type)
-	{
-	case nod_abort:
-		if (node->nod_count)
-			gen_expression(node->nod_arg[0], 0);
-		return;
-
-	case nod_assign:
-		gen_assignment(node, request);
-		return;
-
-	case nod_commit_retaining:
-		return;
-
-	case nod_erase:
-		gen_erase(node, request);
-		return;
-
-	case nod_for:
-	case nod_report_loop:
-		gen_for(node, request);
-		return;
-
-	case nod_list:
-	    {
-	        qli_nod** ptr = node->nod_arg;
-			for (const qli_nod* const* const end = ptr + node->nod_count; ptr < end; ++ptr)
-			{
-				gen_statement(*ptr, request);
-			}
-			return;
-		}
-
-	case nod_modify:
-		gen_modify(node); //, request);
-		return;
-
-	case nod_output:
-		gen_statement(node->nod_arg[e_out_statement], request);
-		return;
-
-	case nod_print:
-		gen_print_list(node->nod_arg[e_prt_list], request);
-		return;
-
-	case nod_repeat:
-		gen_statement(node->nod_arg[e_rpt_statement], request);
-		return;
-
-	case nod_report:
-		gen_report(node, request);
-		return;
-
-	case nod_store:
-		gen_store(node, request);
-		return;
-
-	case nod_if:
-		gen_if(node, request);
-		return;
-
-	default:
-		ERRQ_bugcheck(354);			// Msg354 gen_statement: not yet implemented
-	}
-}
-
-
-static void gen_statistical( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ s t a t i s t i c a l
- *
- **************************************
- *
- * Functional description
- *	Generate the BLR for a statistical expresionn.
- *
- **************************************/
-	USHORT operatr;
-
-	switch (node->nod_type)
-	{
-	case nod_average:
-		operatr = blr_average;
-		break;
-
-	case nod_count:
-		// count2
-		// operatr = node->nod_arg [e_stt_value] ? blr_count2 : blr_count;
-		operatr = blr_count;
-		break;
-
-	case nod_max:
-		operatr = blr_maximum;
-		break;
-
-	case nod_min:
-		operatr = blr_minimum;
-		break;
-
-	case nod_total:
-		operatr = blr_total;
-		break;
-
-	case nod_agg_average:
-		operatr = blr_agg_average;
-		break;
-
-	case nod_agg_count:
-		// count2
-		// operatr = node->nod_arg [e_stt_value] ? blr_agg_count2 : blr_agg_count;
-		operatr = blr_agg_count;
-		break;
-
-	case nod_agg_max:
-		operatr = blr_agg_max;
-		break;
-
-	case nod_agg_min:
-		operatr = blr_agg_min;
-		break;
-
-	case nod_agg_total:
-		operatr = blr_agg_total;
-		break;
-
-	case nod_from:
-		operatr = node->nod_arg[e_stt_default] ? blr_via : blr_from;
-		break;
-
-	default:
-		ERRQ_bugcheck(355);			// Msg355 gen_statistical: not understood
-	}
-
-	// If there is a request associated with the statement, prepare to
-	// generate BLR.  Otherwise assume that a request is alrealdy initialized.
-
-	qli_rlb* rlb;
-	qli_req* new_request = (qli_req*) node->nod_arg[e_stt_request];
-	if (new_request)
-	{
-		request = new_request;
-		gen_request(request);
-		const qli_msg* receive = (qli_msg*) node->nod_arg[e_stt_send];
-		if (receive)
-			gen_send_receive(receive, blr_receive);
-		const qli_msg* send = (qli_msg*) node->nod_arg[e_stt_receive];
-		gen_send_receive(send, blr_send);
-		rlb = CHECK_RLB(request->req_blr);
-		STUFF(blr_assignment);
-	}
-	else
-		rlb = CHECK_RLB(request->req_blr);
-
-	STUFF(operatr);
-
-	if (node->nod_arg[e_stt_rse])
-		gen_rse(node->nod_arg[e_stt_rse], request);
-
-	// count 2
-	// if (node->nod_arg [e_stt_value])
-
-	if (node->nod_arg[e_stt_value] && node->nod_type != nod_agg_count)
-		gen_expression(node->nod_arg[e_stt_value], request);
-
-	if (node->nod_arg[e_stt_default])
-		gen_expression(node->nod_arg[e_stt_default], request);
-
-	if (new_request)
-	{
-		gen_parameter(node->nod_import, request);
-		gen_compile(request);
-	}
-}
-
-
-static void gen_store( qli_nod* node, qli_req* request)
-{
-/**************************************
- *
- *	g e n _ s t o r e
- *
- **************************************
- *
- * Functional description
- *	Generate code for STORE statement.
- *
- **************************************/
-
-	// If there is a request associated with the statement, prepare to
-	// generate BLR.  Otherwise assume that a request is alrealdy initialized.
-
-	if (node->nod_arg[e_sto_request])
-	{
-		request = (qli_req*) node->nod_arg[e_sto_request];
-		gen_request(request);
-	}
-
-	qli_rlb* rlb = CHECK_RLB(request->req_blr);
-
-	// If there is a message to be sent, build a receive for it
-
-	if (node->nod_arg[e_sto_send])
-		gen_send_receive((qli_msg*) node->nod_arg[e_sto_send], blr_receive);
-
-	// Generate the STORE statement proper.
-
-	STUFF(blr_store);
-	qli_ctx* context = (qli_ctx*) node->nod_arg[e_sto_context];
-	qli_rel* relation = context->ctx_relation;
-	STUFF(blr_rid);
-	STUFF_WORD(relation->rel_id);
-	STUFF(context->ctx_context);
-
-	// Build  the body of the loop.
-
-	STUFF(blr_begin);
-	gen_statement(node->nod_arg[e_sto_statement], request);
-	STUFF(blr_end);
-
-	// If this is our request, compile it.
-
-	if (node->nod_arg[e_sto_request])
-		gen_compile(request);
-}
-
-
diff --git a/src/qli/gener_proto.h b/src/qli/gener_proto.h
deleted file mode 100644
index 4ef5cad74b..0000000000
--- a/src/qli/gener_proto.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		gener_proto.h
- *	DESCRIPTION:	Prototype header file for gener.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_GENER_PROTO_H
-#define QLI_GENER_PROTO_H
-
-qli_nod*	GEN_generate(qli_nod*);
-void		GEN_release();
-qli_rlb*	GEN_rlb_extend(qli_rlb*);
-void		GEN_rlb_release(qli_rlb*);
-
-inline qli_rlb* CHECK_RLB(qli_rlb*& in)
-{
-	if (!in || (in->rlb_data > in->rlb_limit))
-		in = GEN_rlb_extend(in);
-	return in;
-}
-
-#endif // QLI_GENER_PROTO_H
-
diff --git a/src/qli/help_proto.h b/src/qli/help_proto.h
deleted file mode 100644
index df9c740a45..0000000000
--- a/src/qli/help_proto.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		help_proto.h
- *	DESCRIPTION:	Prototype header file for help.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_HELP_PROTO_H
-#define QLI_HELP_PROTO_H
-
-void	HELP_fini();
-void	HELP_help(qli_syntax*);
-
-#endif // QLI_HELP_PROTO_H
-
diff --git a/src/qli/hsh.cpp b/src/qli/hsh.cpp
deleted file mode 100644
index 445614f044..0000000000
--- a/src/qli/hsh.cpp
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		hsh.cpp
- *	DESCRIPTION:	Hash table and symbol manager
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/hsh_proto.h"
-
-typedef bool (*scompare_t)(const SCHAR*, int, const SCHAR*, int);
-
-static int hash(const SCHAR*, int);
-static bool scompare_ins(const SCHAR*, int, const SCHAR*, int);
-static bool scompare_sens(const SCHAR*, int, const SCHAR*, int);
-
-const int HASH_SIZE = 224;
-static qli_symbol* hash_table[HASH_SIZE];
-static qli_symbol* key_symbols;
-
-struct qli_kword
-{
-	kwwords id;
-	const char* keyword;
-};
-
-const qli_kword keywords[] =
-{
-#include "../qli/words.h"
-   {KW_continuation, "-\n"}
-};
-
-
-void HSH_fini()
-{
-/**************************************
- *
- *	H S H _ f i n i
- *
- **************************************
- *
- * Functional description
- *	Release space used by keywords.
- *
- **************************************/
-	while (key_symbols)
-	{
-		qli_symbol* symbol = key_symbols;
-		key_symbols = (qli_symbol*) key_symbols->sym_object;
-		HSH_remove(symbol);
-		ALLQ_release((qli_frb*) symbol);
-	}
-}
-
-
-void HSH_init()
-{
-/**************************************
- *
- *	H S H _ i n i t
- *
- **************************************
- *
- * Functional description
- *	Initialize the hash table.  This mostly involves
- *	inserting all known keywords.
- *
- **************************************/
-	const qli_kword* qword = keywords;
-
-	for (int i = 0; i < FB_NELEM(keywords); i++, qword++)
-	{
-		qli_symbol* symbol = (qli_symbol*) ALLOCPV(type_sym, 0);
-		symbol->sym_type = SYM_keyword;
-		symbol->sym_length = static_cast<USHORT>(strlen(qword->keyword));
-		symbol->sym_string = qword->keyword;
-		symbol->sym_keyword = qword->id;
-		HSH_insert(symbol, true);
-		symbol->sym_object = (BLK) key_symbols;
-		key_symbols = symbol;
-	}
-}
-
-
-void HSH_insert( qli_symbol* symbol, bool ignore_case)
-{
-/**************************************
- *
- *	H S H _ i n s e r t
- *
- **************************************
- *
- * Functional description
- *	Insert a symbol into the hash table.
- *
- **************************************/
-	const int h = hash(symbol->sym_string, symbol->sym_length);
-	scompare_t scompare = ignore_case ? scompare_ins : scompare_sens;
-
-	for (qli_symbol* old = hash_table[h]; old; old = old->sym_collision)
-	{
-		if (scompare(symbol->sym_string, symbol->sym_length, old->sym_string, old->sym_length))
-		{
-			symbol->sym_homonym = old->sym_homonym;
-			old->sym_homonym = symbol;
-			return;
-		}
-	}
-
-	symbol->sym_collision = hash_table[h];
-	hash_table[h] = symbol;
-}
-
-
-qli_symbol* HSH_lookup(const SCHAR* string, int length)
-{
-/**************************************
- *
- *	H S H _ l o o k u p
- *
- **************************************
- *
- * Functional description
- *	Perform a string lookup against hash table.
- *
- **************************************/
-	scompare_t scompare = scompare_ins;
-
-	if (length > 1 && string[0] == '"')
-	{
-		// This logic differs from DSQL. See how LEX_token works.
-		length -= 2;
-		++string;
-		scompare = scompare_sens;
-	}
-	for (qli_symbol* symbol = hash_table[hash(string, length)]; symbol;
-		symbol = symbol->sym_collision)
-	{
-		if (scompare(string, length, symbol->sym_string, symbol->sym_length))
-			return symbol;
-	}
-
-	return NULL;
-}
-
-
-void HSH_remove( qli_symbol* symbol)
-{
-/**************************************
- *
- *	H S H _ r e m o v e
- *
- **************************************
- *
- * Functional description
- *	Remove a symbol from the hash table.
- *
- **************************************/
-	const int h = hash(symbol->sym_string, symbol->sym_length);
-
-	for (qli_symbol** next = &hash_table[h]; *next; next = &(*next)->sym_collision)
-	{
-		if (symbol == *next)
-		{
-			qli_symbol* homonym = symbol->sym_homonym;
-			if (homonym)
-			{
-				homonym->sym_collision = symbol->sym_collision;
-				*next = homonym;
-			}
-			else
-				*next = symbol->sym_collision;
-
-			return;
-		}
-
-		for (qli_symbol** ptr = &(*next)->sym_homonym; *ptr; ptr = &(*ptr)->sym_homonym)
-		{
-			if (symbol == *ptr)
-			{
-				*ptr = symbol->sym_homonym;
-				return;
-			}
-		}
-	}
-
-	ERRQ_error(27);	// Msg 27 HSH_remove failed
-}
-
-
-static int hash(const SCHAR* string, int length)
-{
-/**************************************
- *
- *	h a s h
- *
- **************************************
- *
- * Functional description
- *	Returns the hash function of a string.
- *
- **************************************/
-	int value = 0;
-
-	while (length--)
-	{
-		const UCHAR c = *string++;
-		value = (value << 1) + UPPER(c);
-	}
-
-	return ((value >= 0) ? value : -value) % HASH_SIZE;
-}
-
-
-static bool scompare_ins(const SCHAR* string1, int length1, const SCHAR* string2, int length2)
-{
-/**************************************
- *
- *	s c o m p a r e _ i n s
- *
- **************************************
- *
- * Functional description
- *	Compare two strings, case insensitive.
- *
- **************************************/
-	if (length1 != length2)
-		return false;
-
-	while (length1--)
-	{
-		const SCHAR c1 = *string1++;
-		const SCHAR c2 = *string2++;
-		if (c1 != c2 && UPPER(c1) != UPPER(c2))
-			return false;
-	}
-
-	return true;
-}
-
-
-static bool scompare_sens(const SCHAR* string1, int length1, const SCHAR* string2, int length2)
-{
-/**************************************
- *
- *	s c o m p a r e _ s e n s
- *
- **************************************
- *
- * Functional description
- *	Compare two strings, case sensitive: quotes identifiers.
- *
- **************************************/
-	if (length1 != length2)
-		return false;
-
-	return !memcmp(string1, string2, length1);
-}
-
diff --git a/src/qli/hsh_proto.h b/src/qli/hsh_proto.h
deleted file mode 100644
index 4b1273e774..0000000000
--- a/src/qli/hsh_proto.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		hsh_proto.h
- *	DESCRIPTION:	Prototype header file for hsh.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_HSH_PROTO_H
-#define QLI_HSH_PROTO_H
-
-void	HSH_fini();
-void	HSH_init();
-void	HSH_insert(qli_symbol*, bool ignore_case = false);
-qli_symbol*	HSH_lookup(const SCHAR*, int);
-void	HSH_remove(qli_symbol*);
-
-#endif // QLI_HSH_PROTO_H
-
diff --git a/src/qli/lex.cpp b/src/qli/lex.cpp
deleted file mode 100644
index 60f0185077..0000000000
--- a/src/qli/lex.cpp
+++ /dev/null
@@ -1,1260 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		lex.cpp
- *	DESCRIPTION:	Lexical analyser
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- *
- * 2002.10.30 Sean Leyne - Removed support for obsolete "PC_PLATFORM" define
- *
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <errno.h>
-#include <string.h>
-#include <stdlib.h>
-#include "../qli/dtr.h"
-#include "../qli/parse.h"
-#include "ibase.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/hsh_proto.h"
-#include "../qli/lex_proto.h"
-#include "../qli/proc_proto.h"
-#include "../yvalve/utl_proto.h"
-#include "../common/gdsassert.h"
-#include "../common/utils_proto.h"
-#include "../common/classes/TempFile.h"
-#include "../common/os/os_utils.h"
-
-using Firebird::TempFile;
-using MsgFormat::SafeArg;
-
-
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#ifdef HAVE_IO_H
-#include <io.h> // isatty
-#endif
-
-static const char* const SCRATCH = "fb_query_";
-
-const char* FOPEN_INPUT_TYPE = "r";
-
-static bool get_line(FILE*, TEXT*, USHORT);
-static int nextchar(const bool);
-static void next_line(const bool);
-static void retchar();
-static bool scan_number(SSHORT, TEXT**);
-static int skip_white();
-
-static qli_lls* QLI_statements;
-static int QLI_position;
-static FILE *input_file = NULL, *trace_file = NULL;
-static char trace_file_name[MAXPATHLEN];
-static SLONG trans_limit;
-
-const SLONG TRANS_LIMIT	= 10;
-
-const char CHR_ident	= char(1);
-const char CHR_letter	= char(2);
-const char CHR_digit	= char(4);
-const char CHR_quote	= char(8);
-const char CHR_white	= char(16);
-const char CHR_eol		= char(32);
-
-const char CHR_IDENT	= CHR_ident;
-const char CHR_LETTER	= CHR_letter | CHR_ident;
-const char CHR_DIGIT	= CHR_digit | CHR_ident;
-const char CHR_QUOTE	= CHR_quote;
-const char CHR_WHITE	= CHR_white;
-const char CHR_EOL		= CHR_eol;
-
-static const char* const eol_string = "end of line";
-static const char* const eof_string = "*end_of_file*";
-
-// Do not reference the array directly; use the functions below.
-
-static const char classes_array[256] =
-{
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, CHR_WHITE, CHR_EOL, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	CHR_WHITE, 0, CHR_QUOTE, CHR_IDENT, CHR_LETTER, 0, 0, CHR_QUOTE,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	CHR_DIGIT, CHR_DIGIT, CHR_DIGIT, CHR_DIGIT, CHR_DIGIT, CHR_DIGIT,
-		CHR_DIGIT, CHR_DIGIT,
-	CHR_DIGIT, CHR_DIGIT, 0, 0, 0, 0, 0, 0,
-	0, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER,
-		CHR_LETTER,
-	CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER,
-		CHR_LETTER, CHR_LETTER,
-	CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER,
-		CHR_LETTER, CHR_LETTER,
-	CHR_LETTER, CHR_LETTER, CHR_LETTER, 0, 0, 0, 0, CHR_IDENT,
-	0, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER,
-		CHR_LETTER,
-	CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER,
-		CHR_LETTER, CHR_LETTER,
-	CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER, CHR_LETTER,
-		CHR_LETTER, CHR_LETTER,
-	CHR_LETTER, CHR_LETTER, CHR_LETTER, 0
-};
-
-inline char classes(int idx)
-{
-	return classes_array[(UCHAR) idx];
-}
-
-inline char classes(UCHAR idx)
-{
-	return classes_array[idx];
-}
-
-
-
-bool LEX_active_procedure()
-{
-/**************************************
- *
- *	L E X _ a c t i v e _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Return true if we're running out of a
- *	procedure and false otherwise.  Somebody
- *	somewhere may care.
- *
- **************************************/
-
-	return (QLI_line->line_type == line_blob);
-}
-
-
-void LEX_edit(SLONG start, SLONG stop)
-{
-/**************************************
- *
- *	L E X _ e d i t
- *
- **************************************
- *
- * Functional description
- *	Dump the last full statement into a scratch file, then
- *	push the scratch file on the input stack.
- *
- **************************************/
-	const Firebird::PathName filename = TempFile::create(SCRATCH);
-	FILE* scratch = os_utils::fopen(filename.c_str(), "w+b");
-	if (!scratch)
-		IBERROR(61);			// Msg 61 couldn't open scratch file
-
-#ifdef WIN_NT
-	stop--;
-#endif
-
-	if (fseek(trace_file, start, 0))
-	{
-		fseek(trace_file, 0, 2);
-		IBERROR(59);			// Msg 59 fseek failed
-	}
-
-	while (++start <= stop)
-	{
-		const SSHORT c = getc(trace_file);
-		if (c == EOF)
-			break;
-		putc(c, scratch);
-	}
-
-	fclose(scratch);
-
-	if (gds__edit(filename.c_str(), TRUE))
-		LEX_push_file(filename.c_str(), true);
-
-	unlink(filename.c_str());
-
-	fseek(trace_file, 0, 2);
-}
-
-
-qli_tok* LEX_edit_string()
-{
-/**************************************
- *
- *	L E X _ e d i t _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Parse the next token as an edit_string.
- *
- **************************************/
-	SSHORT c;
-	qli_tok* token = QLI_token;
-
-	do {
-		c = skip_white();
-	} while (c == '\n');
-	TEXT* p = token->tok_string;
-	*p = c;
-
-	if (!QLI_line)
-	{
-		token->tok_symbol = NULL;
-		token->tok_keyword = KW_none;
-		return NULL;
-	}
-
-	while (!(classes(c) & (CHR_white | CHR_eol)))
-	{
-		*p++ = c;
-		if (classes(c) & CHR_quote)
-		{
-			for (;;)
-			{
-				const SSHORT d = nextchar(false);
-				if (d == '\n')
-				{
-					retchar();
-					break;
-				}
-				*p++ = d;
-				if (d == c)
-					break;
-			}
-		}
-		c = nextchar(true);
-	}
-
-	retchar();
-
-	if (p[-1] == ',')
-	{
-		retchar();
-		--p;
-	}
-
-	token->tok_length = p - token->tok_string;
-	*p = 0;
-	token->tok_symbol = NULL;
-	token->tok_keyword = KW_none;
-
-	if (sw_trace)
-		puts(token->tok_string);
-
-	return token;
-}
-
-
-qli_tok* LEX_filename()
-{
-/**************************************
- *
- *	L E X _ f i l e n a m e
- *
- **************************************
- *
- * Functional description
- *	Parse the next token as a filename.
- *
- **************************************/
-	SSHORT c;
-
-	qli_tok* token = QLI_token;
-
-	do {
-		c = skip_white();
-	} while (c == '\n');
-	TEXT* p = token->tok_string;
-	*p++ = c;
-
-	// If there isn't a line, we're all done
-
-	if (!QLI_line)
-	{
-		token->tok_symbol = NULL;
-		token->tok_keyword = KW_none;
-		return NULL;
-	}
-
-	// notice if this looks like a quoted file name
-
-	SSHORT save = 0;
-	if (classes(c) & CHR_quote)
-	{
-		token->tok_type = tok_quoted;
-		save = c;
-	}
-
-	// Look for white space or end of line, allowing embedded quoted strings.
-
-	for (;;)
-	{
-		c = nextchar(true);
-		char char_class = classes(c);
-		if (c == '"' && c != save)
-		{
-			*p++ = c;
-			for (;;)
-			{
-				c = nextchar(true);
-				char_class = classes(c);
-				if ((char_class & CHR_eol) || c == '"')
-					break;
-				*p++ = c;
-			}
-		}
-
-		if (char_class & (CHR_white | CHR_eol))
-			break;
-		*p++ = c;
-	}
-
-	retchar();
-
-	// Drop trailing semi-colon to avoid confusion
-
-	if (p[-1] == ';')
-	{
-		retchar();
-		--p;
-	}
-
-	// complain on unterminated quoted string
-
-	if ((token->tok_type == tok_quoted) && (p[-1] != save))
-		IBERROR(60);			// Msg 60 unterminated quoted string
-
-	token->tok_length = p - token->tok_string;
-	*p = 0;
-	token->tok_symbol = NULL;
-	token->tok_keyword = KW_none;
-
-	if (sw_trace)
-		puts(token->tok_string);
-
-	return token;
-}
-
-
-void LEX_fini()
-{
-/**************************************
- *
- *	L E X _ f i n i
- *
- **************************************
- *
- * Functional description
- *	Shut down LEX in a more or less clean way.
- *
- **************************************/
-
-	if (trace_file)
-	{
-		fclose(trace_file);
-		unlink(trace_file_name);
-	}
-}
-
-
-void LEX_flush()
-{
-/**************************************
- *
- *	L E X _ f l u s h
- *
- **************************************
- *
- * Functional description
- *	Flush the input stream after an error.
- *
- **************************************/
-
-	trans_limit = 0;
-
-	if (!QLI_line)
-		return;
-
-	// Pop off line sources until we're down to the last one.
-
-	while (QLI_line->line_next)
-		LEX_pop_line();
-
-	// Look for a semi-colon
-
-	if (QLI_semi)
-	{
-		while (QLI_line && QLI_token->tok_keyword != KW_SEMI)
-			LEX_token();
-	}
-	else
-	{
-		while (QLI_line && QLI_token->tok_type != tok_eol)
-			LEX_token();
-	}
-}
-
-
-bool LEX_get_line(const TEXT* prompt, TEXT* buffer, int size)
-{
-/**************************************
- *
- *	L E X _ g e t _ l i n e
- *
- **************************************
- *
- * Functional description
- *	Give a prompt and read a line.  If the line is terminated by
- *	an EOL, return true.  If the buffer is exhausted and non-blanks
- *	would be discarded, return an error.  If EOF is detected,
- *	return false.  Regardless, a null terminated string is returned.
- *
- **************************************/
-	// UNIX flavor
-
-	if (QLI_quit_flag)
-	{
-		buffer[0] = 0;
-		return false;
-	}
-
-	if (prompt)
-		printf("%s", prompt);
-
-	errno = 0;
-	TEXT* p = buffer;
-
-	bool overflow_flag = false;
-	SSHORT c;
-
-	while (true)
-	{
-		c = getc(input_file);
-		if (c == EOF)
-		{
-			if (SYSCALL_INTERRUPTED(errno) && !QLI_abort)
-			{
-				errno = 0;
-				continue;
-			}
-
-			// The check for this actually being a terminal that is at
-			//   end of file is to prevent looping through a redirected
-			//   stdin (e.g., a script file).
-
-			if (prompt && isatty(fileno(stdin)))
-			{
-				rewind(stdin);
-				putchar('\n');
-			}
-			if (QLI_abort)
-				continue;
-
-			break;
-		}
-		if (--size > 0)
-			*p++ = c;
-		else if (c != ' ' && c != '\n')
-			overflow_flag = true;
-		if (c == '\n')
-			break;
-	}
-
-	*p = 0;
-	if (c == EOF)
-		return false;
-
-	if (overflow_flag)
-	{
-		buffer[0] = 0;
-		IBERROR(476);			// Msg 476 input line too long
-	}
-
-	if (sw_verify)
-		fputs(buffer, stdout);
-
-	return true;
-}
-
-
-void LEX_init()
-{
-/**************************************
- *
- *	L E X _ i n i t
- *
- **************************************
- *
- * Functional description
- *	Initialize for lexical scanning.  While we're at it, open a
- *	scratch trace file to keep all input.
- *
- **************************************/
-	const Firebird::PathName filename = TempFile::create(SCRATCH);
-	strcpy(trace_file_name, filename.c_str());
-	trace_file = os_utils::fopen(trace_file_name, "w+b");
-#ifdef UNIX
-	unlink(trace_file_name);
-#endif
-	if (!trace_file)
-		IBERROR(61);			// Msg 61 couldn't open scratch file
-
-	QLI_token = (qli_tok*) ALLOCPV(type_tok, MAXSYMLEN);
-
-	QLI_line = (qli_line*) ALLOCPV(type_line, 0);
-	QLI_line->line_size = sizeof(QLI_line->line_data);
-	QLI_line->line_ptr = QLI_line->line_data;
-	QLI_line->line_type = line_stdin;
-	QLI_line->line_source_file = stdin;
-
-	QLI_semi = false;
-	input_file = stdin;
-	HSH_init();
-}
-
-
-void LEX_mark_statement()
-{
-/**************************************
- *
- *	L E X _ m a r k _ s t a t e m e n t
- *
- **************************************
- *
- * Functional description
- *	Push a position in the trace file onto
- *	the statement stack.
- *
- **************************************/
-	qli_line* temp;
-
-	for (temp = QLI_line; temp->line_next && QLI_statements; temp = temp->line_next)
-	{
-		if (temp->line_next->line_position == (IPTR) QLI_statements->lls_object)
-			return;
-	}
-
-	qli_lls* statement = (qli_lls*) ALLOCP(type_lls);
-	statement->lls_object = (BLK)(IPTR) temp->line_position;
-	statement->lls_next = QLI_statements;
-	QLI_statements = statement;
-}
-
-
-void LEX_pop_line()
-{
-/**************************************
- *
- *	L E X _ p o p _ l i n e
- *
- **************************************
- *
- * Functional description
- *	We're done with the current line source.  Close it out
- *	and release the line block.
- *
- **************************************/
-	qli_line* const temp = QLI_line;
-	QLI_line = temp->line_next;
-
-	if (temp->line_type == line_blob)
-		PRO_close(temp->line_database, temp->line_source_blob);
-	else if (temp->line_type == line_file)
-		fclose(temp->line_source_file);
-
-	ALLQ_release((qli_frb*) temp);
-}
-
-
-void LEX_procedure( qli_dbb* database, FB_API_HANDLE blob)
-{
-/**************************************
- *
- *	L E X _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Push a blob-resident procedure onto the input line source
- *	stack;
- *
- **************************************/
-	qli_line* temp = (qli_line*) ALLOCPV(type_line, QLI_token->tok_length);
-	temp->line_source_blob = blob;
-	strncpy(temp->line_source_name, QLI_token->tok_string, QLI_token->tok_length);
-	temp->line_type = line_blob;
-	temp->line_database = database;
-	temp->line_size = sizeof(temp->line_data);
-	temp->line_ptr = temp->line_data;
-	temp->line_position = QLI_position;
-	temp->line_next = QLI_line;
-	QLI_line = temp;
-}
-
-
-bool LEX_push_file(const TEXT* filename, const bool error_flag)
-{
-/**************************************
- *
- *	L E X _ p u s h _ f i l e
- *
- **************************************
- *
- * Functional description
- *	Open a command file.  If the open succeedes, push the input
- *	source onto the source stack.  If the open fails, give an error
- *	if the error flag is set, otherwise return quietly.
- *
- **************************************/
-	FILE *file = os_utils::fopen(filename, FOPEN_INPUT_TYPE);
-	if (!file)
-	{
-	    TEXT buffer[64];
-		sprintf(buffer, "%s.com", filename);
-		if (!(file = os_utils::fopen(buffer, FOPEN_INPUT_TYPE)))
-		{
-			if (error_flag)
-				ERRQ_msg_put(67, filename);
-				// Msg 67 can't open command file \"%s\"\n
-			return false;
-		}
-	}
-
-	qli_line* line = (qli_line*) ALLOCPV(type_line, static_cast<int>(strlen(filename)));
-	line->line_type = line_file;
-	line->line_source_file = file;
-	line->line_size = sizeof(line->line_data);
-	line->line_ptr = line->line_data;
-	*line->line_ptr = 0;
-	strcpy(line->line_source_name, filename);
-	line->line_next = QLI_line;
-	QLI_line = line;
-
-	return true;
-}
-
-
-bool LEX_push_string(const TEXT* const string)
-{
-/**************************************
- *
- *	L E X _ p u s h _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Push a simple string on as an input source.
- *
- **************************************/
-	qli_line* line = (qli_line*) ALLOCPV(type_line, 0);
-	line->line_type = line_string;
-	line->line_size = static_cast<USHORT>(strlen(string));
-	line->line_ptr = line->line_data;
-	strcpy(line->line_data, string);
-	line->line_data[line->line_size] = '\n';
-	line->line_next = QLI_line;
-	QLI_line = line;
-
-	return true;
-}
-
-
-void LEX_put_procedure(FB_API_HANDLE blob, SLONG start, SLONG stop)
-{
-/**************************************
- *
- *	L E X _ p u t _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	Write text from the scratch trace file into a blob.
- *
- **************************************/
-	ISC_STATUS_ARRAY status_vector;
-
-	if (fseek(trace_file, start, 0))
-	{
-		fseek(trace_file, 0, 2);
-		IBERROR(62);			// Msg 62 fseek failed
-	}
-
-	int length = stop - start;
-
-    TEXT buffer[1024];
-
-	while (length)
-	{
-		TEXT* p = buffer;
-		while (length)
-		{
-			--length;
-			const SSHORT c = getc(trace_file);
-			*p++ = c;
-			if (c == '\n')
-			{
-#ifdef WIN_NT
-				// account for the extra line-feed on OS/2 and Windows NT
-
-				if (length)
-					--length;
-#endif
-				break;
-			}
-		}
-		const SSHORT l = p - buffer;
-		if (l && isc_put_segment(status_vector, &blob, l, buffer))
-			ERRQ_bugcheck(58);	// Msg 58 isc_put_segment failed
-	}
-
-	fseek(trace_file, 0, 2);
-}
-
-
-void LEX_real()
-{
-/**************************************
- *
- *	L E X _ r e a l
- *
- **************************************
- *
- * Functional description
- *	If the token is an end of line, get the next token.
- *
- **************************************/
-
-	while (QLI_token->tok_type == tok_eol)
-		LEX_token();
-}
-
-
-qli_lls* LEX_statement_list()
-{
-/**************************************
- *
- *	L E X _ s t a t e m e n t _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Somebody outside needs to know
- *	where the top of the statement list
- *	is.
- *
- **************************************/
-
-	return QLI_statements;
-}
-
-
-qli_tok* LEX_token()
-{
-/**************************************
- *
- *	L E X _ t o k e n
- *
- **************************************
- *
- * Functional description
- *	Parse and return the next token.
- *
- **************************************/
-	qli_tok* token = QLI_token;
-	TEXT* p = token->tok_string;
-
-	// Get next significant byte.  If it's the last EOL of a blob, throw it away
-
-	SSHORT c;
-
-	for (;;)
-	{
-		c = skip_white();
-		if (c != '\n' || QLI_line->line_type != line_blob)
-			break;
-		qli_line* prior = QLI_line;
-		next_line(true);
-		if (prior == QLI_line)
-			break;
-	}
-
-	// If we hit end of file, make up a phoney token
-
-	if (!QLI_line)
-	{
-		const TEXT* q = eof_string;
-		while (*p++ = *q++);
-		token->tok_type = tok_eof;
-		token->tok_keyword = KW_none;
-		return NULL;
-	}
-
-	*p++ = c;
-	QLI_token->tok_position = QLI_line->line_position + QLI_line->line_ptr - QLI_line->line_data - 1;
-
-	// On end of file, generate furious but phone end of line tokens
-
-	char char_class = classes(c);
-
-	if (char_class & CHR_letter)
-	{
-		for (c = nextchar(true); classes(c) & CHR_ident; c = nextchar(true))
-			*p++ = c;
-		retchar();
-		token->tok_type = tok_ident;
-	}
-	else if (((char_class & CHR_digit) || c == '.') && scan_number(c, &p))
-		token->tok_type = tok_number;
-	else if (char_class & CHR_quote)
-	{
-		token->tok_type = tok_quoted;
-		while (true)
-		{
-			const SSHORT next = nextchar(false);
-			if (!next || next == '\n')
-			{
-				retchar();
-				IBERROR(63);	// Msg 63 unterminated quoted string
-				break;
-			}
-			*p++ = next;
-			if ((p - token->tok_string) >= MAXSYMLEN)
-				ERRQ_msg_put(470, SafeArg() << MAXSYMLEN);	// Msg 470 literal too long
-
-			// If there are 2 quotes in a row, interpret 2nd as a literal
-
-			if (next == c)
-			{
-				const SSHORT peek = nextchar(false);
-				retchar();
-				if (peek != c)
-					break;
-				nextchar(false);
-			}
-		}
-	}
-	else if (c == '\n')
-	{
-	    // end of line, signal it properly with a phoney token.
-		token->tok_type = tok_eol;
-		--p;
-		const TEXT* q = eol_string;
-		while (*q)
-			*p++ = *q++;
-	}
-	else
-	{
-		token->tok_type = tok_punct;
-		*p++ = nextchar(true);
-		if (!HSH_lookup(token->tok_string, 2))
-		{
-			retchar();
-			--p;
-		}
-	}
-
-	token->tok_length = p - token->tok_string;
-	*p = '\0';
-
-	if (token->tok_string[0] == '$' && trans_limit < TRANS_LIMIT)
-	{
-		Firebird::string s;
-		if (fb_utils::readenv(token->tok_string + 1, s))
-		{
-			LEX_push_string(s.c_str());
-			++trans_limit;
-			token = LEX_token();
-			--trans_limit;
-			return token;
-		}
-	}
-
-    qli_symbol* symbol = HSH_lookup(token->tok_string, token->tok_length);
-	token->tok_symbol = symbol;
-	if (symbol && symbol->sym_type == SYM_keyword)
-		token->tok_keyword = (kwwords) symbol->sym_keyword;
-	else
-		token->tok_keyword = KW_none;
-
-	if (sw_trace)
-		puts(token->tok_string);
-
-	return token;
-}
-
-
-static bool get_line(FILE* file, TEXT* buffer, USHORT size)
-{
-/**************************************
- *
- *	g e t _ l i n e
- *
- **************************************
- *
- * Functional description
- *	Read a line.  If the line is terminated by
- *	an EOL, return true.  If the buffer is exhausted and non-blanks
- *	would be discarded, return an error.  If EOF is detected,
- *	return false.  Regardless, a null terminated string is returned.
- *
- **************************************/
-	bool overflow_flag = false;
-	SSHORT c;
-
-	errno = 0;
-	TEXT* p = buffer;
-	SLONG length = size;
-
-	while (true)
-	{
-		c = getc(file);
-		if (c == EOF)
-		{
-			if (SYSCALL_INTERRUPTED(errno) && !QLI_abort)
-			{
-				errno = 0;
-				continue;
-			}
-			if (QLI_abort)
-				continue;
-
-			break;
-		}
-		if (--length > 0)
-			*p++ = c;
-		else if (c != ' ' && c != '\n')
-			overflow_flag = true;
-		if (c == '\n')
-			break;
-	}
-
-	*p = 0;
-	if (c == EOF)
-		return false;
-
-	if (overflow_flag)
-		IBERROR(477);			// Msg 477 input line too long
-
-	if (sw_verify)
-		fputs(buffer, stdout);
-
-	return true;
-}
-
-
-static int nextchar(const bool eof_ok)
-{
-/**************************************
- *
- *	n e x t c h a r
- *
- **************************************
- *
- * Functional description
- *	Get the next character from the input stream.
- *
- **************************************/
-	// Get the next character in the current line.  If we run out,
-	// get the next line.  If the line source runs out, pop the
-	// line source.  If we run out of line sources, we are distinctly
-	// at end of file.
-
-	while (QLI_line)
-	{
-		const SSHORT c = *QLI_line->line_ptr++;
-		if (c)
-			return c;
-		next_line(eof_ok);
-	}
-
-	return 0;
-}
-
-
-static void next_line(const bool eof_ok)
-{
-/**************************************
- *
- *	n e x t _ l i n e
- *
- **************************************
- *
- * Functional description
- *	Get the next line from the input stream.
- *
- **************************************/
-	TEXT* p;
-
-	while (QLI_line)
-	{
-		bool flag = false;
-
-		// Get next line from where ever.  If it comes from either the terminal
-		//   or command file, check for another command file.
-
-		if (QLI_line->line_type == line_blob)
-		{
-			// If the current blob segment contains another line, use it
-
-			if ((p = QLI_line->line_ptr) != QLI_line->line_data && p[-1] == '\n' && *p)
-			{
-				flag = true;
-			}
-			else
-			{
-				// Initialize line block for retrieval
-
-				p = QLI_line->line_data;
-				QLI_line->line_ptr = QLI_line->line_data;
-
-				flag = PRO_get_line(QLI_line->line_source_blob, p, QLI_line->line_size);
-				if (flag && QLI_echo)
-					printf("%s", QLI_line->line_data);
-			}
-		}
-		else
-		{
-			// Initialize line block for retrieval
-
-			QLI_line->line_ptr = QLI_line->line_data;
-			p = QLI_line->line_data;
-
-			if (QLI_line->line_type == line_stdin)
-				flag = LEX_get_line(QLI_prompt, p, (int) QLI_line->line_size);
-			else if (QLI_line->line_type == line_file)
-			{
-				flag = get_line(QLI_line->line_source_file, p, QLI_line->line_size);
-				if (QLI_echo)
-					printf("%s", QLI_line->line_data);
-			}
-			if (flag)
-			{
-				TEXT* q;
-				for (q = p; classes(*q) & CHR_white; q++);
-				if (*q == '@')
-				{
-					TEXT filename[MAXPATHLEN];
-					for (p = q + 1, q = filename; *p && *p != '\n';)
-						*q++ = *p++;
-					*q = 0;
-					QLI_line->line_ptr = p;
-					LEX_push_file(filename, true);
-					continue;
-				}
-			}
-		}
-
-		// If get got a line, we're almost done
-
-		if (flag)
-			break;
-
-		// We hit end of file.  Either complain about the circumstances
-		//   or just close out the current input source.  Don't close the
-		//   input source if it's the terminal and we're at a continuation
-		//   prompt.
-
-		if (eof_ok && (QLI_line->line_next || QLI_prompt != QLI_cont_string))
-		{
-			LEX_pop_line();
-			return;
-		}
-
-		// this is an unexpected end of file
-
-		switch (QLI_line->line_type)
-		{
-		case line_blob:
-			ERRQ_print_error(64, QLI_line->line_source_name);
-			// Msg 64 unexpected end of procedure in procedure %s
-			break;
-		case line_file:
-			ERRQ_print_error(65, QLI_line->line_source_name);
-			// Msg 65 unexpected end of file in file %s
-			break;
-		default:
-			if (QLI_line->line_type == line_string)
-				LEX_pop_line();
-			IBERROR(66);		// Msg 66 unexpected eof
-		}
-	}
-
-	if (!QLI_line)
-		return;
-
-	QLI_line->line_position = QLI_position;
-
-	// Dump output to the trace file
-
-	if (QLI_line->line_type == line_blob)
-	{
-		while (*p)
-			p++;
-	}
-	else
-	{
-		while (*p)
-			putc(*p++, trace_file);
-		QLI_position += (TEXT*) p - QLI_line->line_data;
-#ifdef WIN_NT
-		// account for the extra line-feed on OS/2 and Windows NT
-		//   to determine file position
-
-		QLI_position++;
-#endif
-	}
-
-	QLI_line->line_length = (TEXT*) p - QLI_line->line_data;
-}
-
-
-static void retchar()
-{
-/**************************************
- *
- *	r e t c h a r
- *
- **************************************
- *
- * Functional description
- *	Return a character to the input stream.
- *
- **************************************/
-
-	// CVC: Too naive implementation: what if the pointer is at the beginning?
-	fb_assert(QLI_line);
-	--QLI_line->line_ptr;
-}
-
-
-static bool scan_number(SSHORT c, TEXT** ptr)
-{
-/**************************************
- *
- *	s c a n _ n u m b e r
- *
- **************************************
- *
- * Functional description
- *	Pass on a possible numeric literal.
- *
- **************************************/
-	bool dot = false;
-
-	// If this is a leading decimal point, check that the next
-	//   character is really a digit, otherwise backout
-
-	if (c == '.')
-	{
-		c = nextchar(true);
-		retchar();
-		if (!(classes(c) & CHR_digit))
-			return false;
-		dot = true;
-	}
-
-	TEXT* p = *ptr;
-
-	// Gobble up digits up to a single decimal point
-
-	for (;;)
-	{
-		c = nextchar(true);
-		if (classes(c) & CHR_digit)
-			*p++ = c;
-		else if (!dot && c == '.')
-		{
-			*p++ = c;
-			dot = true;
-		}
-		else
-			break;
-	}
-
-	// If this is an exponential, eat the exponent sign and digits
-
-	if (UPPER(c) == 'E')
-	{
-		*p++ = c;
-		c = nextchar(true);
-		if (c == '+' || c == '-')
-		{
-			*p++ = c;
-			c = nextchar(true);
-		}
-		while (classes(c) & CHR_digit)
-		{
-			*p++ = c;
-			c = nextchar(true);
-		}
-	}
-
-	retchar();
-	*ptr = p;
-
-	return true;
-}
-
-
-static int skip_white()
-{
-/**************************************
- *
- *	s k i p _ w h i t e
- *
- **************************************
- *
- * Functional description
- *	Skip over while space and comments in input stream
- *
- **************************************/
-	SSHORT c;
-
-	while (true)
-	{
-		c = nextchar(true);
-		const char char_class = classes(c);
-		if (char_class & CHR_white)
-			continue;
-		if (c == '/')
-		{
-		    SSHORT next = nextchar(true);
-			if (next != '*')
-			{
-				retchar();
-				return c;
-			}
-			c = nextchar(false);
-			while ((next = nextchar(false)) && !(c == '*' && next == '/'))
-				c = next;
-			continue;
-		}
-		break;
-	}
-
-	return c;
-}
-
-
diff --git a/src/qli/lex_proto.h b/src/qli/lex_proto.h
deleted file mode 100644
index 420b695a8a..0000000000
--- a/src/qli/lex_proto.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		lex_proto.h
- *	DESCRIPTION:	Prototype header file for lex.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_LEX_PROTO_H
-#define QLI_LEX_PROTO_H
-
-bool	LEX_active_procedure ();
-void	LEX_edit (SLONG, SLONG);
-qli_tok*	LEX_edit_string();
-qli_tok*	LEX_filename();
-void	LEX_fini ();
-void	LEX_flush ();
-bool	LEX_get_line (const TEXT*, TEXT*, int);
-void	LEX_init ();
-void	LEX_mark_statement ();
-void	LEX_pop_line ();
-void	LEX_procedure(qli_dbb*, FB_API_HANDLE);
-bool	LEX_push_file (const TEXT*, const bool);
-bool	LEX_push_string (const TEXT* const);
-void	LEX_put_procedure (FB_API_HANDLE, SLONG, SLONG);
-void	LEX_real ();
-qli_lls*	LEX_statement_list();
-qli_tok*	LEX_token();
-
-#endif // QLI_LEX_PROTO_H
-
diff --git a/src/qli/meta_proto.h b/src/qli/meta_proto.h
deleted file mode 100644
index 11bd4934b6..0000000000
--- a/src/qli/meta_proto.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		meta_proto.h
- *	DESCRIPTION:	Prototype header file for meta.epp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_META_PROTO_H
-#define QLI_META_PROTO_H
-
-bool	MET_declare(qli_dbb*, qli_fld*, const qli_name*);
-void	MET_define_field(qli_dbb*, qli_fld*);
-void	MET_define_index(qli_syntax*);
-void	MET_define_relation(qli_rel*, qli_rel*);
-void	MET_define_sql_relation(qli_rel*);
-void	MET_delete_database(qli_dbb*);
-void	MET_delete_field(qli_dbb*, qli_name*);
-void	MET_delete_index(qli_dbb*, qli_name*);
-void	MET_delete_relation(qli_rel*);
-int		MET_dimensions(qli_dbb*, const TEXT*);
-void	MET_fields(qli_rel*);
-void	MET_finish(qli_dbb*);
-int		MET_get_datatype (USHORT);
-void	MET_index_info(qli_dbb* db, const TEXT*, const TEXT*, SCHAR* const, size_t bufsize);
-void	MET_meta_commit(qli_dbb*);
-void	MET_meta_rollback(qli_dbb*);
-FB_API_HANDLE	MET_meta_transaction(qli_dbb*, bool);
-void	MET_modify_field(qli_dbb*, qli_fld*);
-void	MET_modify_index(qli_syntax*);
-void	MET_modify_relation(qli_rel*, qli_fld*);
-void	MET_ready(qli_syntax*, const bool);
-void	MET_shutdown();
-void	MET_sql_alter_table(qli_rel*, qli_fld*);
-void	MET_sql_cr_view(qli_syntax*);
-void	MET_sql_grant(qli_syntax*);
-void	MET_sql_revoke(qli_syntax*);
-FB_API_HANDLE	MET_transaction(nod_t, qli_dbb*);
-
-#endif // QLI_META_PROTO_H
-
diff --git a/src/qli/mov.cpp b/src/qli/mov.cpp
deleted file mode 100644
index 93fc214d04..0000000000
--- a/src/qli/mov.cpp
+++ /dev/null
@@ -1,1644 +0,0 @@
-/*
- *	PROGRAM:	QLI Access Method
- *	MODULE:		mov.cpp
- *	DESCRIPTION:	Data mover and converter and comparator, etc.
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <string.h>
-#include "../qli/dtr.h"
-#include "../common/classes/timestamp.h"
-#include "../jrd/intl.h"
-#include "../qli/err_proto.h"
-#include "../yvalve/gds_proto.h"
-#include "../common/gdsassert.h"
-#include "../qli/mov_proto.h"
-#include "../common/utils_proto.h"
-
-using MsgFormat::SafeArg;
-
-
-static void date_error(const TEXT*, const USHORT);
-static double double_from_text(const dsc* desc);
-static void sql_date_to_text(const SLONG[1], DSC*);
-static void sql_time_to_text(const ULONG[1], DSC*);
-static void timestamp_to_text(const SLONG[2], DSC*);
-static void mover_error(int, USHORT, USHORT);
-static void now_to_date(const tm*, SLONG[2]);
-static void numeric_to_text(const dsc*, dsc*);
-static void string_to_date(const TEXT*, USHORT, SLONG[2]);
-static void string_to_time(const TEXT*, USHORT, SLONG[2]);
-static const TEXT* type_name(USHORT);
-
-
-
-#define LETTER(c)	(c >= 'A' && c <= 'Z')
-#define DIGIT(c)	(c >= '0' && c <= '9')
-const char* const TODAY = "TODAY";
-const char* const NOW = "NOW";
-const char* const TOMORROW = "TOMORROW";
-const char* const YESTERDAY = "YESTERDAY";
-
-const int PRECISION		= 10000;
-
-struct dtypes_t
-{
-	USHORT type;
-	const TEXT* description;
-};
-
-static const dtypes_t dtypes_table[] =
-{
-	{ dtype_unknown, "NULL" },
-	{ dtype_text, "character string" },
-	{ dtype_cstring, "character string" },
-	{ dtype_varying, "varying string" },
-	{ dtype_packed, "packed decimal" },
-	{ dtype_byte, "byte integer" },
-	{ dtype_short, "short integer" },
-	{ dtype_long, "long integer" },
-	{ dtype_quad, "quadword integer" },
-	{ dtype_real, "single precision floating" },
-	{ dtype_double, "double precision floating" },
-	{ dtype_d_float, "double precision floating" },
-	{ dtype_timestamp, "date" },
-	{ dtype_sql_date, "SQL date" },
-	{ dtype_sql_time, "SQL time" },
-	{ dtype_blob, "blob" },
-	{ dtype_int64, "big integer" },
-	{ 0, 0 }
-};
-
-
-int MOVQ_compare(const dsc* arg1, const dsc* arg2)
-{
-/**************************************
- *
- *	M O V Q _ c o m p a r e
- *
- **************************************
- *
- * Functional description
- *	Compare two descriptors.  Return (-1, 0, 1) if a<b, a=b, or a>b.
- *
- **************************************/
-
-	// Handle the simple (matched) ones first
-
-	if (arg1->dsc_dtype == arg2->dsc_dtype && arg1->dsc_scale == arg2->dsc_scale)
-	{
-		const UCHAR* p1 = arg1->dsc_address;
-		const UCHAR* p2 = arg2->dsc_address;
-
-		switch (arg1->dsc_dtype)
-		{
-		case dtype_short:
-			if (*(SSHORT*) p1 == *(SSHORT*) p2)
-				return 0;
-			if (*(SSHORT*) p1 > *(SSHORT*) p2)
-				return 1;
-			return -1;
-
-		case dtype_long:
-		case dtype_sql_date:
-		case dtype_sql_time:
-			if (*(SLONG*) p1 == *(SLONG*) p2)
-				return 0;
-			if (*(SLONG*) p1 > *(SLONG*) p2)
-				return 1;
-			return -1;
-		case dtype_int64:
-       	case dtype_timestamp:
-		case dtype_quad:
-			if (((SLONG*) p1)[0] < ((SLONG*) p2)[0])
-				return -1;
-			if (((SLONG*) p1)[0] > ((SLONG*) p2)[0])
-				return 1;
-			if (((ULONG*) p1)[1] < ((ULONG*) p2)[1])
-				return -1;
-			if (((ULONG*) p1)[1] > ((ULONG*) p2)[1])
-				return 1;
-			return 0;
-
-		case dtype_real:
-			if (*(float*) p1 == *(float*) p2)
-				return 0;
-			if (*(float*) p1 > *(float*) p2)
-				return 1;
-			return -1;
-
-		case dtype_double:
-			if (*(double*) p1 == *(double*) p2)
-				return 0;
-			if (*(double*) p1 > *(double*) p2)
-				return 1;
-			return -1;
-
-		case dtype_text:
-			{
-			    SSHORT length;
-				if (arg1->dsc_length >= arg2->dsc_length)
-				{
-					if (length = arg2->dsc_length)
-						do {
-							if (*p1++ != *p2++)
-								return (p1[-1] > p2[-1]) ? 1 : -1;
-						} while (--length);
-					if (length = arg1->dsc_length - arg2->dsc_length)
-						do {
-							if (*p1++ != ' ')
-								return (p1[-1] > ' ') ? 1 : -1;
-						} while (--length);
-					return 0;
-				}
-				if (length = arg1->dsc_length)
-					do {
-						if (*p1++ != *p2++)
-							return (p1[-1] > p2[-1]) ? 1 : -1;
-					} while (--length);
-				length = arg2->dsc_length - arg1->dsc_length;
-				do {
-					if (*p2++ != ' ')
-						return (' ' > p2[-1]) ? 1 : -1;
-				} while (--length);
-				return 0;
-			}
-		}
-	}
-
-	// Handle mixed string comparisons
-
-	if (arg1->dsc_dtype <= dtype_varying && arg2->dsc_dtype <= dtype_varying)
-	{
-	    const TEXT* p1;
-	    const TEXT* p2;
-		SSHORT length = MOVQ_get_string(arg1, &p1, 0, 0);
-		SSHORT length2 = MOVQ_get_string(arg2, &p2, 0, 0);
-		SSHORT fill = length - length2;
-		if (length >= length2)
-		{
-			if (length2)
-				do {
-					if (*p1++ != *p2++)
-						return (p1[-1] > p2[-1]) ? 1 : -1;
-				} while (--length2);
-			if (fill > 0)
-				do {
-					if (*p1++ != ' ')
-						return (p1[-1] > ' ') ? 1 : -1;
-				} while (--fill);
-			return 0;
-		}
-		if (length)
-		{
-			do {
-				if (*p1++ != *p2++)
-					return (p1[-1] > p2[-1]) ? 1 : -1;
-			} while (--length);
-		}
-		do {
-			if (*p2++ != ' ')
-				return (' ' > p2[-1]) ? 1 : -1;
-		} while (++fill);
-		return 0;
-	}
-
-	// Handle hetergeneous compares
-
-	if (arg1->dsc_dtype < arg2->dsc_dtype)
-		return (-MOVQ_compare(arg2, arg1));
-
-	dsc desc;
-	SLONG date[2];
-
-	switch (arg1->dsc_dtype)
-	{
-	case dtype_timestamp:
-		desc.dsc_dtype = dtype_timestamp;
-		desc.dsc_length = sizeof(date);
-		desc.dsc_scale = 0;
-		desc.dsc_address = (UCHAR*) date;
-		desc.dsc_sub_type = 0;
-		MOVQ_move(arg2, &desc);
-		return MOVQ_compare(arg1, &desc);
-
-	case dtype_sql_time:
-		desc.dsc_dtype = dtype_sql_time;
-		desc.dsc_length = sizeof(date[0]);
-		desc.dsc_scale = 0;
-		desc.dsc_address = (UCHAR*) date;
-		desc.dsc_sub_type = 0;
-		MOVQ_move(arg2, &desc);
-		return MOVQ_compare(arg1, &desc);
-
-	case dtype_sql_date:
-		desc.dsc_dtype = dtype_sql_date;
-		desc.dsc_length = sizeof(date[0]);
-		desc.dsc_scale = 0;
-		desc.dsc_address = (UCHAR*) date;
-		desc.dsc_sub_type = 0;
-		MOVQ_move(arg2, &desc);
-		return MOVQ_compare(arg1, &desc);
-
-	case dtype_short:
-	case dtype_long:
-		{
-			const SSHORT scale = MIN(arg1->dsc_scale, arg2->dsc_scale);
-
-			const SLONG temp1 = MOVQ_get_long(arg1, scale);
-			const SLONG temp2 = MOVQ_get_long(arg2, scale);
-			if (temp1 == temp2)
-				return 0;
-			if (temp1 > temp2)
-				return 1;
-			return -1;
-		}
-
-	case dtype_real:
-		{
-			const float temp1 = MOVQ_get_double(arg1);
-			const float temp2 = MOVQ_get_double(arg2);
-			if (temp1 == temp2)
-				return 0;
-			if (temp1 > temp2)
-				return 1;
-			return -1;
-		}
-
-	case dtype_double:
-		{
-			const double temp1 = MOVQ_get_double(arg1);
-			const double temp2 = MOVQ_get_double(arg2);
-			if (temp1 == temp2)
-				return 0;
-			if (temp1 > temp2)
-				return 1;
-			return -1;
-		}
-
-	case dtype_blob:
-		IBERROR(48);			// Msg 48 Blob conversion is not supported
-
-	default:
-		mover_error(410, arg1->dsc_dtype, arg2->dsc_dtype);
-
-	}
-	return -1;
-}
-
-
-double MOVQ_date_to_double(const dsc* desc)
-{
-/**************************************
- *
- *	M O V Q _ d a t e _ t o _ d o u b l e
- *
- **************************************
- *
- * Functional description
- *    Convert a date to double precision for
- *    date arithmetic routines.
- *
- **************************************/
-	SLONG temp[2], *date;
-
-	// If the input descriptor is not in date form, convert it.
-
-	if (desc->dsc_dtype == dtype_timestamp)
-		date = (SLONG *) desc->dsc_address;
-	else
-	{
-	    dsc temp_desc;
-		temp_desc.dsc_dtype = dtype_timestamp;
-		temp_desc.dsc_length = sizeof(temp);
-		temp_desc.dsc_scale = 0;
-		temp_desc.dsc_sub_type = 0;
-		date = temp;
-		temp_desc.dsc_address = (UCHAR*) date;
-		QLI_validate_desc(temp_desc);
-		MOVQ_move(desc, &temp_desc);
-	}
-
-	return date[0] + (double) date[1] / (24. * 60. * 60. * PRECISION);
-}
-
-
-int MOVQ_decompose(const TEXT* string, USHORT length, SLONG* return_value)
-{
-/**************************************
- *
- *	M O V Q _ d e c o m p o s e
- *
- **************************************
- *
- * Functional description
- *	Decompose a numeric string in mantissa and exponent.
- *
- **************************************/
-	SSHORT scale = 0;
-	SLONG value = 0;
-	SCHAR temp[128];
-
-	bool sign = false;
-	bool fraction = false;
-
-	const TEXT* p = string;
-	const TEXT* const end = p + length;
-	for (; p < end; p++)
-	{
-		if (*p == ',')
-			continue;
-
-		if (DIGIT(*p))
-		{
-			value = value * 10 + *p - '0';
-			if (fraction)
-				--scale;
-		}
-		else if (*p == '.')
-		{
-			if (fraction)
-			{
-				MOVQ_terminate(string, temp, length, sizeof(temp));
-				ERRQ_error(411, temp);
-			}
-			else
-				fraction = true;
-		}
-		else if (*p == '-' && !value && !sign)
-			sign = true;
-		else if (*p == '+' && !value && !sign)
-			sign = false;
-		else if (*p == 'e' || *p == 'E')
-			break;
-		else if (*p != ' ')
-		{
-			MOVQ_terminate(string, temp, length, sizeof(temp));
-			ERRQ_error(411, temp);
-		}
-	}
-
-	if (sign)
-		value = -value;
-
-	// If there's still something left, there must be an explicit exponent
-
-	if (p < end)
-	{
-		SSHORT exp = 0;
-		sign = false;
-		for (p++; p < end; p++)
-		{
-			if (DIGIT(*p))
-				exp = exp * 10 + *p - '0';
-			else if (*p == '-' && !exp)
-				sign = true;
-			else if (*p == '+' && !exp && !sign)
-				continue;
-			else if (*p != ' ')
-			{
-				MOVQ_terminate(string, temp, length, sizeof(temp));
-				ERRQ_error(411, temp);
-			}
-		}
-		if (sign)
-			scale -= exp;
-		else
-			scale += exp;
-	}
-
-	*return_value = value;
-
-	return scale;
-}
-
-
-void MOVQ_double_to_date( double real, SLONG fixed[2])
-{
-/**************************************
- *
- *	M O V Q _ d o u b l e _ t o _ d a t e
- *
- **************************************
- *
- * Functional description
- *	Convert a double precision representation of a date
- *	to a fixed point representation.   Double is used for
- *      date arithmetic.
- *
- **************************************/
-
-	fixed[0] = static_cast<SLONG>(real);
-	fixed[1] = static_cast<SLONG>((real - fixed[0]) * 24. * 60. * 60. * PRECISION);
-}
-
-
-double MOVQ_get_double(const dsc* desc)
-{
-/**************************************
- *
- *	M O V Q _ g e t _ d o u b l e
- *
- **************************************
- *
- * Functional description
- *	Convert something arbitrary to a
- *	double_precision representation.
- *
- **************************************/
-	double value = 0;
-
-	switch (desc->dsc_dtype)
-	{
-	case dtype_short:
-		value = *((SSHORT*) desc->dsc_address);
-		break;
-
-	case dtype_long:
-		value = *((SLONG*) desc->dsc_address);
-		break;
-
-	case dtype_int64:
-		value = *((SINT64*) desc->dsc_address);
-		break;
-
-	case dtype_real:
-		return *((float*) desc->dsc_address);
-
-	case dtype_double:
-		return *((double*) desc->dsc_address);
-
-	case dtype_varying:
-	case dtype_cstring:
-	case dtype_text:
-		return double_from_text(desc);
-
-	default:
-		mover_error(410, desc->dsc_dtype, dtype_double);
-	}
-
-	// Last, but not least, adjust for scale
-
-	int scale = desc->dsc_scale;
-	if (scale == 0)
-		return value;
-
-	if (scale > 0)
-		do {
-			value *= 10.;
-		} while (--scale);
-	else
-		do {
-			value /= 10.;
-		} while (++scale);
-
-	return value;
-}
-
-
-SLONG MOVQ_get_long(const dsc* desc, SSHORT scale)
-{
-/**************************************
- *
- *	M O V Q _ g e t _ l o n g
- *
- **************************************
- *
- * Functional description
- *	Convert something arbitrary to a long (32 bit) integer of given
- *	scale.
- *
- **************************************/
-	SLONG value;
-	double d;
-
-	scale -= (SSHORT) desc->dsc_scale;
-
-	const TEXT* p = (TEXT*) desc->dsc_address;
-	switch (desc->dsc_dtype)
-	{
-	case dtype_short:
-		value = *((SSHORT*) p);
-		break;
-
-	case dtype_int64:
-		value = *((SINT64*) p);
-		break;
-
-	case dtype_long:
-		value = *((SLONG*) p);
-		break;
-
-	case dtype_real:
-		d = *((float*) p);
-		if (scale > 0)
-			do {
-				d /= 10.;
-			} while (--scale);
-		else if (scale < 0)
-			do {
-				d *= 10.;
-			} while (++scale);
-		if (d > 0)
-			d += 0.5;
-		else
-			d -= 0.5;
-		return (SLONG) d;
-
-	case dtype_double:
-		d = *((double*) p);
-		if (scale > 0)
-			do {
-				d /= 10.;
-			} while (--scale);
-		else if (scale < 0)
-			do {
-				d *= 10.;
-			} while (++scale);
-		if (d > 0)
-			d += 0.5;
-		else
-			d -= 0.5;
-		return (SLONG) d;
-
-	case dtype_varying:
-	case dtype_cstring:
-	case dtype_text:
-		{
-			const SSHORT length = MOVQ_get_string(desc, &p, 0, 0);
-			scale -= MOVQ_decompose(p, length, &value);
-			break;
-		}
-
-	default:
-		mover_error(410, desc->dsc_dtype, dtype_long);
-	}
-
-	// Last, but not least, adjust for scale
-
-	if (scale == 0)
-		return value;
-
-	if (scale > 0)
-	{
-		if ((desc->dsc_dtype == dtype_short) || (desc->dsc_dtype == dtype_long))
-		{
-			int fraction = 0;
-			do {
-				if (scale == 1)
-					fraction = value % 10;
-				value /= 10;
-			} while (--scale);
-			if (fraction > 4)
-				value++;
-		}
-		else
-			do {
-				value /= 10;
-			} while (--scale);
-	}
-	else
-		do {
-			value *= 10;
-		} while (++scale);
-
-	return value;
-}
-
-
-int MOVQ_get_string(const dsc* desc, const TEXT** address, vary* temp, USHORT length)
-{
-/**************************************
- *
- *	M O V Q _  g e t _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Get address and length of string, converting the value to
- *	string, if necessary.  The caller must provide a sufficiently
- *	large temporary.  The address of the resultant string is returned
- *	by reference.  Get_string returns the length of the string.
- *
- *	Note: If the descriptor is known to be a string type, the third
- *	argument (temp buffer) may be omitted.
- *
- **************************************/
-
-	// If the value is already a string (fixed or varying), just return
-	// the address and length.
-
-	if (desc->dsc_dtype == dtype_text)
-	{
-		*address = (TEXT*) desc->dsc_address;
-		return desc->dsc_length;
-	}
-
-	// Perhaps it a "C" type string?
-
-	if (desc->dsc_dtype == dtype_cstring)
-	{
-		*address = (TEXT*) desc->dsc_address;
-		return MIN(static_cast<int>(strlen((char*)desc->dsc_address)), desc->dsc_length - 1);
-	}
-
-	// No luck -- convert value to varying string.
-
-	if (desc->dsc_dtype == dtype_varying)
-	{
-		vary* varying = (vary*) desc->dsc_address;
-		*address = varying->vary_string;
-		return varying->vary_length;
-	}
-
-	dsc temp_desc;
-	temp_desc.dsc_length = length;
-	temp_desc.dsc_address = (UCHAR*) temp;
-	temp_desc.dsc_scale = 0;
-	temp_desc.dsc_dtype = dtype_varying;
-	temp_desc.dsc_sub_type = ttype_ascii;
-	QLI_validate_desc(temp_desc);
-	MOVQ_move(desc, &temp_desc);
-	*address = temp->vary_string;
-
-	return temp->vary_length;
-}
-
-
-void MOVQ_move(const dsc* from, dsc* to)
-{
-/**************************************
- *
- *	M O V Q _ m o v e
- *
- **************************************
- *
- * Functional description
- *	Move (and possible convert) something to something else.
- *
- **************************************/
-	USHORT length = from->dsc_length;
-	UCHAR* p = to->dsc_address;
-	const UCHAR* q = from->dsc_address;
-
-	// If the datatypes and lengths are identical, just move the
-	// stuff byte by byte.  Although this may seem slower than
-	// optimal, it would cost more to find the fast move than the
-	// fast move would gain.
-
-	// if (((ALT_DSC*) from)->dsc_combined_type == ((ALT_DSC*) to)->dsc_combined_type)
-   	if (DSC_EQUIV(from, to, false))
-	{
-		if (length)
-			memcpy(p, q, length);
-
-		return;
-	}
-
-	const TEXT* ptr;
-
-	// Do data type by data type conversions.  Not all are supported,
-	// and some will drop out for additional handling.
-
-	switch (to->dsc_dtype)
-	{
-	case dtype_timestamp:
-		switch (from->dsc_dtype)
-		{
-		case dtype_varying:
-		case dtype_cstring:
-		case dtype_text:
-			length = MOVQ_get_string(from, &ptr, 0, 0);
-			string_to_date((TEXT*) ptr, length, (SLONG*) to->dsc_address);
-			return;
-		case dtype_sql_date:
-			((SLONG*) to->dsc_address)[0] = *(SLONG*) from->dsc_address;
-			((SLONG*) to->dsc_address)[1] = 0;
-			return;
-		case dtype_sql_time:
-			((SLONG*) to->dsc_address)[0] = 0;
-			((SLONG*) to->dsc_address)[1] = *(SLONG*) from->dsc_address;
-			return;
-		}
-		break;
-
-	case dtype_sql_date:
-		switch (from->dsc_dtype)
-		{
-		case dtype_varying:
-		case dtype_cstring:
-		case dtype_text:
-			{
-				SLONG date[2];
-				length = MOVQ_get_string(from, &ptr, 0, 0);
-				string_to_date((TEXT*) ptr, length, (SLONG*) date);
-				((SLONG*) to->dsc_address)[0] = date[0];
-			}
-			return;
-		case dtype_timestamp:
-			((SLONG*) to->dsc_address)[0] = ((SLONG*) from->dsc_address)[0];
-			return;
-		case dtype_sql_time:
-			// Error situation
-			break;
-		}
-		break;
-
-	case dtype_sql_time:
-		switch (from->dsc_dtype)
-		{
-		case dtype_varying:
-		case dtype_cstring:
-		case dtype_text:
-			{
-				SLONG date[2];
-				length = MOVQ_get_string(from, &ptr, 0, 0);
-				string_to_time((TEXT*) ptr, length, (SLONG*) date);
-				((SLONG*) to->dsc_address)[0] = date[1];
-			}
-			return;
-		case dtype_timestamp:
-			((SLONG*) to->dsc_address)[0] = ((SLONG*) from->dsc_address)[1];
-			return;
-		case dtype_sql_date:
-			// Error situation
-			break;
-		}
-		break;
-
-	case dtype_text:
-	case dtype_cstring:
-	case dtype_varying:
-		switch (from->dsc_dtype)
-		{
-		case dtype_varying:
-		case dtype_cstring:
-		case dtype_text:
-			{
-				length = MOVQ_get_string(from, &ptr, 0, 0);
-				const TEXT* s = ptr;
-
-				switch (to->dsc_dtype)
-				{
-				case dtype_text:
-					{
-						length = MIN(length, to->dsc_length);
-						SSHORT fill = to->dsc_length - length;
-						if (length)
-							memcpy(p, s, length);
-						if (fill > 0)
-							memset(p + length, ' ', fill);
-						return;
-					}
-
-				case dtype_cstring:
-					length = MIN(length, to->dsc_length - 1);
-					if (length)
-						memcpy(p, s, length);
-					p[length] = 0;
-					return;
-
-				case dtype_varying:
-					{
-						length = MIN(length, to->dsc_length - sizeof(SSHORT));
-						vary* avary = reinterpret_cast<vary*>(p);
-						avary->vary_length = length;
-						if (length)
-							memcpy(avary->vary_string, s, length);
-					}
-					return;
-				}
-			}
-
-		case dtype_int64:
-		case dtype_short:
-		case dtype_long:
-		case dtype_real:
-		case dtype_double:
-			numeric_to_text(from, to);
-			return;
-
-		case dtype_sql_date:
-			sql_date_to_text((SLONG*) from->dsc_address, to);
-			return;
-		case dtype_sql_time:
-			sql_time_to_text((ULONG*) from->dsc_address, to);
-			return;
-		case dtype_timestamp:
-			timestamp_to_text((SLONG*) from->dsc_address, to);
-			return;
-		}
-		break;
-
-	case dtype_blob:
-		if (from->dsc_dtype == dtype_quad)
-		{
-			((SLONG*) p)[0] = ((SLONG*) q)[0];
-			((SLONG*) p)[1] = ((SLONG*) q)[1];
-			return;
-		}
-		break;
-
-	case dtype_quad:
-		if (from->dsc_dtype == dtype_blob)
-		{
-			((SLONG*) p)[0] = ((SLONG*) q)[0];
-			((SLONG*) p)[1] = ((SLONG*) q)[1];
-			return;
-		}
-		break;
-
-	case dtype_short:
-		{
-			const SLONG l = MOVQ_get_long(from, to->dsc_scale);
-			*(SSHORT*) p = l;
-			if (*(SSHORT*) p != l)
-				IBERROR(14);		// Msg14 integer overflow
-			return;
-		}
-
-	case dtype_long:
-		*(SLONG*) p = MOVQ_get_long(from, to->dsc_scale);
-		return;
-
-	case dtype_int64:
-		*(SINT64*) p = MOVQ_get_long(from, to->dsc_scale);
-		return;
-
-	case dtype_real:
-		*(float*) p = MOVQ_get_double(from);
-		return;
-
-	case dtype_double:
-		*(double*) p = MOVQ_get_double(from);
-		return;
-	}
-
-	if (to->dsc_dtype == dtype_blob || from->dsc_dtype == dtype_blob)
-		IBERROR(55);			// Msg 55 Blob conversion is not supported
-
-	mover_error(410, from->dsc_dtype, to->dsc_dtype);
-}
-
-
-void MOVQ_terminate(const SCHAR* from, SCHAR* to, USHORT length, USHORT max_length)
-{
-/**************************************
- *
- *	M O V Q _ t e r m i n a t e
- *
- **************************************
- *
- * Functional description
- *	Null-terminate a possibly non-
- *	null-terminated string with max
- *	buffer room.
- *
- **************************************/
-
-	fb_assert(max_length != 0);
-	if (length)
-	{
-		length = MIN(length, max_length - 1);
-		memcpy(to, from, length);
-		to[length] = '\0';
-	}
-	else
-		fb_utils::copy_terminate(to, from, max_length);
-}
-
-
-static void date_error(const TEXT* string, const USHORT length)
-{
-/**************************************
- *
- *	d a t e _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	A date conversion error occurred.  Complain.
- *
- **************************************/
-	SCHAR temp[128];
-
-	MOVQ_terminate(string, temp, length, sizeof(temp));
-	ERRQ_error(56, temp);
-	// Msg 56 Error converting string \"%s\" to date
-}
-
-
-static double double_from_text(const dsc* desc)
-{
-	const TEXT* p;
-	const SSHORT length = MOVQ_get_string(desc, &p, 0, 0);
-	int scale = 0;
-	bool fraction = false, sign = false;
-	double value = 0;
-	const TEXT* const end = p + length;
-	for (; p < end; p++)
-	{
-		if (*p == ',')
-			continue;
-
-		if (DIGIT(*p))
-		{
-			value = value * 10. + (*p - '0');
-			if (fraction)
-				scale++;
-		}
-		else if (*p == '.')
-		{
-			if (fraction)
-				IBERROR(52);	// Msg 52 conversion error
-			else
-				fraction = true;
-		}
-		else if (!value && *p == '-')
-			sign = true;
-		else if (!value && *p == '+')
-			continue;
-		else if (*p == 'e' || *p == 'E')
-			break;
-		else if (*p != ' ')
-			IBERROR(53);	// Msg 53 conversion error
-	}
-
-	if (sign)
-		value = -value;
-
-	// If there's still something left, there must be an explicit exponent
-
-	if (p < end)
-	{
-		sign = false;
-		int exp = 0;
-		for (p++; p < end; p++)
-		{
-			if (DIGIT(*p))
-				exp = exp * 10 + *p - '0';
-			else if (*p == '-' && !exp)
-				sign = true;
-			else if (*p == '+' && !exp)
-				;
-			else if (*p != ' ')
-				IBERROR(54);	// Msg 54 conversion error
-		}
-		if (sign)
-			scale += exp;
-		else
-			scale -= exp;
-	}
-
-	if (scale > 0)
-		do {
-			value /= 10.;
-		} while (--scale);
-	else if (scale)
-		do {
-			value *= 10.;
-		} while (++scale);
-
-	return value;
-}
-
-
-static void sql_date_to_text( const SLONG date[1], DSC* to)
-{
-/**************************************
- *
- *	s q l _ d a t e _ t o _ t e x t
- *
- **************************************
- *
- * Functional description
- *	Convert date to text.
- *
- **************************************/
-	tm times;
-	SLONG date2[2];
-
-	date2[0] = date[0];
-	date2[1] = 0;
-	isc_decode_date((const ISC_QUAD*) date2, &times);
-
-	TEXT temp[35];
-	sprintf(temp, "%2d-%.3s-%04d", times.tm_mday,
-			FB_LONG_MONTHS_UPPER[times.tm_mon], times.tm_year + 1900);
-
-	const TEXT* p = temp;
-	while (*p)
-		++p;
-
-	dsc desc;
-	desc.dsc_length = p - temp;
-	desc.dsc_address = (UCHAR*) temp;
-	desc.dsc_dtype = dtype_text;
-	desc.dsc_scale = 0;
-	desc.dsc_sub_type = ttype_ascii;
-	QLI_validate_desc(desc);
-
-	MOVQ_move(&desc, to);
-}
-
-
-static void sql_time_to_text( const ULONG date[1], DSC* to)
-{
-/**************************************
- *
- *	s q l _ t i m e _ t o _ t e x t
- *
- **************************************
- *
- * Functional description
- *	Convert sql time to text.
- *
- **************************************/
-	tm times;
-	SLONG date2[2];
-
-	date2[0] = 0;
-	date2[1] = date[0];
-
-	isc_decode_date((const ISC_QUAD*) date2, &times);
-
-	TEXT temp[35];
-	sprintf(temp, " %2d:%.2d:%.2d.%.4" SLONGFORMAT, times.tm_hour, times.tm_min,
-			times.tm_sec, date2[1] % PRECISION);
-
-	const TEXT* p = temp;
-	while (*p)
-		++p;
-
-	dsc desc;
-	desc.dsc_length = p - temp;
-	desc.dsc_address = (UCHAR*) temp;
-	desc.dsc_dtype = dtype_text;
-	desc.dsc_scale = 0;
-	desc.dsc_sub_type = ttype_ascii;
-	QLI_validate_desc(desc);
-
-	MOVQ_move(&desc, to);
-}
-
-
-static void timestamp_to_text( const SLONG date[2], DSC* to)
-{
-/**************************************
- *
- *	t i m e s t a m p _ t o _ t e x t
- *
- **************************************
- *
- * Functional description
- *	Convert date to text.
- *
- **************************************/
-	tm times;
-	isc_decode_date((const ISC_QUAD*) date, &times);
-
-    TEXT temp[35];
-	sprintf(temp, "%2d-%.3s-%04d", times.tm_mday,
-			FB_LONG_MONTHS_UPPER[times.tm_mon], times.tm_year + 1900);
-
-	if (times.tm_hour || times.tm_min || times.tm_sec || date[1])
-	{
-		TEXT time[15];
-		sprintf(time, " %2d:%.2d:%.2d.%.4" SLONGFORMAT, times.tm_hour, times.tm_min,
-				times.tm_sec, date[1] % PRECISION);
-		strcat(temp, time);
-	}
-
-	const TEXT* p = temp;
-	while (*p)
-		++p;
-
-	dsc desc;
-	desc.dsc_length = p - temp;
-	desc.dsc_address = (UCHAR*) temp;
-	desc.dsc_dtype = dtype_text;
-	desc.dsc_scale = 0;
-	desc.dsc_sub_type = ttype_ascii;
-	QLI_validate_desc(desc);
-
-	MOVQ_move(&desc, to);
-}
-
-
-static void mover_error( int pattern, USHORT in_type, USHORT out_type)
-{
-/**************************************
- *
- *	m o v e r _ e r r o r
- *
- **************************************
- *
- * Functional description
- *	Return a reasonable error for
- *	unreasonable conversions and
- *	comparisons.
- *
- **************************************/
-	TEXT in_name[25], out_name[25], msg_unknown[40];
-
-	ERRQ_msg_get(504, msg_unknown, sizeof(msg_unknown));	// Msg504 unknown datatype %d
-
-	const TEXT* in = type_name(in_type);
-	if (!in)
-	{
-		in = in_name;
-		sprintf(in_name, msg_unknown, in_type);
-	}
-
-	const TEXT* out = type_name(out_type);
-	if (!out)
-	{
-		out = out_name;
-		sprintf(out_name, msg_unknown, out_type);
-	}
-
-	ERRQ_error(pattern, SafeArg() << in << out);
-}
-
-
-static void now_to_date(const tm* time, SLONG date[2])
-{
-/**************************************
- *
- *	n o w _ t o _ d a t e
- *
- **************************************
- *
- * Functional description
- *	Convert "now" (or best guess) to
- *	a date attempting to get millisecond
- *	precision.  This unfortunately means
- *	that we use one routine for VAX, one
- *	for Apollo, and a third for Unix.
- *
- **************************************/
-
-	isc_encode_date(time, (ISC_QUAD*)date);
-}
-
-
-static void numeric_to_text(const dsc* from, dsc* to)
-{
-/**************************************
- *
- *	n u m e r i c _ t o _ t e x t
- *
- **************************************
- *
- * Functional description
- *	Convert your basic number to nice, formatted text.
- *
- **************************************/
-
-	// Save (or compute) scale of source.  Then convert source to ordinary longword.
-
-	SSHORT scale = from->dsc_scale;
-
-	SSHORT pad = 0, decimal = 0;
-	if (scale > 0)
-		pad = scale;
-	else if (scale < 0)
-		decimal = 1;
-
-	SLONG n;
-	dsc intermediate;
-	intermediate.dsc_dtype = dtype_long;
-	intermediate.dsc_length = sizeof(SLONG);
-	intermediate.dsc_scale = scale;
-	intermediate.dsc_sub_type = 0;
-	intermediate.dsc_address = (UCHAR*) &n;
-	QLI_validate_desc(intermediate);
-
-	MOVQ_move(from, &intermediate);
-
-	// Check for negation, then convert the number to a string of digits
-
-	SSHORT neg = 0;
-	if (n < 0)
-	{
-		neg = 1;
-		n = -n;
-	}
-
-	TEXT temp[32];
-	TEXT* p = temp;
-
-	do {
-		*p++ = n % 10 + '0';
-		n /= 10;
-	} while (n);
-
-	// Compute the total length off the field formatted.  Make sure it
-	// fits.  Keep in mind that routine handles both string and varying
-	// string fields.
-
-	SSHORT l = p - temp;
-	const FB_SIZE_T length = l + neg + decimal + pad;
-
-	if ((to->dsc_dtype == dtype_text && length > to->dsc_length) ||
-		(to->dsc_dtype == dtype_cstring && length >= to->dsc_length) ||
-		(to->dsc_dtype == dtype_varying && length > to->dsc_length - sizeof(SSHORT)))
-	{
-		IBERROR(57);			// Msg 57 overflow during conversion
-	}
-
-	// Hopefully a cstring never reached this point.
-	TEXT* q = (TEXT*) ((to->dsc_dtype == dtype_text) ?
-		to->dsc_address : to->dsc_address + sizeof(SSHORT));
-
-	// If negative, put in minus sign
-
-	if (neg)
-		*q++ = '-';
-
-	// If a decimal point is required, do the formatting.  Otherwise just
-	// copy number
-
-	if (scale < 0)
-	{
-		if ((l += scale) > 0)
-			do {
-				*q++ = *--p;
-			} while (--l);
-		*q++ = '.';
-		do {
-			*q++ = *--p;
-		} while (++scale);
-	}
-	else
-		do {
-			*q++ = *--p;
-		} while (--l);
-
-	// If padding is required, do it now.
-
-	if (pad)
-		do {
-			*q++ = '0';
-		} while (--pad);
-
-	// Finish up by padding (if fixed) or computing the actual length
-	// (varying string)
-
-	if (to->dsc_dtype == dtype_text)
-	{
-		if (l = to->dsc_length - length)
-			do {
-				*q++ = ' ';
-			} while (--l);
-		return;
-	}
-
-	if (to->dsc_dtype == dtype_cstring)
-	{
-		*q = 0;
-		return;
-	}
-
-	*(SSHORT*) (to->dsc_address) = static_cast<SSHORT>((UCHAR*) q - to->dsc_address - sizeof(SSHORT));
-}
-
-
-static void string_to_date(const TEXT* string, USHORT length, SLONG date[2])
-{
-/**************************************
- *
- *	s t r i n g _ t o _ d a t e
- *
- **************************************
- *
- * Functional description
- *	Convert an arbitrary string to a date.
- *
- **************************************/
-	if (!length)
-	{
-		date[0] = date[1] = 0;
-		return;
-	}
-
-	const TEXT* p = string;
-	const TEXT* const end = p + length;
-
-	USHORT month_position = 0;
-
-	const time_t clock = time(0);
-	tm* today = localtime(&clock);
-
-	USHORT components[7];
-	for (int i = 0; i < 7; i++)
-		components[i] = 0;
-
-	// Parse components
-
-	TEXT temp[15];
-	USHORT n, precision;
-	bool year = false;
-
-	for (int i = 0; i < 7; i++)
-	{
-
-		// Skip leading blanks.  If we run out of characters, we're done with parse.
-
-		while (p < end && *p == ' ')
-			p++;
-		if (p == end)
-			break;
-
-		// Handle digit or character strings
-
-		TEXT c = UPPER(*p);
-		if (DIGIT(c))
-		{
-			precision = n = 0;
-			while (p < end && DIGIT(*p))
-			{
-				n = n * 10 + *p++ - '0';
-				precision++;
-			}
-			if (i == 2)
-				year = true;
-		}
-		else if (LETTER(c))
-		{
-			TEXT* t = temp;
-			while (p < end && LETTER(c))
-			{
-				c = UPPER(*p);
-				if (!LETTER(c))
-					break;
-				*t++ = c;
-				p++;
-			}
-			*t = 0;
-			const TEXT* const* month_ptr = FB_LONG_MONTHS_UPPER;
-			while (true)
-			{
-				if (!*month_ptr)
-				{
-					while (++p < end)
-						if (*p != ' ' && *p != '\t' && *p != 0)
-							date_error(string, length);
-
-					if (strcmp(temp, NOW) == 0)
-					{
-						now_to_date(today, date);
-						return;
-					}
-					today->tm_hour = today->tm_min = today->tm_sec = 0;
-					isc_encode_date(today, (ISC_QUAD*)date);
-					if (strcmp(temp, TODAY) == 0)
-						return;
-					if (strcmp(temp, TOMORROW) == 0)
-					{
-						++date[0];
-						return;
-					}
-					if (strcmp(temp, YESTERDAY) == 0)
-					{
-						--date[0];
-						return;
-					}
-					date_error(string, length);
-				}
-				t = temp;
-				for (const TEXT* m = *month_ptr++; *t && *t == *m; t++, m++);
-				if (!*t)
-					break;
-			}
-			n = month_ptr - FB_LONG_MONTHS_UPPER;
-			month_position = i;
-		}
-		else
-		{
-			date_error(string, length);
-			return;
-		}
-		components[i] = n;
-		while (p < end && *p == ' ')
-			p++;
-
-		switch (*p)
-		{
-		case '.':
-			if (!month_position && i < 2)
-				month_position = 1;
-			// fall into
-		case '/':
-		case '-':
-		case ',':
-		case ':':
-			p++;
-			continue;
-		}
-	}
-
-	// Slide things into day, month, year form
-
-	tm times;
-	if (month_position)
-	{
-		times.tm_mon = components[1];
-		times.tm_mday = components[0];
-	}
-	else
-	{
-		times.tm_mon = components[0];
-		times.tm_mday = components[1];
-	}
-
-	// Handle defaulting of year
-
-	if (((times.tm_year = components[2]) == 0) && !year)
-		times.tm_year = today->tm_year + 1900;
-	else if (times.tm_year < 100)
-	{
-		if (times.tm_year < (today->tm_year - 50) % 100)
-			times.tm_year += 2000;
-		else
-			times.tm_year += 1900;
-	}
-
-	times.tm_year -= 1900;
-	times.tm_mon -= 1;
-	times.tm_hour = components[3];
-	times.tm_min = components[4];
-	times.tm_sec = components[5];
-
-	// convert day/month/year to Julian and validate result
-
-	isc_encode_date(&times, (ISC_QUAD*)date);
-	tm times2;
-	isc_decode_date((ISC_QUAD*)date, &times2);
-
-	if (times.tm_year != times2.tm_year ||
-		times.tm_mon != times2.tm_mon || times.tm_mday != times2.tm_mday)
-	{
-		date_error(string, length);
-	}
-
-	while (precision++ < 4)
-		components[6] *= 10;
-
-	date[1] += components[6];
-
-}
-
-
-static void string_to_time(const TEXT* string, USHORT length, SLONG date[2])
-{
-/**************************************
- *
- *	s t r i n g _ t o _ t i m e
- *
- **************************************
- *
- * Functional description
- *	Convert an arbitrary string to a time.
- *
- **************************************/
-	if (!length)
-	{
-		date[0] = date[1] = 0;
-		return;
-	}
-
-	const TEXT* p = string;
-	const TEXT* const end = p + length;
-
-	const time_t clock = time(0);
-	const tm* today = localtime(&clock);
-
-	int i;
-	USHORT components[7];
-	for (i = 0; i < 7; i++)
-		components[i] = 0;
-
-	// Parse components
-
-	TEXT temp[15];
-	USHORT n, precision;
-
-	for (i = 3; i < 7; i++)
-	{
-
-		// Skip leading blanks.  If we run out of characters, we're done with parse.
-
-		while (p < end && *p == ' ')
-			p++;
-		if (p == end)
-			break;
-
-		// Handle digit or character strings
-
-		TEXT c = UPPER(*p);
-		if (DIGIT(c))
-		{
-			precision = n = 0;
-			while (p < end && DIGIT(*p))
-			{
-				n = n * 10 + *p++ - '0';
-				precision++;
-			}
-		}
-		else if (LETTER(c))
-		{
-			TEXT* t = temp;
-			while (p < end && LETTER(c))
-			{
-				c = UPPER(*p);
-				if (!LETTER(c))
-					break;
-				*t++ = c;
-				p++;
-			}
-			*t = 0;
-			while (++p < end)
-			{
-				if (*p != ' ' && *p != '\t' && *p != 0)
-					date_error(string, length);
-			}
-
-			if (strcmp(temp, NOW) == 0)
-			{
-				now_to_date(today, date);
-				return;
-			}
-			date_error(string, length);
-		}
-		else
-		{
-			date_error(string, length);
-			return;
-		}
-		components[i] = n;
-		while (p < end && *p == ' ')
-			p++;
-
-		if (*p == '/' || *p == '-' || *p == ',' || *p == ':' || *p == '.')
-		{
-			p++;
-			continue;
-		}
-
-	}
-
-	tm times;
-	times.tm_hour = components[3];
-	times.tm_min = components[4];
-	times.tm_sec = components[5];
-
-	// convert day/month/year to Julian and validate result
-
-	isc_encode_date(&times, (ISC_QUAD*)date);
-
-	while (precision++ < 4)
-		components[6] *= 10;
-
-	date[1] += components[6];
-
-}
-
-
-static const TEXT* type_name( USHORT dtype)
-{
-/**************************************
- *
- *	t y p e _ n a m e
- *
- **************************************
- *
- * Functional description
- *	Return the name of a data type.
- *
- **************************************/
-	for (const dtypes_t* names = dtypes_table; names->description; names++)
-	{
-		if (names->type == dtype)
-			return names->description;
-	}
-	return NULL;
-}
diff --git a/src/qli/mov_proto.h b/src/qli/mov_proto.h
deleted file mode 100644
index 96a6c274c7..0000000000
--- a/src/qli/mov_proto.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		mov_proto.h
- *	DESCRIPTION:	Prototype header file for mov.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_MOV_PROTO_H
-#define QLI_MOV_PROTO_H
-
-int			MOVQ_compare(const dsc*, const dsc*);
-double		MOVQ_date_to_double(const dsc*);
-int			MOVQ_decompose (const TEXT*, USHORT, SLONG *);
-void		MOVQ_double_to_date (double, SLONG [2]);
-double		MOVQ_get_double(const dsc*);
-SLONG		MOVQ_get_long(const dsc*, SSHORT);
-int			MOVQ_get_string(const dsc*, const TEXT**, vary*, USHORT);
-void		MOVQ_move(const dsc*, dsc*);
-void		MOVQ_terminate (const SCHAR*, SCHAR*, USHORT, USHORT);
-
-#endif // QLI_MOV_PROTO_H
-
diff --git a/src/qli/nounix.cpp b/src/qli/nounix.cpp
deleted file mode 100644
index 8d066f14c9..0000000000
--- a/src/qli/nounix.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		nounix.cpp
- *	DESCRIPTION:	Dummy routines
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-
-int pipe()
-{
-	return -1;
-}
-
-int vfork()
-{
-	return -1;
-}
-
diff --git a/src/qli/parse.cpp b/src/qli/parse.cpp
deleted file mode 100644
index 6bdd2e95c9..0000000000
--- a/src/qli/parse.cpp
+++ /dev/null
@@ -1,5723 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		parse.cpp
- *	DESCRIPTION:	Statement parser
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "../qli/dtr.h"
-#include "../qli/exe.h"			// This is only included to suppress a compiler warning
-#include "../qli/parse.h"
-#include "../qli/compile.h"
-#include "../qli/report.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/hsh_proto.h"
-#include "../qli/lex_proto.h"
-#include "../qli/mov_proto.h"
-#include "../qli/parse_proto.h"
-#include "../qli/proc_proto.h"
-#include "../common/gdsassert.h"
-#include "../jrd/constants.h"
-
-using MsgFormat::SafeArg;
-
-
-#define KEYWORD(kw)		(QLI_token->tok_keyword == kw)
-#define INT_CAST		(qli_syntax*) (IPTR)
-
-static void check_end();
-static void command_end();
-static qli_dbb* get_dbb(qli_symbol*);
-static qli_syntax* make_list(qli_lls*);
-static qli_name* make_name();
-static qli_const* make_numeric_constant(const TEXT*, USHORT);
-static TEXT* make_string(const TEXT*, USHORT);
-static qli_syntax* negate(qli_syntax*);
-static kwwords next_keyword();
-static qli_syntax* parse_abort();
-static qli_syntax* parse_accept();
-static qli_syntax* parse_add(USHORT *, bool *);
-static qli_syntax* parse_and(USHORT *);
-static qli_syntax* parse_assignment();
-static qli_syntax* parse_boolean(USHORT *);
-static qli_syntax* parse_copy();
-static qli_dbb* parse_database();
-static qli_syntax* parse_declare();
-static qli_syntax* parse_define();
-static qli_syntax* parse_def_index();
-static qli_syntax* parse_def_relation();
-static qli_syntax* parse_delete();
-static qli_syntax* parse_drop();
-static int parse_dtype(USHORT *, USHORT *);
-static int parse_dtype_subtype();
-static qli_syntax* parse_edit();
-static TEXT* parse_edit_string();
-static qli_syntax* parse_erase();
-static qli_syntax* parse_extract();
-static qli_fld* parse_field(bool);
-static qli_syntax* parse_field_name(qli_syntax**);
-static qli_syntax* parse_for();
-static qli_syntax* parse_from(USHORT*, bool*);
-static qli_syntax* parse_function();
-static TEXT* parse_header();
-static qli_syntax* parse_help();
-static qli_syntax* parse_if();
-static qli_syntax* parse_in(qli_syntax*, nod_t, bool);
-static qli_syntax* parse_insert();
-static nod_t parse_join_type();
-static qli_syntax* parse_list_fields();
-static qli_const* parse_literal();
-static qli_syntax* parse_matches();
-static void parse_matching_paren();
-static qli_syntax* parse_modify();
-static qli_syntax* parse_modify_index();
-static qli_syntax* parse_modify_relation();
-static qli_syntax* parse_multiply(USHORT*, bool*);
-static qli_name* parse_name();
-static qli_syntax* parse_not(USHORT *);
-static int parse_ordinal();
-static qli_syntax* parse_output();
-static qli_syntax* parse_primitive_value(USHORT*, bool*);
-static qli_syntax* parse_print_list();
-static qli_syntax* parse_print();
-static qli_syntax* parse_prompt();
-static qli_filter* parse_qualified_filter();
-static qli_func* parse_qualified_function();
-static qli_proc* parse_qualified_procedure();
-static qli_rel* parse_qualified_relation();
-static qli_syntax* parse_ready(nod_t);
-static qli_syntax* parse_relational(USHORT*);
-static qli_syntax* parse_relation();
-static qli_syntax* parse_rename();
-static qli_syntax* parse_repeat();
-static qli_syntax* parse_report();
-static qli_syntax* parse_rse();
-static qli_syntax* parse_select();
-static qli_syntax* parse_set();
-static qli_syntax* parse_shell();
-static qli_syntax* parse_show();
-static qli_syntax* parse_sort();
-static qli_syntax* parse_sql_alter();
-static qli_syntax* parse_sql_create();
-static int parse_sql_dtype(USHORT* length, USHORT* scale, USHORT* precision, USHORT* sub_type);
-static qli_fld* parse_sql_field();
-static qli_syntax* parse_sql_grant_revoke(const nod_t type);
-static qli_syntax* parse_sql_index_create(const bool, const bool);
-static qli_syntax* parse_sql_joined_relation(); //(qli_syntax*);
-static qli_syntax* parse_sql_join_clause(qli_syntax*);
-static qli_syntax* parse_sql_table_create();
-#ifdef NOT_USED_OR_REPLACED
-static qli_syntax* parse_sql_view_create();
-#endif
-static qli_syntax* parse_sql_relation();
-static qli_syntax* parse_sql_rse();
-static qli_syntax* parse_sql_singleton_select();
-static qli_syntax* parse_sql_subquery();
-static qli_syntax* parse_statement();
-static qli_syntax* parse_statistical();
-static qli_syntax* parse_store();
-static TEXT* parse_string();
-static qli_symbol* parse_symbol();
-static void parse_terminating_parens(USHORT*, USHORT*);
-static qli_syntax* parse_transaction(nod_t);
-static qli_syntax* parse_udf_or_field();
-static qli_syntax* parse_update();
-static qli_syntax* parse_value(USHORT*, bool*);
-static bool potential_rse();
-static qli_rel* resolve_relation(const qli_symbol*, qli_symbol*);
-static qli_syntax* syntax_node(nod_t, USHORT);
-static bool test_end();
-
-struct gds_quad
-{
-	SLONG gds_quad_high;
-	ULONG gds_quad_low;
-};
-
-/*
-The following flags are:
-
-	sql_flag	indicates whether we are parsing in a SQL environment.
-			The flag is used to turn off automatic end-of-command
-			recognition.
-
-	else_count	indicates the depth of if/then/else's
-
-	sw_report 	indicates whether we're in a report statement
-
-	sw_statement	indicates that we're actively parsing a statement/command
-
-	sw_sql_view	indicates parsing a SQL VIEW, so restrict the select.
-*/
-
-static int sql_flag, else_count, sw_report;
-static bool sw_statement, sw_sql_view;
-static int function_count;	// indicates the depth of UDF calls
-
-struct nod_types
-{
-	kwwords nod_t_keyword;
-	nod_t nod_t_node;
-	nod_t nod_t_rpt_node;
-	nod_t nod_t_sql_node;
-};
-
-static const nod_types statisticals[] =
-{
-	{ KW_MAX, nod_max, nod_rpt_max, nod_agg_max },
-	{ KW_MIN, nod_min, nod_rpt_min, nod_agg_min },
-	{ KW_COUNT, nod_count, nod_rpt_count, nod_agg_count },
-	{ KW_AVERAGE, nod_average, nod_rpt_average, nod_agg_average },
-	{ KW_TOTAL, nod_total, nod_rpt_total, nod_agg_total },
-	{ KW_none, nod_any, nod_any, nod_any }
-};
-
-static const nod_t relationals[] =
-{
-	nod_eql, nod_neq, nod_leq, nod_lss, nod_gtr, nod_geq, nod_containing,
-	nod_like, nod_starts, nod_missing, nod_between, nod_sleuth,
-	nod_matches, nod_and, nod_or, nod_not, nod_any, nod_unique, nod_nothing
-};
-
-
-qli_syntax* PARQ_parse()
-{
-/**************************************
- *
- *	P A R Q _ p a r s e
- *
- **************************************
- *
- * Functional description
- *	Parse a single statement or command.
- *
- **************************************/
-	sql_flag = else_count = sw_report = 0;
-	sw_statement = true;
-
-	switch (next_keyword())
-	{
-	case KW_COMMIT:
-		return parse_transaction(nod_commit);
-
-	case KW_COPY:
-		return parse_copy();
-
-	case KW_EXIT:
-		return syntax_node(nod_exit, 0);
-
-	case KW_EXTRACT:
-		return parse_extract();
-
-	case KW_QUIT:
-		return syntax_node(nod_quit, 0);
-
-	case KW_DELETE:
-	case KW_DROP:
-		{
-			qli_syntax* node = parse_drop();
-			if (node)
-				return node;
-			node = parse_delete();
-			check_end();
-			if (!PAR_match(KW_THEN))
-				return node;
-			qli_lls* stack = NULL;
-			ALLQ_push((blk*) node, &stack);
-			ALLQ_push((blk*) parse_statement(), &stack);
-			return make_list(stack);
-		}
-
-	case KW_DEFINE:
-		return parse_define();
-
-	case KW_CREATE:
-		return parse_sql_create();
-
-	case KW_ALTER:
-		return parse_sql_alter();
-
-	case KW_EDIT:
-		return parse_edit();
-
-	case KW_FINISH:
-		return parse_transaction(nod_finish);
-
-	case KW_GRANT:
-		return parse_sql_grant_revoke(nod_sql_grant);
-
-	case KW_HELP:
-		return parse_help();
-
-	case KW_PREPARE:
-		return parse_transaction(nod_prepare);
-
-	case KW_READY:
-		return parse_ready(nod_ready);
-
-	case KW_RENAME:
-		return parse_rename();
-
-	case KW_REVOKE:
-		return parse_sql_grant_revoke(nod_sql_revoke);
-
-	case KW_ROLLBACK:
-		return parse_transaction(nod_rollback);
-
-	case KW_SET:
-		return parse_set();
-
-	case KW_SHELL:
-		return parse_shell();
-
-	case KW_SHOW:
-		return parse_show();
-	}
-
-	return parse_statement();
-}
-
-
-bool PAR_match( kwwords keyword)
-{
-/**************************************
- *
- *	P A R _ m a t c h
- *
- **************************************
- *
- * Functional description
- *	Test the current token for a particular keyword.
- *	If so, advance the token stream.
- *
- **************************************/
-	if (KEYWORD(keyword))
-	{
-		PAR_token();
-		return true;
-	}
-
-	for (const qli_symbol* symbol = QLI_token->tok_symbol; symbol; symbol = symbol->sym_homonym)
-	{
-		if (symbol->sym_type == SYM_keyword && symbol->sym_keyword == keyword)
-		{
-			PAR_token();
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-void PAR_real()
-{
-/**************************************
- *
- *	P A R _ r e a l
- *
- **************************************
- *
- * Functional description
- *	Get a real (not EOL) token.
- *
- *	If the token is an end of line, get the next token.
- *      If the next token is a colon, start reading the
- *      procedure.
- *
- **************************************/
-	while ((QLI_token->tok_type == tok_eol) || KEYWORD(KW_continuation))
-		LEX_token();
-
-	if (PAR_match(KW_COLON))
-	{
-		qli_dbb* database = parse_database();
-		PRO_invoke(database, QLI_token->tok_string);
-	}
-}
-
-
-void PAR_real_token()
-{
-/**************************************
- *
- *	P A R _ r e a l _ t o k e n
- *
- **************************************
- *
- * Functional description
- *	Composition of PAR_token followed by PAR_real.
- *
- **************************************/
-
-	PAR_token();
-	PAR_real();
-}
-
-
-void PAR_token()
-{
-/**************************************
- *
- *	P A R _ t o k e n
- *
- **************************************
- *
- * Functional description
- *	Get the next token.
- *	If it's a procedure invocation, handle it
- *      or complain and get rid of the evidence.
- *
- **************************************/
-	for (;;)
-	{
-		LEX_token();
-		if (!(KEYWORD(KW_continuation)) &&
-			!(sw_statement && QLI_semi && QLI_token->tok_type == tok_eol))
-		{
-			break;
-		}
-	}
-
-	if (PAR_match(KW_COLON))
-	{
-		if (!QLI_databases)
-		{
-			ERRQ_error_format(159);	// Msg159 no databases are ready
-			ERRQ_pending();
-			LEX_token();
-		}
-		else
-		{
-			qli_dbb* database = parse_database();
-			PRO_invoke(database, QLI_token->tok_string);
-		}
-	}
-}
-
-
-static void check_end()
-{
-/**************************************
- *
- *	c h e c k _ e n d
- *
- **************************************
- *
- * Functional description
- *	Check for end of statement.  If it isn't complain bitterly.
- *
- **************************************/
-
-	if (QLI_token->tok_type == tok_eol || KEYWORD(KW_SEMI) || KEYWORD(KW_THEN) ||
-		(else_count && KEYWORD(KW_ELSE)))
-	{
-		sw_statement = false;
-		return;
-	}
-
-	ERRQ_syntax(161);			// Msg161 end of statement
-}
-
-
-static void command_end()
-{
-/**************************************
- *
- *	c o m m a n d _ e n d
- *
- **************************************
- *
- * Functional description
- *	Check for end of command.  If it isn't complain bitterly.
- *
- **************************************/
-
-	if (QLI_token->tok_type == tok_eol || KEYWORD(KW_SEMI))
-	{
-		sw_statement = false;
-		return;
-	}
-
-	ERRQ_syntax(162);			// Msg162 end of command
-}
-
-
-static qli_dbb* get_dbb( qli_symbol* symbol)
-{
-/**************************************
- *
- *	g e t _ d b b
- *
- **************************************
- *
- * Functional description
- *	Find a database block from a symbol
- *	or its homonyms.
- *
- **************************************/
-
-	for (; symbol; symbol = symbol->sym_homonym)
-	{
-		if (symbol->sym_type == SYM_database)
-			return (qli_dbb*) symbol->sym_object;
-	}
-
-	return NULL;
-}
-
-
-static qli_syntax* make_list( qli_lls* stack)
-{
-/**************************************
- *
- *	m a k e _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Dump a stack of junk into a list node.  Best count
- *	them first.
- *
- **************************************/
-	qli_lls* temp = stack;
-	USHORT count = 0;
-
-	while (temp)
-	{
-		count++;
-		temp = temp->lls_next;
-	}
-
-	qli_syntax* node = syntax_node(nod_list, count);
-	qli_syntax** ptr = &node->syn_arg[count];
-
-	while (stack)
-		*--ptr = (qli_syntax*) ALLQ_pop(&stack);
-
-	return node;
-}
-
-
-static qli_name* make_name()
-{
-/**************************************
- *
- *	m a k e _ n a m e
- *
- **************************************
- *
- * Functional description
- *	Generate a unique name for something
- *	(like a database) that needs one.
- *
- **************************************/
-	SSHORT l;
-	TEXT string[32];
-
-	for (SSHORT i = 0; i < 1000; i++)
-	{
-		sprintf(string, "QLI_%d", i);
-		if (i < 10)
-			l = 5;
-		else
-			l = (i < 100) ? 6 : 7;
-		if (!(HSH_lookup(string, l)))
-			break;
-	}
-
-	qli_name* name = (qli_name*) ALLOCDV(type_nam, l);
-	name->nam_length = l;
-	TEXT* p = name->nam_string;
-	const TEXT* q = string;
-
-	if (l)
-		do {
-			const TEXT c = *q++;
-			*p++ = UPPER(c);
-		} while (--l);
-
-	return name;
-}
-
-
-static qli_const* make_numeric_constant(const TEXT* string, USHORT length)
-{
-/**************************************
- *
- *	m a k e _ n u m e r i c _ c o n s t a n t
- *
- **************************************
- *
- * Functional description
- *	Build a constant block for a numeric
- *	constant.  Numeric constants are normally
- *	stored as long words, but especially large
- *	ones become text.  They ought to become
- *      double precision, one would think, but they'd
- *      have to be VAX style double precision which is
- *      more pain than gain.
- *
- **************************************/
-	qli_const* constant;
-
-	// If there are a reasonable number of digits, convert to binary
-
-	if (length < 9)
-	{
-		constant = (qli_const*) ALLOCDV(type_con, sizeof(SLONG));
-		constant->con_desc.dsc_dtype = dtype_long;
-		constant->con_desc.dsc_length = sizeof(SLONG);
-		constant->con_desc.dsc_address = constant->con_data;
-		constant->con_desc.dsc_scale = MOVQ_decompose(string, length, (SLONG*) constant->con_data);
-	}
-	else
-	{
-		++length;
-		constant = (qli_const*) ALLOCDV(type_con, length);
-		constant->con_desc.dsc_dtype = dtype_text;
-		constant->con_desc.dsc_length = length;
-		constant->con_desc.dsc_address = constant->con_data;
-		TEXT* p = (TEXT*) constant->con_desc.dsc_address;
-		*p++ = '0';
-		memcpy(p, string, --length);
-	}
-	QLI_validate_desc(constant->con_desc);
-
-	return constant;
-}
-
-
-static TEXT* make_string(const TEXT* address, USHORT length)
-{
-/**************************************
- *
- *	m a k e _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Copy a string into a temporary string block.
- *
- **************************************/
-	qli_str* string = (qli_str*) ALLOCDV(type_str, length);
-	if (length)
-		memcpy(string->str_data, address, length);
-
-	return string->str_data;
-}
-
-
-static qli_syntax* negate( qli_syntax* expr)
-{
-/**************************************
- *
- *	n e g a t e
- *
- **************************************
- *
- * Functional description
- *	Build negation of expression.
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_not, 1);
-	node->syn_arg[0] = expr;
-
-	return node;
-}
-
-
-static kwwords next_keyword()
-{
-/**************************************
- *
- *	n e x t _ k e y w o r d
- *
- **************************************
- *
- * Functional description
- *	Get a real token and return the keyword number.
- *
- **************************************/
-	PAR_real();
-
-	for (const qli_symbol* symbol = QLI_token->tok_symbol; symbol; symbol = symbol->sym_homonym)
-	{
-		if (symbol->sym_type == SYM_keyword)
-			return (kwwords) symbol->sym_keyword;
-	}
-
-	return KW_none;
-}
-
-
-static qli_syntax* parse_abort()
-{
-/**************************************
- *
- *	p a r s e _ a b o r t
- *
- **************************************
- *
- * Functional description
- *	Parse an ABORT statement.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_abort, 1);
-
-	if (KEYWORD(KW_SEMI))
-		node->syn_count = 0;
-	else
-		node->syn_arg[0] = parse_value(0, 0);
-
-	return node;
-}
-
-
-static qli_syntax* parse_accept()
-{
-/**************************************
- *
- *	p a r s e _ a c c e p t
- *
- **************************************
- *
- * Functional description
- *	Parse form update statement.
- *
- **************************************/
-	IBERROR(484);				// FORMs not supported
-	return 0;
-}
-
-
-static qli_syntax* parse_add( USHORT* paren_count, bool* bool_flag)
-{
-/**************************************
- *
- *	p a r s e _ a d d
- *
- **************************************
- *
- * Functional description
- *	Parse the lowest precedence operatrs, ADD and SUBTRACT.
- *
- **************************************/
-	nod_t operatr;
-
-	qli_syntax* node = parse_multiply(paren_count, bool_flag);
-
-	while (true)
-	{
-		if (PAR_match(KW_PLUS))
-			operatr = nod_add;
-		else if (PAR_match(KW_MINUS))
-			operatr = nod_subtract;
-		else
-			return node;
-		qli_syntax* arg = node;
-		node = syntax_node(operatr, 2);
-		node->syn_arg[0] = arg;
-		node->syn_arg[1] = parse_multiply(paren_count, bool_flag);
-	}
-}
-
-
-static qli_syntax* parse_and( USHORT* paren_count)
-{
-/**************************************
- *
- *	p a r s e _ a n d
- *
- **************************************
- *
- * Functional description
- *	Parse an AND expression.
- *
- **************************************/
-	qli_syntax* expr = parse_not(paren_count);
-
-	/*
-	while (*paren_count && KEYWORD (KW_RIGHT_PAREN))
-	{
-		parse_matching_paren();
-		(*paren_count)--;
-	}
-	*/
-
-	if (!PAR_match(KW_AND))
-		return expr;
-
-	qli_syntax* node = syntax_node(nod_and, 2);
-	node->syn_arg[0] = expr;
-	node->syn_arg[1] = parse_and(paren_count);
-
-	return node;
-}
-
-
-static qli_syntax* parse_assignment()
-{
-/**************************************
- *
- *	p a r s e _ a s s i g n m e n t
- *
- **************************************
- *
- * Functional description
- *	Parse an assignment statement (or give an error).  The
- *	assignment statement can be either a simple assignment
- *	(field = value) or a restructure (relation = rse).
- *	If the assignment operator is missing,
- *	generate an "expected statement" error.
- *
- **************************************/
-	qli_syntax* field = NULL;
-
-	qli_syntax* node = syntax_node(nod_assign, s_asn_count);
-	node->syn_arg[s_asn_to] = parse_field_name(&field);
-	qli_name* name = (qli_name*) field->syn_arg[0];
-
-	// If the next token is an equals sign, the statement really is an
-	// assignment, and we're off the hook.
-
-	if (!PAR_match(KW_EQUALS))
-		ERRQ_print_error(156, name->nam_string);	// Msg156 expected statement, encountered %s
-
-	// See if the "field name" is really a relation reference.  If so,
-	// turn the assignment into a restructure.
-
-	qli_rel* relation = NULL;
-	if (field->syn_count == 1)
-		relation = resolve_relation(0, name->nam_symbol);
-	else if (field->syn_count == 2 && name->nam_symbol)
-	{
-		qli_name* name2 = (qli_name*) field->syn_arg[1];
-		relation = resolve_relation(name->nam_symbol, name2->nam_symbol);
-	}
-
-	if (relation)
-	{
-		ALLQ_release((qli_frb*) field);
-		node->syn_type = nod_restructure;
-		node->syn_arg[s_asn_to] = field = syntax_node(nod_relation, s_rel_count);
-		field->syn_arg[s_rel_relation] = (qli_syntax*) relation;
-		node->syn_arg[s_asn_from] = parse_rse();
-	}
-	else
-		node->syn_arg[s_asn_from] = parse_value(0, 0);
-
-	return node;
-}
-
-
-static qli_syntax* parse_boolean( USHORT * paren_count)
-{
-/**************************************
- *
- *	p a r s e _ b o o l e a n
- *
- **************************************
- *
- * Functional description
- *	Parse a general boolean expression.  By precedence, handle an OR
- *	here.
- *
- **************************************/
-	USHORT local_count;
-
-	if (!paren_count)
-	{
-		local_count = 0;
-		paren_count = &local_count;
-	}
-
-	qli_syntax* expr = parse_and(paren_count);
-
-	/*
-	while (*paren_count && KEYWORD (KW_RIGHT_PAREN))
-	{
-		parse_matching_paren();
-		(*paren_count)--;
-	}
-	*/
-
-	if (!PAR_match(KW_OR))
-	{
-		parse_terminating_parens(paren_count, &local_count);
-		return expr;
-	}
-
-	qli_syntax* node = syntax_node(nod_or, 2);
-	node->syn_arg[0] = expr;
-	node->syn_arg[1] = parse_boolean(paren_count);
-	parse_terminating_parens(paren_count, &local_count);
-
-	return node;
-}
-
-
-static qli_syntax* parse_copy()
-{
-/**************************************
- *
- *	p a r s e _ c o p y
- *
- **************************************
- *
- * Functional description
- *	Parse a copy command, which copies
- *	one procedure to another.
- *
- **************************************/
-	PAR_real_token();
-
-	if (PAR_match(KW_PROCEDURE))
-	{
-		qli_syntax* node = syntax_node(nod_copy_proc, 2);
-		node->syn_arg[0] = (qli_syntax*) parse_qualified_procedure();
-		PAR_match(KW_TO);
-		node->syn_arg[1] = (qli_syntax*) parse_qualified_procedure();
-		return node;
-	}
-
-	ERRQ_print_error(157, QLI_token->tok_string);	// Msg157 Expected PROCEDURE encountered %s
-	return NULL;
-}
-
-
-static qli_dbb* parse_database()
-{
-/**************************************
- *
- *	p a r s e _ d a t a b a s e
- *
- **************************************
- *
- * Functional description
- *	Pick up a database for a meta-data or
- *	procedure update.  Return NULL if the
- *	token is not a database name.
- *
- **************************************/
-	qli_symbol* db_symbol = QLI_token->tok_symbol;
-
-	if (db_symbol && db_symbol->sym_type == SYM_database)
-	{
-		qli_dbb* database = (qli_dbb*) db_symbol->sym_object;
-		PAR_real_token();
-		if (!PAR_match(KW_DOT))
-			ERRQ_syntax(158);	// Msg158 period in qualified name
-		PAR_real();
-		return database;
-	}
-
-	if (!QLI_databases)
-		IBERROR(159);			// Msg159 no databases are ready
-
-	return NULL;
-}
-
-
-static qli_syntax* parse_declare()
-{
-/**************************************
- *
- *	p a r s e _ d e c l a r e
- *
- **************************************
- *
- * Functional description
- *	Parse a variable  declaration.
- *
- **************************************/
-	PAR_token();
-	PAR_real();
-
-	USHORT dtype = 0, length = 0, scale = 0;
-	SSHORT sub_type = 0;
-	SSHORT sub_type_missing = 1;
-	qli_syntax* field_node = NULL;
-	qli_symbol* query_name = NULL;
-	const TEXT* edit_string = NULL;
-	const TEXT* query_header = NULL;
-
-	qli_symbol* name = parse_symbol();
-
-	// if (global_flag)
-	//	PAR_real();
-
-	while (!KEYWORD(KW_SEMI) && !KEYWORD(KW_COMMA))
-	{
-		PAR_real();
-		switch (QLI_token->tok_keyword)
-		{
-		case KW_SHORT:
-		case KW_LONG:
-		case KW_FLOAT:
-		case KW_DOUBLE:
-		case KW_DATE:
-		case KW_CHAR:
-		case KW_VARYING:
-			if (dtype)
-				ERRQ_syntax(164);	// Msg164 variable definition clause
-			dtype = parse_dtype(&length, &scale);
-			break;
-
-		case KW_BLOB:
-			IBERROR(160);		// Msg160 blob variables are not supported
-			break;
-
-		case KW_SUB_TYPE:
-			sub_type = parse_dtype_subtype();
-			sub_type_missing = 0;
-			break;
-
-		case KW_EDIT_STRING:
-			PAR_token();
-			if (QLI_token->tok_type != tok_quoted)
-				ERRQ_syntax(163);	// Msg163 quoted edit string
-			edit_string = make_string(QLI_token->tok_string + 1, QLI_token->tok_length - 2);
-			PAR_token();
-			break;
-
-		case KW_QUERY_NAME:
-			PAR_token();
-			PAR_match(KW_IS);
-			if (QLI_token->tok_type != tok_ident)
-				ERRQ_syntax(199);	// Msg199 identifier
-			query_name = parse_symbol();
-			break;
-
-		case KW_QUERY_HEADER:
-			PAR_token();
-			query_header = parse_header();
-			break;
-
-		case KW_BASED:
-			PAR_token();
-			PAR_match(KW_ON);
-			field_node = parse_field_name(0);
-			break;
-
-		default:
-			ERRQ_syntax(164);	// Msg164 variable definition clause
-			break;
-		}
-	}
-
-	qli_rel* relation = NULL;
-	if (field_node && field_node->syn_count == 3)
-	{
-		qli_name* db_name = (qli_name*) field_node->syn_arg[0];
-		qli_name* rel_name = (qli_name*) field_node->syn_arg[1];
-		if (!db_name->nam_symbol)
-			ERRQ_print_error(165, db_name->nam_string);
-			// Msg165 %s is not a database
-
-		relation = resolve_relation(db_name->nam_symbol, rel_name->nam_symbol);
-		if (!relation)
-		{
-			ERRQ_print_error(166, SafeArg() << rel_name->nam_string << db_name->nam_string);
-			// Msg166 %s is not a relation in database %s
-		}
-	}
-
-	if (!dtype && !field_node)
-		ERRQ_syntax(167);		// Msg167 variable data type
-	if (field_node && (dtype || length || scale))
-		IBERROR(168);			// Msg168 no datatype may be specified for a variable based on a field
-
-	qli_syntax* node = syntax_node(nod_declare, 2);
-	// Not global to this unit, misleading name "global..."
-	qli_fld* global_variable = (qli_fld*) ALLOCDV(type_fld, length);
-	node->syn_arg[0] = (qli_syntax*) global_variable;
-	global_variable->fld_name = name;
-	global_variable->fld_dtype = dtype;
-	global_variable->fld_scale = scale;
-	global_variable->fld_sub_type = sub_type;
-	global_variable->fld_sub_type_missing = sub_type_missing;
-	global_variable->fld_length = length;
-	global_variable->fld_edit_string = edit_string;
-	global_variable->fld_query_name = query_name;
-	global_variable->fld_query_header = query_header;
-	global_variable->fld_relation = relation;
-
-	node->syn_arg[1] = field_node;
-
-	check_end();
-
-	return node;
-}
-
-
-static qli_syntax* parse_define()
-{
-/**************************************
- *
- *	p a r s e _ d e f i n e
- *
- **************************************
- *
- * Functional description
- *	Parse a DEFINE command.
- *	There are, of course, a whole class of define commands.
- *
- **************************************/
-	PAR_real_token();
-
-	if (PAR_match(KW_PROCEDURE))
-	{
-		PAR_real();
-		qli_syntax* anode = syntax_node(nod_define, 1);
-		anode->syn_arg[0] = (qli_syntax*) parse_qualified_procedure();
-		return anode;
-	}
-
-	if (PAR_match(KW_FIELD))
-	{
-		PAR_real();
-		qli_syntax* node = syntax_node(nod_def_field, 2);
-		node->syn_arg[0] = (qli_syntax*) parse_database();
-		node->syn_arg[1] = (qli_syntax*) parse_field(true);
-		return node;
-	}
-
-	if (PAR_match(KW_RELATION))
-		return parse_def_relation();
-
-	if (KEYWORD(KW_DATABASE))
-		return parse_ready(nod_def_database);
-
-	if (PAR_match(KW_INDEX))
-		return parse_def_index();
-
-	ERRQ_syntax(169);			// Msg169 object type for DEFINE
-	return NULL;
-}
-
-
-static qli_syntax* parse_def_index()
-{
-/**************************************
- *
- *	p a r s e _ d e f _ i n d e x
- *
- **************************************
- *
- * Functional description
- *	Parse a DEFINE INDEX command.
- *
- **************************************/
-	PAR_real();
-	qli_syntax* node = syntax_node(nod_def_index, s_dfi_count);
-	node->syn_arg[s_dfi_name] = (qli_syntax*) parse_symbol();
-	PAR_real();
-	PAR_match(KW_FOR);
-
-	if (!(node->syn_arg[s_dfi_relation] = (qli_syntax*) parse_qualified_relation()))
-		ERRQ_syntax(170);		// Msg170 relation name
-
-	PAR_real();
-
-	while (true)
-	{
-		PAR_real();
-		if (PAR_match(KW_UNIQUE))
-			node->syn_flags |= s_dfi_flag_unique;
-		else if (PAR_match(KW_DUPLICATE))
-			node->syn_flags &= ~s_dfi_flag_unique;
-		else if (PAR_match(KW_ACTIVE))
-			node->syn_flags &= ~s_dfi_flag_inactive;
-		else if (PAR_match(KW_INACTIVE))
-			node->syn_flags |= s_dfi_flag_inactive;
-		else if (PAR_match(KW_DESCENDING))
-			node->syn_flags |= s_dfi_flag_descending;
-		else if (PAR_match(KW_ASCENDING))
-			node->syn_flags &= ~s_dfi_flag_descending;
-		else
-			break;
-	}
-
-	qli_lls* stack = NULL;
-	for (;;)
-	{
-		ALLQ_push((blk*) parse_name(), &stack);
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-	node->syn_arg[s_dfi_fields] = make_list(stack);
-
-	command_end();
-	return node;
-}
-
-
-static qli_syntax* parse_def_relation()
-{
-/**************************************
- *
- *	p a r s e _ d e f _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse a DEFINE RELATION command,
- *	which include the field definitions
- *	for a primitive relation definition
- *	or it may just reference another relation
- *	whose field definitions we will copy.
- *
- **************************************/
-	PAR_real();
-	qli_syntax* node = syntax_node(nod_def_relation, 2);
-	qli_rel* relation = (qli_rel*) ALLOCD(type_rel);
-	node->syn_arg[0] = (qli_syntax*) relation;
-	relation->rel_database = parse_database();
-	relation->rel_symbol = parse_symbol();
-	PAR_real();
-
-	if (PAR_match(KW_BASED))
-	{
-		PAR_real();
-		PAR_match(KW_ON);
-		PAR_real();
-		PAR_match(KW_RELATION);
-		PAR_real();
-		relation = (qli_rel*) ALLOCD(type_rel);
-		node->syn_arg[1] = (qli_syntax*) relation;
-		relation->rel_database = parse_database();
-		relation->rel_symbol = parse_symbol();
-	}
-	else
-	{
-		node->syn_arg[1] = NULL;
-		qli_fld** ptr = &relation->rel_fields;
-		for (;;)
-		{
-			PAR_match(KW_ADD);
-			PAR_real();
-			PAR_match(KW_FIELD);
-			qli_fld* field = parse_field(false);
-			*ptr = field;
-			ptr = &field->fld_next;
-			if (KEYWORD(KW_SEMI))
-				break;
-			if (!PAR_match(KW_COMMA))
-				ERRQ_syntax(171);	// Msg171 comma between field definitions
-		}
-	}
-
-	command_end();
-	return node;
-}
-
-
-static qli_syntax* parse_delete()
-{
-/**************************************
- *
- *	p a r s e _ d e l e t e
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL DELETE statement.
- *	(DELETE PROCEDURE is parsed in parse_drop)
- *
- **************************************/
-	++sql_flag;
-
-	if (!PAR_match(KW_FROM))
-		ERRQ_syntax(172);		// Msg172 FROM
-
-	qli_syntax* node = syntax_node(nod_erase, s_era_count);
-	qli_syntax* rse = syntax_node(nod_rse, (int) s_rse_count + 2);
-	node->syn_arg[s_era_rse] = rse;
-
-	rse->syn_count = 1;
-	rse->syn_arg[s_rse_count] = parse_sql_relation();
-
-	// Pick up boolean, if present
-
-	if (PAR_match(KW_WITH))
-		rse->syn_arg[s_rse_boolean] = parse_boolean(0);
-
-	--sql_flag;
-
-	return node;
-}
-
-
-static qli_syntax* parse_drop()
-{
-/**************************************
- *
- *	p a r s e _ d r o p
- *
- **************************************
- *
- * Functional description
- *	Parse a DDL DROP/DELETE command.  It it isn't one,
- *	just return NULL.
- *
- **************************************/
-	qli_syntax* node;
-	nod_t type;
-	qli_dbb* database;
-	SSHORT l;
-	const TEXT* q;
-
-	PAR_real_token();
-
-	if (PAR_match(KW_RELATION) || PAR_match(KW_VIEW) || PAR_match(KW_TABLE))
-	{
-		node = syntax_node(nod_del_relation, 1);
-		if (!(node->syn_arg[0] = (qli_syntax*) parse_qualified_relation()))
-			ERRQ_syntax(173);	// Msg173 relation or view name
-		return node;
-	}
-
-	switch (QLI_token->tok_keyword)
-	{
-	case KW_PROCEDURE:
-		type = nod_delete_proc;
-		break;
-
-	case KW_INDEX:
-		type = nod_del_index;
-		break;
-
-	case KW_FIELD:
-		type = nod_del_field;
-		break;
-
-	case KW_DATABASE:
-		LEX_filename();
-		if (!(l = QLI_token->tok_length))
-			ERRQ_error(429);	// Msg429 database file name required on DROP DATABASE
-		q = QLI_token->tok_string;
-		if (QLI_token->tok_type == tok_quoted)
-		{
-			l -= 2;
-			q++;
-		}
-		database = (qli_dbb*) ALLOCDV(type_dbb, l);
-		database->dbb_filename_length = l;
-		memcpy(database->dbb_filename, q, l);
-		PAR_token();
-
-		// parse an optional user name and password if given
-
-		for (;;)
-		{
-			if (PAR_match(KW_USER))
-				database->dbb_user = parse_literal();
-			else if (PAR_match(KW_PASSWORD))
-				database->dbb_password = parse_literal();
-			else
-				break;
-		}
-
-		command_end();
-		node = syntax_node(nod_del_database, 1);
-		node->syn_arg[0] = (qli_syntax*) database;
-		return node;
-
-	default:
-		return NULL;
-	}
-
-	PAR_real_token();
-	node = syntax_node(type, 2);
-
-	if (type == nod_delete_proc)
-		node->syn_arg[0] = (qli_syntax*) parse_qualified_procedure();
-	else
-	{
-		node->syn_arg[0] = (qli_syntax*) parse_database();
-		node->syn_arg[1] = (qli_syntax*) parse_name();
-	}
-
-	return node;
-}
-
-
-static int parse_dtype( USHORT * length, USHORT * scale)
-{
-/**************************************
- *
- *	p a r s e _ d t y p e
- *
- **************************************
- *
- * Functional description
- *	Parse a datatype clause.
- *
- **************************************/
-	USHORT dtype;
-
-	const kwwords keyword = QLI_token->tok_keyword;
-	PAR_token();
-	*scale = 0;
-
-	switch (keyword)
-	{
-	case KW_SHORT:
-		*length = sizeof(SSHORT);
-		dtype = dtype_short;
-		break;
-
-   	case KW_BIGINT:
-		*length = sizeof(SINT64);
-		dtype = dtype_int64;
-		break;
-
-	case KW_LONG:
-		*length = sizeof(SLONG);
-		dtype = dtype_long;
-		break;
-
-	case KW_FLOAT:
-		*length = sizeof(float);
-		return dtype_real;
-
-	case KW_DOUBLE:
-		*length = sizeof(double);
-		return dtype_double;
-
-	case KW_DATE:
-		*length = sizeof(gds_quad);
-		return dtype_timestamp;
-
-	case KW_CHAR:
-		dtype = dtype_text;
-		break;
-
-	case KW_VARYING:
-		dtype = dtype_varying;
-		break;
-
-	case KW_BLOB:
-		*length = sizeof(gds_quad);
-		return dtype_blob;
-	}
-
-	switch (dtype)
-	{
-	case dtype_short:
-	case dtype_long:
-	case dtype_int64:
-		if (PAR_match(KW_SCALE))
-		{
-			const bool m = PAR_match(KW_MINUS) ? true : false;
-			*scale = parse_ordinal();
-			if (m)
-				*scale = -(*scale);
-		}
-		break;
-	case dtype_text:
-	case dtype_varying:
-		{
-			if (!PAR_match(KW_L_BRCKET) && !PAR_match(KW_LT))
-				ERRQ_syntax(174);	// Msg174 "["
-
-			USHORT l = parse_ordinal();
-			if (dtype == dtype_varying)
-				l += sizeof(SSHORT);
-			*length = l;
-
-			if (!PAR_match(KW_R_BRCKET) && !PAR_match(KW_GT))
-				ERRQ_syntax(175);	// Msg175 "]"
-		}
-	}
-
-	return dtype;
-}
-
-
-static int parse_dtype_subtype()
-{
-/**************************************
- *
- *	p a r s e _ d t y p e _ s u b t y p e
- *
- **************************************
- *
- * Functional description
- *	Parse a sub-type definition, which can be any of
- *	SUB_TYPE {IS} [TEXT | FIXED | <n>]
- *
- *	Returns the numeric subtype value,
- *
- **************************************/
-	// grab KW_SUB_TYPE
-
-	PAR_token();
-	PAR_match(KW_IS);
-	if (PAR_match(KW_TEXT) || PAR_match(KW_FIXED))
-		return 1;
-
-	const int sign = PAR_match(KW_MINUS) ? -1 : 1;
-
-	return (sign * parse_ordinal());
-}
-
-
-static qli_syntax* parse_edit()
-{
-/**************************************
- *
- *	p a r s e _ e d i t
- *
- **************************************
- *
- * Functional description
- *	Parse an edit statement which can
- *	be any of  EDIT <procedure_name>
- *	           EDIT <n>
- *		   EDIT <*>
- *		   EDIT
- *
- *
- **************************************/
-	LEX_token();
-
-	// edit previous statements.  The top of the statment list
-	// is this edit command, which we conveniently ignore.
-
-	if (KEYWORD(KW_SEMI) || (QLI_token->tok_type == tok_number) || (KEYWORD(KW_ASTERISK)))
-	{
-	    qli_lls* statement_list = LEX_statement_list();
-		if (!statement_list)
-			IBERROR(176);		// Msg176 No statements issued yet
-
-		if (PAR_match(KW_ASTERISK))
-			LEX_edit(0, (IPTR) statement_list->lls_object);
-		else
-		{
-		    int l = 0; // initialize, will catch changes in logic here.
-			if (KEYWORD(KW_SEMI))
-				l = 1;
-			else if (QLI_token->tok_type == tok_number) // redundant for now
-				l = parse_ordinal();
-
-			qli_lls* start = statement_list;
-			qli_lls* stop = start;
-			while (l && start->lls_next)
-			{
-				--l;
-				start = start->lls_next;
-			}
-			command_end();
-			LEX_edit((IPTR) start->lls_object, (IPTR) stop->lls_object);
-		}
-	}
-	else
-	{
-		const nod_t type = nod_edit_proc;
-		qli_syntax* node = syntax_node(type, 2);
-		node->syn_arg[0] = (qli_syntax*) parse_qualified_procedure();
-		command_end();
-		return node;
-	}
-
-	return NULL;
-}
-
-
-static TEXT* parse_edit_string()
-{
-/**************************************
- *
- *	p a r s e _ e d i t _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Look for and parse a clause of the form:
- *	    USING <edit_string>
- *
- **************************************/
-
-	if (!KEYWORD(KW_USING))
-		return NULL;
-
-	LEX_edit_string();
-
-	return parse_string();
-}
-
-
-static qli_syntax* parse_erase()
-{
-/**************************************
- *
- *	p a r s e _ e r a s e
- *
- **************************************
- *
- * Functional description
- *	Parse an ERASE statement.  Erase can be any of the
- *	following:
- *
- *	ERASE [ALL] [OF <rse>]
- *
- **************************************/
-	PAR_token();
-	PAR_match(KW_ALL);
-	PAR_match(KW_OF);
-	qli_syntax* node = syntax_node(nod_erase, s_era_count);
-
-	if (PAR_match(KW_ALL) || potential_rse())
-	{
-		PAR_match(KW_OF);
-		node->syn_arg[s_era_rse] = parse_rse();
-	}
-
-	return node;
-}
-
-
-static qli_syntax* parse_extract()
-{
-/**************************************
- *
- *	p a r s e _ e x t r a c t
- *
- **************************************
- *
- * Functional description
- *	Parse a procedure extract statement.  Syntax is:
- *
- *	EXTRACT [ON <file>] proc [, ...] [ON <file> ]
- *
- **************************************/
-	PAR_real_token();
-	qli_syntax* node = syntax_node(nod_extract, 2);
-	node->syn_arg[1] = parse_output();
-
-	if (!PAR_match(KW_ALL))
-	{
-		qli_lls* stack = NULL;
-		for (;;)
-		{
-			ALLQ_push((blk*) parse_qualified_procedure(), &stack);
-			if (!PAR_match(KW_COMMA))
-				break;
-		}
-		node->syn_arg[0] = make_list(stack);
-	}
-
-	if (!node->syn_arg[1] && !(node->syn_arg[1] = parse_output()))
-		ERRQ_syntax(177);		// Msg177 "ON or TO"
-
-	return node;
-}
-
-
-static qli_fld* parse_field( bool global_flag)
-{
-/**************************************
- *
- *	p a r s e _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Parse a field description.
- *
- **************************************/
-	PAR_real();
-
-	USHORT dtype = 0, length = 0, scale = 0;
-	SSHORT sub_type = 0;
-	SSHORT sub_type_missing = 1;
-	qli_symbol* query_name = NULL;
-	qli_symbol* based_on = NULL;
-	const TEXT* edit_string = NULL;
-	const TEXT* query_header = NULL;
-	qli_symbol* name = parse_symbol();
-
-	if (global_flag)
-		PAR_real();
-
-	while (!KEYWORD(KW_SEMI) && !KEYWORD(KW_COMMA))
-	{
-		PAR_real();
-		switch (QLI_token->tok_keyword)
-		{
-		case KW_SHORT:
-		case KW_LONG:
-		case KW_FLOAT:
-		case KW_DOUBLE:
-		case KW_DATE:
-		case KW_CHAR:
-		case KW_VARYING:
-		case KW_BLOB:
-			if (dtype)
-				ERRQ_syntax(179);	// Msg179 field definition clause
-			dtype = parse_dtype(&length, &scale);
-			break;
-
-		case KW_SUB_TYPE:
-			sub_type = parse_dtype_subtype();
-			sub_type_missing = 0;
-			break;
-
-		case KW_EDIT_STRING:
-			PAR_token();
-			if (QLI_token->tok_type != tok_quoted)
-				ERRQ_syntax(178);	// Msg178 quoted edit string
-			edit_string = make_string(QLI_token->tok_string + 1, QLI_token->tok_length - 2);
-			PAR_token();
-			break;
-
-		case KW_QUERY_NAME:
-			PAR_token();
-			PAR_match(KW_IS);
-			if (QLI_token->tok_type != tok_ident)
-				ERRQ_syntax(199);	// Msg199 identifier
-			query_name = parse_symbol();
-			break;
-
-		case KW_BASED:
-			PAR_token();
-			PAR_match(KW_ON);
-			based_on = parse_symbol();
-			break;
-
-		default:
-			ERRQ_syntax(179);	// Msg179 field definition clause
-			break;
-		}
-	}
-
-	qli_fld* field = (qli_fld*) ALLOCDV(type_fld, length);
-	field->fld_name = name;
-	field->fld_dtype = dtype;
-	field->fld_scale = scale;
-	field->fld_sub_type = sub_type;
-	field->fld_sub_type_missing = sub_type_missing;
-	field->fld_length = length;
-	field->fld_edit_string = edit_string;
-	field->fld_query_name = query_name;
-	field->fld_query_header = query_header;
-	if (!global_flag)
-		field->fld_based = based_on;
-	else if (based_on)
-		IBERROR(180);			// Msg180 global fields may not be based on other fields
-
-	return field;
-}
-
-
-static qli_syntax* parse_field_name( qli_syntax** fld_ptr)
-{
-/**************************************
- *
- *	p a r s e _ f i e l d _ n a m e
- *
- **************************************
- *
- * Functional description
- *	Parse a qualified field name, or
- *	qualified * expression.
- *
- **************************************/
-	qli_lls* stack = NULL;
-
-	while (true)
-	{
-		if (PAR_match(KW_ASTERISK))
-		{
-			if (!stack)
-				ERRQ_syntax(181);	// Msg181 field name or asterisk expression
-			qli_syntax* afield = make_list(stack);
-			afield->syn_type = nod_star;
-			return afield;
-		}
-		ALLQ_push((blk*) parse_name(), &stack);
-		if (!PAR_match(KW_DOT))
-			break;
-	}
-
-	qli_syntax* field = make_list(stack);
-	field->syn_type = nod_field;
-	if (fld_ptr)
-		*fld_ptr = field;
-	if (!(PAR_match(KW_L_BRCKET)))
-		return field;
-
-	// Parse an array reference
-
-	stack = NULL;
-	for (;;)
-	{
-		ALLQ_push((blk*) parse_value(0, 0), &stack);
-		if (PAR_match(KW_R_BRCKET))
-			break;
-		if (!PAR_match(KW_COMMA))
-			ERRQ_syntax(183);	// Msg183 comma
-	}
-
-	qli_syntax* node = syntax_node(nod_index, s_idx_count);
-	node->syn_arg[s_idx_field] = field;
-	node->syn_arg[s_idx_subs] = make_list(stack);
-
-	return node;
-}
-
-
-static qli_syntax* parse_for()
-{
-/**************************************
- *
- *	p a r s e _ f o r
- *
- **************************************
- *
- * Functional description
- *	Parse a FOR statement.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_for, s_for_count);
-	node->syn_arg[s_for_rse] = parse_rse();
-	node->syn_arg[s_for_statement] = parse_statement();
-
-	return node;
-}
-
-
-static qli_syntax* parse_from( USHORT* paren_count, bool* bool_flag)
-{
-/**************************************
- *
- *	p a r s e _ f r o m
- *
- **************************************
- *
- * Functional description
- *	Parse either an explicit or implicit FIRST ... FROM statement.
- *
- **************************************/
-	qli_syntax* value;
-
-	PAR_real();
-
-	if (PAR_match(KW_FIRST))
-	{
-		value = parse_primitive_value(0, 0);
-		PAR_real();
-		if (!PAR_match(KW_FROM))
-			ERRQ_syntax(182);	// Msg182 FROM rse clause
-	}
-	else
-	{
-		value = parse_primitive_value(paren_count, bool_flag);
-		if (sql_flag || !PAR_match(KW_FROM))
-			return value;
-	}
-
-	qli_syntax* node = syntax_node(nod_from, s_stt_count);
-	node->syn_arg[s_stt_value] = value;
-	node->syn_arg[s_stt_rse] = parse_rse();
-
-	if (PAR_match(KW_ELSE))
-		node->syn_arg[s_stt_default] = parse_value(0, 0);
-
-	return node;
-}
-
-
-static qli_syntax* parse_function()
-{
-/**************************************
- *
- *	p a r s e _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse a function reference.
- *
- **************************************/
-	function_count++;
-	qli_syntax* node = syntax_node(nod_function, s_fun_count);
-	node->syn_arg[s_fun_function] = (qli_syntax*) QLI_token->tok_symbol;
-	node->syn_count = 1;
-	PAR_token();
-	qli_lls* stack = NULL;
-
-	if (PAR_match(KW_LEFT_PAREN))
-	{
-		for (;;)
-		{
-			ALLQ_push((blk*) parse_value(0, 0), &stack);
-			if (PAR_match(KW_RIGHT_PAREN))
-				break;
-			if (!PAR_match(KW_COMMA))
-				ERRQ_syntax(183);	// Msg183 comma
-		}
-	}
-
-	node->syn_arg[s_fun_args] = make_list(stack);
-	function_count--;
-
-	return node;
-}
-
-
-static TEXT* parse_header()
-{
-/**************************************
- *
- *	p a r s e _ h e a d e r
- *
- **************************************
- *
- * Functional description
- *	Parse and store headers of the form:
- *		"quoted_string" [/ "more_string"]...
- *		or even the non-header -
- *
- **************************************/
-	TEXT header[1024];
-
-	TEXT* p = header;
-	const TEXT* end = p + sizeof(header);
-
-	while (true)
-	{
-		PAR_real();
-		if ((QLI_token->tok_keyword != KW_MINUS) && (QLI_token->tok_type != tok_quoted))
-		{
-			ERRQ_syntax(184);	// Msg184 quoted header segment
-		}
-		const TEXT* q = QLI_token->tok_string;
-		while (*q && p < end)
-			*p++ = *q++;
-
-		if (p == end && *q)
-		    ERRQ_syntax(184); // Msg184 quoted header segment
-
-		PAR_real_token();
-		if (!PAR_match(KW_SLASH))
-			break;
-	}
-
-	return make_string(header, p - header);
-}
-
-
-static qli_syntax* parse_help()
-{
-/**************************************
- *
- *	p a r s e _ h e l p
- *
- **************************************
- *
- * Functional description
- *	Parse HELP statement.  Unreasonable, but the masses
- *	must be appeased.  Bread, circuses, help.
- *
- **************************************/
-	qli_lls* stack = NULL;
-	PAR_token();
-
-	while (!KEYWORD(KW_SEMI))
-	{
-		ALLQ_push((blk*) parse_name(), &stack);
-		PAR_match(KW_COMMA);
-	}
-
-	qli_syntax* node = make_list(stack);
-	node->syn_type = nod_help;
-	command_end();
-
-	return node;
-}
-
-
-static qli_syntax* parse_if()
-{
-/**************************************
- *
- *	p a r s e _ i f
- *
- **************************************
- *
- * Functional description
- *	Parse an IF THEN ELSE statement.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_if, s_if_count);
-	node->syn_arg[s_if_boolean] = parse_boolean(0);
-	PAR_real();
-	PAR_match(KW_THEN);
-	++else_count;
-	node->syn_arg[s_if_true] = parse_statement();
-	--else_count;
-
-	if (PAR_match(KW_ELSE))
-		node->syn_arg[s_if_false] = parse_statement();
-
-	return node;
-}
-
-
-static qli_syntax* parse_in( qli_syntax* value, nod_t operatr, bool all_flag)
-{
-/**************************************
- *
- *	p a r s e _ i n
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL "IN" clause.  This can have two forms:
- *
- *		value IN (exp1, exp2...)
- *
- *		value IN (column <select expression>)
- *
- **************************************/
-	PAR_real();
-
-	if (!PAR_match(KW_LEFT_PAREN))
-		ERRQ_syntax(185);		// Msg185 left parenthesis
-
-	// Time to chose between two forms of the expression
-
-	if (!PAR_match(KW_SELECT))
-	{
-		qli_syntax* node1 = syntax_node(operatr, 2);
-		node1->syn_arg[0] = value;
-		node1->syn_arg[1] = parse_primitive_value(0, 0);
-		while (PAR_match(KW_COMMA))
-		{
-			qli_syntax* node2 = node1;
-			node1 = syntax_node(nod_or, 2);
-			node1->syn_arg[0] = node2;
-			node1->syn_arg[1] = node2 = syntax_node(nod_eql, 2);
-			node2->syn_arg[0] = value;
-			node2->syn_arg[1] = parse_value(0, 0);
-		}
-		parse_matching_paren();
-		return node1;
-	}
-
-	qli_syntax* value2 = parse_value(0, 0);
-
-	// We have the "hard" -- an implicit ANY
-
-	qli_syntax* rse = parse_sql_rse();
-	parse_matching_paren();
-
-	rse->syn_arg[s_rse_outer] = value;
-	rse->syn_arg[s_rse_inner] = value2;
-	rse->syn_arg[s_rse_op] = INT_CAST operatr;
-	rse->syn_arg[s_rse_all_flag] = INT_CAST (all_flag ? TRUE: FALSE);
-
-	// Finally, construct an ANY node
-
-	qli_syntax* node = syntax_node(nod_any, 1);
-	node->syn_arg[0] = rse;
-
-	return all_flag ? negate(node) : node;
-}
-
-
-static qli_syntax* parse_insert()
-{
-/**************************************
- *
- *	p a r s e _ i n s e r t
- *
- **************************************
- *
- * Functional description
- *	Parse a STORE statement.
- *
- **************************************/
-	++sql_flag;
-	PAR_real_token();
-	PAR_match(KW_INTO);
-	qli_syntax* node = syntax_node(nod_store, s_sto_count);
-
-	// Pick up relation name for insert
-
-	node->syn_arg[s_sto_relation] = parse_sql_relation();
-
-	// Pick up field list, provided one is present
-
-	PAR_real();
-
-	qli_lls* fields = NULL;
-	if (PAR_match(KW_LEFT_PAREN))
-	{
-		while (true)
-		{
-			ALLQ_push((blk*) parse_field_name(0), &fields);
-			if (PAR_match(KW_RIGHT_PAREN))
-				break;
-			if (!PAR_match(KW_COMMA))
-				ERRQ_syntax(186);	// Msg186 comma or terminating right parenthesis
-		}
-	}
-
-	// Pick up value list or SELECT statement
-
-	PAR_real();
-
-	bool select_flag;
-	if (PAR_match(KW_VALUES))
-	{
-		select_flag = false;
-		if (!PAR_match(KW_LEFT_PAREN))
-			ERRQ_syntax(187);	// Msg187 left parenthesis
-	}
-	else if (PAR_match(KW_SELECT))
-		select_flag = true;
-	else
-		ERRQ_syntax(188);		// Msg188 VALUES list or SELECT clause
-
-
-	qli_lls* values = NULL;
-	qli_lls* distinct = NULL;
-	while (true)
-	{
-		if (distinct || PAR_match(KW_DISTINCT))
-		{
-			ALLQ_push((blk*) parse_value(0, 0), &distinct);
-			ALLQ_push(distinct->lls_object, &values);
-			ALLQ_push(0, &distinct);
-		}
-		else
-			ALLQ_push((blk*) parse_value(0, 0), &values);
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	if (select_flag)
-		node->syn_arg[s_sto_rse] = parse_sql_rse();
-	else
-		parse_matching_paren();
-
-	if (distinct)
-		node->syn_arg[s_sto_rse]->syn_arg[s_rse_reduced] = make_list(distinct);
-
-	node->syn_arg[s_sto_fields] = (qli_syntax*) fields;
-	node->syn_arg[s_sto_values] = (qli_syntax*) values;
-
-	--sql_flag;
-
-	return node;
-}
-
-
-static nod_t parse_join_type()
-{
-/**************************************
- *
- *	p a r s e _ j o i n _ t y p e
- *
- **************************************
- *
- * Functional description
- *	Parse a join type.
- *
- **************************************/
-	nod_t operatr;
-
-	if (PAR_match(KW_INNER))
-		operatr = nod_join_inner;
-	else if (PAR_match(KW_LEFT))
-		operatr = nod_join_left;
-	else if (PAR_match(KW_RIGHT))
-		operatr = nod_join_right;
-	else if (PAR_match(KW_FULL))
-		operatr = nod_join_full;
-	else if (PAR_match(KW_JOIN))
-		return nod_join_inner;
-	else
-		return nod_nothing;
-
-	if (operatr != nod_join_inner)
-		PAR_match(KW_OUTER);
-
-	if (!PAR_match(KW_JOIN))
-		ERRQ_syntax(489);		// Msg489 JOIN
-
-	return operatr;
-}
-
-
-static qli_syntax* parse_list_fields()
-{
-/**************************************
- *
- *	p a r s e _ l i s t _ f i e l d s
- *
- **************************************
- *
- * Functional description
- *	Parse a LIST statement.  LIST is like PRINT, but does vertical
- *	formatting.
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_list_fields, s_prt_count);
-	PAR_token();
-
-	if (!PAR_match(KW_ALL) && PAR_match(KW_DISTINCT))
-		node->syn_arg[s_prt_distinct] = INT_CAST TRUE;
-
-	if (node->syn_arg[s_prt_output] = parse_output())
-		return node;
-
-	if (test_end())
-		return node;
-
-	// If there is a potential record selection expression, there obviously
-	// can't be a print list.  Get the rse.  Otherwise, pick up the print
-	// list.
-
-	if (potential_rse())
-		node->syn_arg[s_prt_rse] = parse_rse();
-	else
-	{
-		if (!test_end())
-		{
-			qli_lls* stack = NULL;
-			for (;;)
-			{
-				qli_syntax* item = syntax_node(nod_print_item, s_itm_count);
-				item->syn_arg[s_itm_value] = parse_value(0, 0);
-				item->syn_arg[s_itm_edit_string] = (qli_syntax*) parse_edit_string();
-				ALLQ_push((blk*) item, &stack);
-				if (!PAR_match(KW_COMMA) && !PAR_match(KW_AND))
-					break;
-				PAR_real();
-				if (PAR_match(KW_AND))
-					PAR_real();
-			}
-			node->syn_arg[s_prt_list] = make_list(stack);
-		}
-		if (PAR_match(KW_OF))
-			node->syn_arg[s_prt_rse] = parse_rse();
-	}
-
-	node->syn_arg[s_prt_output] = parse_output();
-
-	return node;
-}
-
-
-static qli_const* parse_literal()
-{
-/**************************************
- *
- *	p a r s e _ l i t e r a l
- *
- **************************************
- *
- * Functional description
- *	Parse a literal expression.
- *
- **************************************/
-	qli_const* constant;
-
-	PAR_real();
-	const UCHAR* q = (UCHAR*) QLI_token->tok_string;
-	USHORT l = QLI_token->tok_length;
-
-	if (QLI_token->tok_type == tok_quoted)
-	{
-		q++;
-		l -= 2;
-		constant = (qli_const*) ALLOCDV(type_con, l);
-		constant->con_desc.dsc_dtype = dtype_text;
-		UCHAR* p = constant->con_desc.dsc_address = constant->con_data;
-		QLI_validate_desc(constant->con_desc);
-		if (constant->con_desc.dsc_length = l)
-			memcpy(p, q, l);
-	}
-	else if (QLI_token->tok_type == tok_number)
-		constant = make_numeric_constant(QLI_token->tok_string, QLI_token->tok_length);
-	else
-		ERRQ_syntax(190);		// Msg190 value expression
-
-	PAR_token();
-
-	return constant;
-}
-
-
-static qli_syntax* parse_matches()
-{
-/**************************************
- *
- *	p a r s e _ m a t c h e s
- *
- **************************************
- *
- * Functional description
- *	Parse a matching expressing, including
- *	the preset matching language template.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_sleuth, 3);
-	node->syn_arg[1] = parse_value(0, 0);
-	if (PAR_match(KW_USING))
-		node->syn_arg[2] = parse_value(0, 0);
-	else if (QLI_matching_language)
-	{
-		qli_syntax* language = syntax_node(nod_constant, 1);
-		node->syn_arg[2] = language;
-		language->syn_arg[0] = (qli_syntax*) QLI_matching_language;
-	}
-	else
-	{
-		node->syn_type = nod_matches;
-		node->syn_count = 2;
-	}
-
-	return node;
-}
-
-
-static void parse_matching_paren()
-{
-/**************************************
- *
- *	p a r s e _ m a t c h i n g _ p a r e n
- *
- **************************************
- *
- * Functional description
- *	Check for a trailing (right) parenthesis.  Complain if
- *	its not there.
- *
- **************************************/
-
-	PAR_real();
-
-	if (PAR_match(KW_RIGHT_PAREN))
-		return;
-
-	ERRQ_syntax(191);			// Msg191 right parenthesis
-}
-
-
-static qli_syntax* parse_modify()
-{
-/**************************************
- *
- *	p a r s e _ m o d i f y
- *
- **************************************
- *
- * Functional description
- *	Parse a MODIFY statement.  Modify can be any of the
- *	following:
- *
- *	MODIFY [ALL] [<field> [, <field>]...] [OF <rse> ]
- *	MODIFY [ALL] USING <statement> [OF <rse>]
- *
- **************************************/
-	PAR_token();
-
-	// If this is a meta-data change, handle it elsewhere
-
-	if (PAR_match(KW_INDEX))
-		return parse_modify_index();
-
-	if (PAR_match(KW_FIELD))
-	{
-		qli_syntax* anode = syntax_node(nod_mod_field, 1);
-		anode->syn_arg[0] = (qli_syntax*) parse_database();
-		anode->syn_arg[1] = (qli_syntax*) parse_field(true);
-		return anode;
-	}
-
-	if (PAR_match(KW_RELATION))
-		return parse_modify_relation();
-
-	// Not a meta-data modification, just a simple data modify
-
-	PAR_match(KW_ALL);
-	qli_syntax* node = syntax_node(nod_modify, s_mod_count);
-
-	if (PAR_match(KW_USING))
-		node->syn_arg[s_mod_statement] = parse_statement();
-	else if (!KEYWORD(KW_SEMI))
-	{
-		qli_lls* stack = NULL;
-		while (true)
-		{
-			ALLQ_push((blk*) parse_field_name(0), &stack);
-			if (!PAR_match(KW_COMMA))
-				break;
-		}
-		node->syn_arg[s_mod_list] = make_list(stack);
-	}
-
-	if (PAR_match(KW_OF))
-		node->syn_arg[s_mod_rse] = parse_rse();
-
-	return node;
-}
-
-
-static qli_syntax* parse_modify_index()
-{
-/**************************************
- *
- *	p a r s e _ m o d i f y _ i n d e x
- *
- **************************************
- *
- * Functional description
- *	Parse a MODIFY INDEX statement.
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_mod_index, s_mfi_count);
-	node->syn_arg[s_mfi_database] = (qli_syntax*) parse_database();
-	node->syn_arg[s_mfi_name] = (qli_syntax*) parse_name();
-	PAR_real();
-
-	while (true)
-	{
-		if (PAR_match(KW_UNIQUE))
-			node->syn_flags |= (s_dfi_flag_selectivity | s_dfi_flag_unique);
-		else if (PAR_match(KW_DUPLICATE))
-		{
-			node->syn_flags |= s_dfi_flag_selectivity;
-			node->syn_flags &= ~s_dfi_flag_unique;
-		}
-		else if (PAR_match(KW_INACTIVE))
-			node->syn_flags |= (s_dfi_flag_activity | s_dfi_flag_inactive);
-		else if (PAR_match(KW_ACTIVE))
-		{
-			node->syn_flags |= s_dfi_flag_activity;
-			node->syn_flags &= ~s_dfi_flag_inactive;
-		}
-		else if (PAR_match(KW_DESCENDING))
-			node->syn_flags |= (s_dfi_flag_order | s_dfi_flag_descending);
-		else if (PAR_match(KW_ASCENDING))
-		{
-			node->syn_flags |= s_dfi_flag_order;
-			node->syn_flags &= ~s_dfi_flag_inactive;
-		}
-		else if (PAR_match(KW_STATISTICS))
-			node->syn_flags |= s_dfi_flag_statistics;
-		else
-			break;
-	}
-
-	if (!node->syn_flags)
-		ERRQ_syntax(195);		// Msg195 index state option
-
-	command_end();
-
-	return node;
-}
-
-
-static qli_syntax* parse_modify_relation()
-{
-/**************************************
- *
- *	p a r s e _ m o d i f y _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse a MODIFY RELATION statement.
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_mod_relation, 2);
-	qli_rel* relation = parse_qualified_relation();
-	node->syn_arg[0] = (qli_syntax*) relation;
-
-	if (!relation)
-		ERRQ_syntax(196);		// Msg196 relation name
-
-	for (;;)
-	{
-		PAR_real();
-		qli_fld* field;
-		if (PAR_match(KW_ADD))
-		{
-			PAR_real();
-			PAR_match(KW_FIELD);
-			field = parse_field(false);
-		}
-		else if (PAR_match(KW_MODIFY))
-		{
-			PAR_real();
-			PAR_match(KW_FIELD);
-			field = parse_field(false);
-			field->fld_flags |= FLD_modify;
-		}
-		else if (PAR_match(KW_DROP))
-		{
-			PAR_real();
-			PAR_match(KW_FIELD);
-			field = parse_field(false);
-			field->fld_flags |= FLD_drop;
-		}
-		else
-			ERRQ_syntax(197);	// Msg197 ADD, MODIFY, or DROP
-		field->fld_next = (qli_fld*) node->syn_arg[1];
-		node->syn_arg[1] = (qli_syntax*) field;
-		if (KEYWORD(KW_SEMI))
-			break;
-		if (!PAR_match(KW_COMMA))
-			ERRQ_syntax(198);	// Msg198 comma between field definitions
-	}
-
-	command_end();
-
-	return node;
-}
-
-
-static qli_syntax* parse_multiply( USHORT * paren_count, bool* bool_flag)
-{
-/**************************************
- *
- *	p a r s e _ m u l t i p l y
- *
- **************************************
- *
- * Functional description
- *	Parse the operatrs * and /.
- *
- **************************************/
-	nod_t operatr;
-
-	qli_syntax* node = parse_from(paren_count, bool_flag);
-
-	while (true)
-	{
-		if (PAR_match(KW_ASTERISK))
-			operatr = nod_multiply;
-		else if (PAR_match(KW_SLASH))
-			operatr = nod_divide;
-		else
-			return node;
-		qli_syntax* arg = node;
-		node = syntax_node(operatr, 2);
-		node->syn_arg[0] = arg;
-		node->syn_arg[1] = parse_from(paren_count, bool_flag);
-	}
-}
-
-
-static qli_name* parse_name()
-{
-/**************************************
- *
- *	p a r s e _ n a m e
- *
- **************************************
- *
- * Functional description
- *	Turn current token into a name and get the next token.
- *
- **************************************/
-	PAR_real();
-
-	const bool isQuoted =
-		QLI_token->tok_type == tok_quoted && sql_flag && QLI_token->tok_string[0] == '"';
-	if (QLI_token->tok_type != tok_ident && !isQuoted)
-		ERRQ_syntax(199);		// Msg199 identifier
-
-	SSHORT l = QLI_token->tok_length - 2 * int(isQuoted);
-	qli_name* name = (qli_name*) ALLOCDV(type_nam, l);
-	name->nam_length = l;
-	name->nam_symbol = QLI_token->tok_symbol;
-	const TEXT* q = QLI_token->tok_string + int(isQuoted);
-	TEXT* p = name->nam_string;
-
-	if (isQuoted)
-		memcpy(p, q, l);
-	else if (l)
-		do {
-			const TEXT c = *q++;
-			*p++ = UPPER(c);
-
-		} while (--l);
-
-	PAR_token();
-
-	return name;
-}
-
-
-static qli_syntax* parse_not( USHORT * paren_count)
-{
-/**************************************
- *
- *	p a r s e _ n o t
- *
- **************************************
- *
- * Functional description
- *	Parse a prefix NOT expression.
- *
- **************************************/
-
-	PAR_real();
-
-	if (!PAR_match(KW_NOT))
-		return parse_relational(paren_count);
-
-	return negate(parse_not(paren_count));
-}
-
-
-static int parse_ordinal()
-{
-/**************************************
- *
- *	p a r s e _ o r d i n a l
- *
- **************************************
- *
- * Functional description
- *	Pick up a simple number as a number.  This is
- *	used for SKIP [n], SPACE [n], COL n, and SQL
- *	positions.
- *
- **************************************/
-	PAR_real();
-
-	if (QLI_token->tok_type != tok_number)
-		ERRQ_syntax(200);		// Msg200 positive number
-
-	const int n = atoi(QLI_token->tok_string);
-	if (n < 0)
-		ERRQ_syntax(200);		// Msg200 positive number
-	PAR_token();
-
-	return n;
-}
-
-
-static qli_syntax* parse_output()
-{
-/**************************************
- *
- *	p a r s e _ o u t p u t
- *
- **************************************
- *
- * Functional description
- *	Parse an output clause the the absence thereof.
- *
- **************************************/
-	USHORT flag;
-
-	if (PAR_match(KW_ON))
-		flag = FALSE;
-	else if (PAR_match(KW_TO))
-		flag = TRUE;
-	else
-		return NULL;
-
-	qli_syntax* node = syntax_node(nod_output, s_out_count);
-	node->syn_arg[s_out_file] = parse_value(0, 0);
-	node->syn_arg[s_out_pipe] = INT_CAST flag;
-
-	return node;
-}
-
-
-static qli_syntax* parse_primitive_value( USHORT* paren_count, bool* bool_flag)
-{
-/**************************************
- *
- *	p a r s e _ p r i m i t i v e _ v a l u e
- *
- **************************************
- *
- * Functional description
- *	Pick up a value expression.  This may be either a field reference
- *	or a constant value.
- *
- **************************************/
-	USHORT local_count;
-
-	if (!paren_count)
-	{
-		local_count = 0;
-		paren_count = &local_count;
-	}
-
-	PAR_real();
-
-	qli_syntax* node;
-
-	switch (next_keyword())
-	{
-	case KW_LEFT_PAREN:
-		PAR_token();
-		(*paren_count)++;
-		if (bool_flag && *bool_flag)
-			node = parse_boolean(paren_count);
-		else
-			node = parse_value(paren_count, bool_flag);
-
-		// if (*paren_count && KEYWORD (KW_RIGHT_PAREN))
-		{
-			parse_matching_paren();
-			(*paren_count)--;
-		}
-		break;
-
-	case KW_PLUS:
-		PAR_token();
-		return parse_primitive_value(paren_count, 0);
-
-	case KW_MINUS:
-		{
-			PAR_token();
-			qli_syntax* sub = parse_primitive_value(paren_count, 0);
-			if (sub->syn_type == nod_constant)
-			{
-				qli_const* constant = (qli_const*) sub->syn_arg[0];
-				UCHAR* p = constant->con_desc.dsc_address;
-				switch (constant->con_desc.dsc_dtype)
-				{
-				case dtype_long:
-					*(SLONG *) p = -*(SLONG *) p;
-					return sub;
-				case dtype_text:
-					*p = '-';
-					return sub;
-				}
-			}
-			node = syntax_node(nod_negate, 1);
-			node->syn_arg[0] = sub;
-			break;
-		}
-
-	case KW_ASTERISK:
-		node = parse_prompt();
-		break;
-
-	case KW_EDIT:
-		PAR_token();
-		node = syntax_node(nod_edit_blob, 1);
-		if (!KEYWORD(KW_SEMI))
-			node->syn_arg[0] = parse_value(0, 0);
-		break;
-
-	case KW_FORMAT:
-		PAR_token();
-		node = syntax_node(nod_format, s_fmt_count);
-		node->syn_arg[s_fmt_value] = parse_value(0, 0);
-		node->syn_arg[s_fmt_edit] = (qli_syntax*) parse_edit_string();
-		break;
-
-	case KW_NULL:
-		PAR_token();
-		node = syntax_node(nod_null, 0);
-		break;
-
-	case KW_USER_NAME:
-		PAR_token();
-		node = syntax_node(nod_user_name, 0);
-		break;
-
-	case KW_COUNT:
-	case KW_MAX:
-	case KW_MIN:
-	case KW_AVERAGE:
-	case KW_TOTAL:
-		node = parse_statistical();
-		break;
-
-	case KW_RUNNING:
-		if (function_count > 0)
-			IBERROR(487);		// Msg487 Invalid argument for UDF
-		PAR_real_token();
-		node = syntax_node(nod_running_total, s_stt_count);
-		if (PAR_match(KW_COUNT))
-			node->syn_type = nod_running_count;
-		else
-		{
-			PAR_match(KW_TOTAL);
-			node->syn_arg[s_stt_value] = parse_value(0, 0);
-		}
-		break;
-
-	case KW_SELECT:
-		node = parse_sql_subquery();
-		break;
-
-	default:
-		{
-			const qli_symbol* symbol = QLI_token->tok_symbol;
-			if (symbol && symbol->sym_type == SYM_function)
-			{
-				node = parse_function();
-				break;
-			}
-			if (QLI_token->tok_type == tok_ident ||
-				QLI_token->tok_type == tok_quoted && sql_flag && QLI_token->tok_string[0] == '"')
-			{
-				node = parse_field_name(0);
-				break;
-			}
-			node = syntax_node(nod_constant, 1);
-			node->syn_arg[0] = (qli_syntax*) parse_literal();
-		}
-	}
-
-	return node;
-}
-
-
-static qli_syntax* parse_print_list()
-{
-/**************************************
- *
- *	p a r s e _ p r i n t _ l i s t
- *
- **************************************
- *
- * Functional description
- *	Pick up a print item.  The syntax of a print item is:
- *
- *	<value> [ '[ <query_header> '] ] [USING <edit_string> ]
- *
- **************************************/
-	qli_syntax* node;
-	qli_lls* stack = NULL;
-
-	while (true)
-	{
-	    nod_t op;
-		if (PAR_match(KW_SKIP))
-			op = nod_skip;
-		else if (PAR_match(KW_SPACE))
-			op = nod_space;
-		else if (PAR_match(KW_TAB))
-			op = nod_tab;
-		else if (PAR_match(KW_COLUMN))
-			op = nod_column;
-		else if (PAR_match(KW_NEW_PAGE))
-			op = nod_new_page;
-		else if (PAR_match(KW_REPORT_HEADER))
-			op = nod_report_header;
-		else if (PAR_match(KW_COLUMN_HEADER))
-			op = nod_column_header;
-		else
-		{
-			op = nod_print_item;
-			node = syntax_node(nod_print_item, s_itm_count);
-			node->syn_arg[s_itm_value] = parse_value(0, 0);
-			if (PAR_match(KW_LEFT_PAREN))
-			{
-				if (PAR_match(KW_MINUS))
-					node->syn_arg[s_itm_header] = (qli_syntax*) "-";
-				else
-					node->syn_arg[s_itm_header] = (qli_syntax*) parse_header();
-				parse_matching_paren();
-			}
-			node->syn_arg[s_itm_edit_string] = (qli_syntax*) parse_edit_string();
-		}
-		if (op != nod_print_item)
-		{
-			node = syntax_node(op, 1);
-			node->syn_count = 0;
-			node->syn_arg[0] = INT_CAST 1;
-			if (op == nod_column || QLI_token->tok_type == tok_number)
-				node->syn_arg[0] = INT_CAST parse_ordinal();
-			if ((op == nod_skip) && ((IPTR) node->syn_arg[0] < 1))
-				ERRQ_syntax(478);	// Msg478 number > 0
-		}
-		ALLQ_push((blk*) node, &stack);
-		if (!PAR_match(KW_COMMA) && !PAR_match(KW_AND))
-			break;
-		PAR_real();
-		if (PAR_match(KW_AND))
-			PAR_real();
-	}
-
-	node = make_list(stack);
-
-	return node;
-}
-
-
-static qli_syntax* parse_print()
-{
-/**************************************
- *
- *	p a r s e _ p r i n t
- *
- **************************************
- *
- * Functional description
- *	Parse the PRINT statement.  This is the richest and most general
- *	Datatrieve statement.  Hence this may get a bit long.  The syntax is:
- *
- *		[<item> [, <item>]] OF <rse>
- *	PRINT [ 			     ] [ON <file>]
- *		<rse>
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_print, s_prt_count);
-	PAR_token();
-
-	if (!PAR_match(KW_ALL) && PAR_match(KW_DISTINCT))
-		node->syn_arg[s_prt_distinct] = INT_CAST TRUE;
-
-	if (node->syn_arg[s_prt_output] = parse_output())
-		return node;
-
-	if (test_end())
-		return node;
-
-	// If there is a potential record selection expression, there obviously
-	// can't be a print list.  Get the rse.  Otherwise, pick up the print
-	// list.
-
-	if (potential_rse())
-		node->syn_arg[s_prt_rse] = parse_rse();
-	else if (!KEYWORD(KW_USING))
-	{
-		if (!KEYWORD(KW_THEN) && !KEYWORD(KW_OF) && !KEYWORD(KW_ON))
-			node->syn_arg[s_prt_list] = parse_print_list();
-		if (PAR_match(KW_OF))
-			node->syn_arg[s_prt_rse] = parse_rse();
-	}
-
-	if (!node->syn_arg[s_prt_list] && PAR_match(KW_USING))
-	{
-		IBERROR(484);			// FORMs not supported
-	}
-	else
-		node->syn_arg[s_prt_output] = parse_output();
-
-	return node;
-}
-
-
-static qli_syntax* parse_prompt()
-{
-/**************************************
- *
- *	p a r s e _ p r o m p t
- *
- **************************************
- *
- * Functional description
- *	Parse a prompt expression.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_prompt, 1);
-
-	// If there is a period, get the prompt string and make a string node
-
-	if (PAR_match(KW_DOT))
-	{
-		PAR_real();
-		USHORT l = QLI_token->tok_length;
-		const TEXT* q = QLI_token->tok_string;
-		if (QLI_token->tok_type == tok_quoted)
-		{
-			q++;
-			l -= 2;
-		}
-		node->syn_arg[0] = (qli_syntax*) make_string(q, l);
-		PAR_token();
-	}
-
-	return node;
-}
-
-
-static qli_filter* parse_qualified_filter()
-{
-/**************************************
- *
- *	p a r s e _ q u a l i f i e d _ f i l t e r
- *
- **************************************
- *
- * Functional description
- *	This token ought to be a filter, possibly qualified.
- *	Return a qualified filter block, containing the
- *	filter name in a qli_name block and the database in a
- *	qli_dbb block if a database was specified.  Somebody
- *	else will decide what to do if the database was not
- *	specified.
- *
- **************************************/
-	qli_filter* filter = (qli_filter*) ALLOCD(type_qfl);
-	filter->qfl_database = parse_database();
-	filter->qfl_name = parse_name();
-	return filter;
-}
-
-
-
-static qli_func* parse_qualified_function()
-{
-/**************************************
- *
- *	p a r s e _ q u a l i f i e d _ f u n c t i o n
- *
- **************************************
- *
- * Functional description
- *	This token ought to be a function, possibly qualified.
- *	Return a qualified function block, containing the
- *	function name in a qli_name block and the database in a
- *	qli_dbb block if a database was specified.  Somebody
- *	else will decide what to do if the database was not
- *	specified.
- *
- **************************************/
-	qli_func* func = (qli_func*) ALLOCD(type_qfn);
-	func->qfn_database = parse_database();
-	func->qfn_name = parse_name();
-	return func;
-}
-
-
-static qli_proc* parse_qualified_procedure()
-{
-/**************************************
- *
- *	p a r s e _ q u a l i f i e d _ p r o c e d u r e
- *
- **************************************
- *
- * Functional description
- *	This token ought to be a procedure, possibly qualified.
- *	Return a qualified procedure block, containing the
- *	procedure name in a qli_name block and the database in a
- *	qli_dbb block if a database was specified.  Somebody
- *	else will decide what to do if the database was not
- *	specified.
- *
- **************************************/
-	qli_proc* proc = (qli_proc*) ALLOCD(type_qpr);
-	proc->qpr_database = parse_database();
-	proc->qpr_name = parse_name();
-	return proc;
-}
-
-
-static qli_rel* parse_qualified_relation()
-{
-/**************************************
- *
- *	p a r s e _ q u a l i f i e d _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Check for a relation name, possible qualified.  If there
- *	is a relation name, parse it and return the relation.  If
- *	not, return NULL.  Produce a syntax error only if there is
- *	a partially qualified name.
- *
- **************************************/
-	PAR_real();
-
-	// If the next token is a database symbol, take it as a qualifier
-
-	qli_symbol* db_symbol = QLI_token->tok_symbol;
-	if (db_symbol && db_symbol->sym_type == SYM_database)
-	{
-		PAR_real_token();
-		if (!PAR_match(KW_DOT))
-			ERRQ_syntax(202);	// Msg202 period in qualified relation name
-		PAR_real();
-		qli_rel* relation = resolve_relation(db_symbol, QLI_token->tok_symbol);
-		if (relation)
-		{
-			PAR_token();
-			return relation;
-		}
-		ERRQ_print_error(203, SafeArg() << QLI_token->tok_string << db_symbol->sym_string);
-		// Msg203 %s is not a relation in database %s
-	}
-
-	qli_rel* relation = resolve_relation(0, QLI_token->tok_symbol);
-	if (relation)
-		PAR_token();
-
-	return relation;
-}
-
-
-static qli_syntax* parse_ready( nod_t node_type)
-{
-/**************************************
- *
- *	p a r s e _ r e a d y
- *
- **************************************
- *
- * Functional description
- *	Parse a READY statement:
- *
- *	READY <filename> [AS <symbol>] [,...];
- *
- **************************************/
-	qli_lls* stack = NULL;
-
-	while (true)
-	{
-		LEX_filename();
-		SSHORT l = QLI_token->tok_length;
-		if (!l)
-			ERRQ_error(204);
-			// Msg204 database file name required on READY
-		const TEXT* q = QLI_token->tok_string;
-		if (QLI_token->tok_type == tok_quoted)
-		{
-			l -= 2;
-			q++;
-		}
-		qli_dbb* database = (qli_dbb*) ALLOCDV(type_dbb, l);
-		database->dbb_filename_length = l;
-		memcpy(database->dbb_filename, q, l);
-		PAR_token();
-
-		switch (node_type)
-		{
-		case nod_def_database:
-		case nod_ready:
-			if (PAR_match(KW_AS))
-			{
-				qli_name* name = parse_name();
-				database->dbb_symbol = (qli_symbol*) name;
-				if (HSH_lookup(name->nam_string, name->nam_length))
-					ERRQ_error(408, name->nam_string);
-					// Database handle is not unique
-			}
-			else
-				database->dbb_symbol = (qli_symbol*) make_name();
-			break;
-		case nod_sql_database:
-			if (PAR_match(KW_PAGESIZE))
-			{
-				if (database->dbb_pagesize)
-					ERRQ_syntax(390);	// Msg390 Multiple page size specifications
-				if (!PAR_match(KW_EQUALS))
-					ERRQ_syntax(396);	// Msg396 = (equals)
-				database->dbb_pagesize = parse_ordinal();
-			}
-			database->dbb_symbol = (qli_symbol*) make_name();
-			break;
-		}
-
-		for (;;)
-		{
-			if (PAR_match(KW_USER))
-				database->dbb_user = parse_literal();
-			else if (PAR_match(KW_PASSWORD))
-				database->dbb_password = parse_literal();
-			else
-				break;
-		}
-
-		ALLQ_push((blk*) database, &stack);
-		if (!KEYWORD(KW_COMMA) || (node_type == nod_sql_database))
-			break;
-	}
-
-	command_end();
-	qli_syntax* node = make_list(stack);
-	node->syn_type = node_type;
-
-	return node;
-}
-
-
-static qli_syntax* parse_relational( USHORT * paren_count)
-{
-/**************************************
- *
- *	p a r s e _ r e l a t i o n a l
- *
- **************************************
- *
- * Functional description
- *	Parse a relational expression.
- *
- **************************************/
-	if (PAR_match(KW_ANY))
-	{
-		qli_syntax* anode = syntax_node(nod_any, 1);
-		anode->syn_arg[0] = parse_rse();
-		return anode;
-	}
-
-	nod_t operatr = nod_nothing;
-	if (PAR_match(KW_EXISTS))
-		operatr = nod_any;
-	else if (PAR_match(KW_SINGULAR))
-		operatr = nod_unique;
-
-	if (operatr != nod_nothing)
-	{
-		PAR_real();
-		if (PAR_match(KW_LEFT_PAREN))
-		{
-			PAR_real();
-			if (PAR_match(KW_SELECT))
-			{
-				PAR_real();
-				qli_syntax* node = syntax_node(operatr, 2);
-				if (!PAR_match(KW_ASTERISK))
-					node->syn_arg[1] = parse_value(0, 0);
-				node->syn_arg[0] = parse_sql_rse();
-				parse_matching_paren();
-				return node;
-			}
-		}
-		if (operatr == nod_any)
-			ERRQ_syntax(205);	// Msg205 EXISTS (SELECT * <sql rse>)
-		else
-			ERRQ_syntax(488);	// Msg488 SINGULAR (SELECT * <sql rse>)
-	}
-
-	if (PAR_match(KW_UNIQUE))
-	{
-		qli_syntax* node = syntax_node(nod_unique, 1);
-		node->syn_arg[0] = parse_rse();
-		return node;
-	}
-
-    bool local_flag = true;
-	qli_syntax* expr1 = parse_value(paren_count, &local_flag);
-	if (KEYWORD(KW_RIGHT_PAREN))
-		return expr1;
-
-	const nod_t* rel_ops;
-
-	if (KEYWORD(KW_SEMI))
-	{
-		for (rel_ops = relationals; *rel_ops != nod_nothing; rel_ops++)
-		{
-			if (expr1->syn_type == *rel_ops)
-				return expr1;
-		}
-	}
-
-	bool negation = false;
-	qli_syntax* node = NULL;
-	PAR_match(KW_IS);
-	PAR_real();
-
-	if (PAR_match(KW_NOT))
-	{
-		negation = true;
-		PAR_real();
-	}
-
-	switch (next_keyword())
-	{
-	case KW_IN:
-		PAR_token();
-		node = parse_in(expr1, nod_eql, false);
-		break;
-
-	case KW_EQUALS:
-	case KW_EQ:
-		operatr = negation ? nod_neq : nod_eql;
-		negation = false;
-		break;
-
-	case KW_NE:
-		operatr = negation ? nod_eql : nod_neq;
-		negation = false;
-		break;
-
-	case KW_GT:
-		operatr = negation ? nod_leq : nod_gtr;
-		negation = false;
-		break;
-
-	case KW_GE:
-		operatr = negation ? nod_lss : nod_geq;
-		negation = false;
-		break;
-
-	case KW_LE:
-		operatr = negation ? nod_gtr : nod_leq;
-		negation = false;
-		break;
-
-	case KW_LT:
-		operatr = negation ? nod_geq : nod_lss;
-		negation = false;
-		break;
-
-	case KW_CONTAINING:
-		operatr = nod_containing;
-		break;
-
-	case KW_MATCHES:
-		node = parse_matches();
-		node->syn_arg[0] = expr1;
-		operatr = node->syn_type;
-		break;
-
-	case KW_LIKE:
-		PAR_token();
-		node = syntax_node(nod_like, 3);
-		node->syn_arg[0] = expr1;
-		node->syn_arg[1] = parse_value(0, 0);
-		if (PAR_match(KW_ESCAPE))
-			node->syn_arg[2] = parse_value(0, 0);
-		else
-			node->syn_count = 2;
-		break;
-
-	case KW_STARTS:
-		PAR_token();
-		PAR_match(KW_WITH);
-		node = syntax_node(nod_starts, 2);
-		node->syn_arg[0] = expr1;
-		node->syn_arg[1] = parse_value(0, 0);
-		break;
-
-	case KW_NULL:
-	case KW_MISSING:
-		PAR_token();
-		node = syntax_node(nod_missing, 1);
-		node->syn_arg[0] = expr1;
-		break;
-
-	case KW_BETWEEN:
-		PAR_token();
-		node = syntax_node(nod_between, 3);
-		node->syn_arg[0] = expr1;
-		node->syn_arg[1] = parse_value(0, 0);
-		PAR_match(KW_AND);
-		node->syn_arg[2] = parse_value(0, 0);
-		break;
-
-	default:
-		for (rel_ops = relationals; *rel_ops != nod_nothing; rel_ops++)
-		{
-			if (expr1->syn_type == *rel_ops)
-				return expr1;
-		}
-		ERRQ_syntax(206);		// Msg206 relational operatr
-	}
-
-	// If we haven't already built a node, it must be an ordinary binary operatr.
-	// Build it.
-
-	if (!node)
-	{
-		PAR_token();
-		if (PAR_match(KW_ANY))
-			return parse_in(expr1, operatr, false);
-		if (PAR_match(KW_ALL))
-			return parse_in(expr1, operatr, true);
-		node = syntax_node(operatr, 2);
-		node->syn_arg[0] = expr1;
-		node->syn_arg[1] = parse_value(paren_count, &local_flag);
-	}
-
-	// If a negation remains to be handled, zap the node under a NOT.
-
-	if (negation)
-		node = negate(node);
-
-	// If the node isn't an equality, we've done.  Since equalities can be
-	// structured as implicit ORs, build them here.
-
-	if (operatr != nod_eql)
-		return node;
-
-	// We have an equality operation, which can take a number of values.  Generate
-	// implicit ORs
-
-	while (PAR_match(KW_COMMA))
-	{
-		PAR_real();
-		PAR_match(KW_OR);
-		qli_syntax* or_node = syntax_node(nod_or, 2);
-		or_node->syn_arg[0] = node;
-		or_node->syn_arg[1] = node = syntax_node(nod_eql, 2);
-		node->syn_arg[0] = expr1;
-		node->syn_arg[1] = parse_value(paren_count, &local_flag);
-		node = or_node;
-	}
-
-	return node;
-}
-
-
-static qli_syntax* parse_relation()
-{
-/**************************************
- *
- *	p a r s e _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse a relation expression.  Syntax is:
- *
- *	[ <context_variable> IN ] <relation>
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_relation, s_rel_count);
-
-	// Token wasn't a relation name, maybe it's a context variable.
-
-	if (!(node->syn_arg[s_rel_relation] = (qli_syntax*) parse_qualified_relation()))
-	{
-		qli_symbol* context = parse_symbol();
-		node->syn_arg[s_rel_context] = (qli_syntax*) context;
-		if (sql_flag || !PAR_match(KW_IN))
-		{
-			if (!QLI_databases)
-				IBERROR(207);	// Msg207 a database has not been readied
-			ERRQ_print_error(208, context->sym_string);
-			// Msg208 expected \"relation_name\", encountered \"%s\"
-		}
-		if (!(node->syn_arg[s_rel_relation] = (qli_syntax*) parse_qualified_relation()))
-		{
-			ERRQ_syntax(209);	// Msg209 relation name
-		}
-	}
-
-	return node;
-}
-
-
-static qli_syntax* parse_rename()
-{
-/**************************************
- *
- *	p a r s e _ r e n a m e
- *
- **************************************
- *
- * Functional description
- *	Parse a PROCEDURE rename statement.
- *
- **************************************/
-	PAR_real_token();
-
-	if (!PAR_match(KW_PROCEDURE))
-		ERRQ_syntax(210);		// Msg210 PROCEDURE
-
-	qli_syntax* node = syntax_node(nod_rename_proc, 2);
-	node->syn_arg[0] = (qli_syntax*) parse_qualified_procedure();
-	PAR_match(KW_TO);
-	node->syn_arg[1] = (qli_syntax*) parse_qualified_procedure();
-
-	return node;
-}
-
-
-static qli_syntax* parse_repeat()
-{
-/**************************************
- *
- *	p a r s e _ r e p e a t
- *
- **************************************
- *
- * Functional description
- *	Parse REPEAT statement.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_repeat, s_rpt_count);
-	node->syn_arg[s_rpt_value] = parse_value(0, 0);
-	node->syn_arg[s_rpt_statement] = parse_statement();
-
-	return node;
-}
-
-
-static qli_syntax* parse_report()
-{
-/**************************************
- *
- *	p a r s e _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Parse a report specification.
- *
- **************************************/
-	++sw_report;
-	PAR_token();
-	qli_rpt* report = (qli_rpt*) ALLOCD(type_rpt);
-	qli_syntax* node = syntax_node(nod_report, s_prt_count);
-	node->syn_arg[s_prt_list] = (qli_syntax*) report;
-
-	// Pick up record select expression
-
-	qli_syntax* rse = node->syn_arg[s_prt_rse] = parse_rse();
-	node->syn_arg[s_prt_output] = parse_output();
-
-	// Pick up report clauses
-
-	bool top;
-
-	for (;;)
-	{
-		PAR_real();
-		if (PAR_match(KW_END_REPORT))
-			break;
-
-		switch (next_keyword())
-		{
-		case KW_PRINT:
-			PAR_token();
-			report->rpt_detail_line = (qli_nod*) parse_print_list();
-			break;
-
-		case KW_AT:
-			PAR_token();
-			if (PAR_match(KW_TOP))
-				top = true;
-			else if (PAR_match(KW_BOTTOM))
-				top = false;
-			else
-				ERRQ_syntax(382);	// Msg382 TOP or BOTTOM
-			PAR_match(KW_OF);
-			if (PAR_match(KW_REPORT))
-			{
-				qli_brk* control = (qli_brk*) ALLOCD(type_brk);
-				qli_brk** ptr = top ? &report->rpt_top_rpt : &report->rpt_bottom_rpt;
-				control->brk_next = *ptr;
-				*ptr = control;
-				PAR_match(KW_PRINT);
-				control->brk_line = parse_print_list();
-			}
-			else if (PAR_match(KW_PAGE))
-			{
-				qli_brk* control = (qli_brk*) ALLOCD(type_brk);
-				qli_brk** ptr = top ? &report->rpt_top_page : &report->rpt_bottom_page;
-				control->brk_next = *ptr;
-				*ptr = control;
-				PAR_match(KW_PRINT);
-				control->brk_line = parse_print_list();
-			}
-			else
-			{
-				qli_brk** ptr = top ? &report->rpt_top_breaks : &report->rpt_bottom_breaks;
-				if (!*ptr)
-				{
-					// control breaks should only be on sorted fields, set up list
-					// of control breaks based on sorted fields and then add action (print)
-					// items to that list.
-					qli_syntax* flds = rse->syn_arg[s_rse_sort];
-					if (!flds)
-						ERRQ_syntax(383);	// Msg383 sort field
-					qli_brk* tmpptr = *ptr;
-					for (USHORT i = 0; i < flds->syn_count; i += 2)
-					{
-						qli_brk* control = (qli_brk*) ALLOCD(type_brk);
-						control->brk_field = flds->syn_arg[i];
-						control->brk_line = NULL;
-						control->brk_statisticals = NULL;
-						control->brk_next = tmpptr;
-						tmpptr = control;
-					}
-					if (!top)
-					{
-						// reverse the 'at bottom' control break list as the
-						// lower control breaks should be performed prior to the higher ones.
-						qli_brk* control = 0;
-						for (qli_brk* tmpptr1 = tmpptr->brk_next; tmpptr;)
-						{
-							tmpptr->brk_next = control;
-							control = tmpptr;
-							if (tmpptr = tmpptr1)
-								tmpptr1 = tmpptr->brk_next;
-						}
-						tmpptr = control;
-					}
-					*ptr = tmpptr;
-				}
-				qli_syntax* qli_fld = parse_field_name(0);
-				qli_brk* control;
-				for (control = *ptr; control; control = control->brk_next)
-				{
-					qli_syntax* rse_fld = (qli_syntax*) control->brk_field;
-					if (rse_fld->syn_type != qli_fld->syn_type)
-						continue;
-					// if number of field qualifiers on sort field and control field
-					// are not equal test match of rightmost set
-					const USHORT syn_count = MIN(rse_fld->syn_count, qli_fld->syn_count);
-					USHORT srt_syn = 0, ctl_syn = 0;
-					if (syn_count != rse_fld->syn_count)
-						srt_syn = rse_fld->syn_count - syn_count;
-					if (syn_count != qli_fld->syn_count)
-						ctl_syn = qli_fld->syn_count - syn_count;
-					USHORT i;
-					for (i = 0; i < syn_count; i++)
-					{
-						const qli_name* name1 = (qli_name*) rse_fld->syn_arg[i + srt_syn];
-						const qli_name* name2 = (qli_name*) qli_fld->syn_arg[i + ctl_syn];
-						if (strcmp(name1->nam_string, name2->nam_string))
-							break;
-					}
-					if (i == qli_fld->syn_count)
-						break;
-				}
-				if (!control)
-					ERRQ_syntax(383);	// Msg383 sort field
-				PAR_match(KW_PRINT);
-				control->brk_field = qli_fld;
-				control->brk_line = parse_print_list();
-			}
-			break;
-
-		case KW_SET:
-			PAR_token();
-			if (PAR_match(KW_COLUMNS))
-			{
-				PAR_match(KW_EQUALS);
-				report->rpt_columns = parse_ordinal();
-			}
-			else if (PAR_match(KW_LINES))
-			{
-				PAR_match(KW_EQUALS);
-				report->rpt_lines = parse_ordinal();
-			}
-			else if (PAR_match(KW_REPORT_NAME))
-			{
-				PAR_match(KW_EQUALS);
-				report->rpt_name = parse_header();
-			}
-			else
-				ERRQ_syntax(212);	// Msg212 report writer SET option
-			break;
-
-		default:
-			ERRQ_syntax(213);	// Msg213 report item
-		}
-		PAR_match(KW_SEMI);
-	}
-
-	if (!node->syn_arg[s_prt_output])
-		node->syn_arg[s_prt_output] = parse_output();
-
-	check_end();
-	--sw_report;
-
-	return node;
-}
-
-
-static qli_syntax* parse_rse()
-{
-/**************************************
- *
- *	p a r s e _ r s e
- *
- **************************************
- *
- * Functional description
- *	Parse a record selection expression.
- *
- **************************************/
-	PAR_real();
-
-	if (PAR_match(KW_ALL))
-		PAR_real();
-
-	qli_syntax* first = NULL;
-	if (PAR_match(KW_FIRST))
-		first = parse_value(0, 0);
-
-	USHORT count = 0;
-	qli_lls* stack = NULL;
-	while (true)
-	{
-		count++;
-		ALLQ_push((blk*) parse_relation(), &stack);
-		qli_syntax* over = NULL;
-		if (PAR_match(KW_OVER))
-		{
-			qli_lls* field_stack = NULL;
-			while (true)
-			{
-				ALLQ_push((blk*) parse_field_name(0), &field_stack);
-				if (!PAR_match(KW_COMMA))
-					break;
-			}
-			over = make_list(field_stack);
-		}
-		ALLQ_push((blk*) over, &stack);
-		if (!PAR_match(KW_CROSS))
-			break;
-	}
-
-	qli_syntax* node = syntax_node(nod_rse, (int) s_rse_count + 2 * count);
-	node->syn_count = count;
-	node->syn_arg[s_rse_first] = first;
-	qli_syntax** ptr = &node->syn_arg[(int) s_rse_count + 2 * count];
-
-	while (stack)
-		*--ptr = (qli_syntax*) ALLQ_pop(&stack);
-
-	// Pick up various other clauses
-
-	USHORT sw_with = 0;
-	while (true)
-	{
-		if (PAR_match(KW_WITH))
-		{
-			if (!sw_with)
-			{
-				sw_with++;
-				node->syn_arg[s_rse_boolean] = parse_boolean(0);
-			}
-			else
-				IBERROR(384);	// Msg384 Too many WITHs
-		}
-		else if (PAR_match(KW_SORTED))
-		{
-			PAR_real();
-			PAR_match(KW_BY);
-			node->syn_arg[s_rse_sort] = parse_sort();
-		}
-		else if (PAR_match(KW_REDUCED))
-		{
-			PAR_real();
-			PAR_match(KW_TO);
-			node->syn_arg[s_rse_reduced] = parse_sort();
-		}
-		else if (PAR_match(KW_GROUP))
-		{
-			PAR_real();
-			PAR_match(KW_BY);
-			stack = NULL;
-			while (true)
-			{
-				ALLQ_push((blk*) parse_udf_or_field(), &stack);
-				if (!PAR_match(KW_COMMA))
-					break;
-			}
-			node->syn_arg[s_rse_group_by] = make_list(stack);
-		}
-		else
-			break;
-	}
-
-	return node;
-}
-
-
-static qli_syntax* parse_select()
-{
-/**************************************
- *
- *	p a r s e _ s e l e c t
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL select statement.
- *
- **************************************/
-	++sql_flag;
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_print, s_prt_count);
-
-	if (!PAR_match(KW_ALL) && PAR_match(KW_DISTINCT))
-		node->syn_arg[s_prt_distinct] = INT_CAST TRUE;
-
-	// Get list of items
-
-	if (!PAR_match(KW_ASTERISK))
-	{
-		qli_lls* stack = NULL;
-		while (true)
-		{
-			qli_syntax* item = syntax_node(nod_print_item, s_itm_count);
-			item->syn_arg[s_itm_value] = parse_value(0, 0);
-			ALLQ_push((blk*) item, &stack);
-			if (!PAR_match(KW_COMMA))
-				break;
-		}
-		node->syn_arg[s_prt_list] = make_list(stack);
-	}
-
-    qli_syntax* rse = parse_sql_rse();
-	node->syn_arg[s_prt_rse] = rse;
-	rse->syn_arg[s_rse_list] = node->syn_arg[s_prt_list];
-
-	if (PAR_match(KW_ORDER))
-	{
-		PAR_real();
-		PAR_match(KW_BY);
-		node->syn_arg[s_prt_order] = parse_sort();
-	}
-
-	--sql_flag;
-
-	return node;
-}
-
-
-static qli_syntax* parse_set()
-{
-/**************************************
- *
- *	p a r s e _ s e t
- *
- **************************************
- *
- * Functional description
- *	Parse a SET statement.
- *
- **************************************/
-	PAR_token();
-	qli_lls* stack = NULL;
-	USHORT count = 0;
-
-	while (true)
-	{
-		PAR_real();
-		U_IPTR value = TRUE;
-		if (PAR_match(KW_NO))
-		{
-			value = FALSE;
-			PAR_real();
-		}
-		enum set_t sw;
-
-		switch (QLI_token->tok_keyword)
-		{
-		case KW_BLR:
-			sw = set_blr;
-			PAR_token();
-			break;
-
-		case KW_STATISTICS:
-			sw = set_statistics;
-			PAR_token();
-			break;
-
-		case KW_COLUMNS:
-			sw = set_columns;
-			PAR_token();
-			PAR_match(KW_EQUALS);
-			value = parse_ordinal();
-			break;
-
-		case KW_LINES:
-			sw = set_lines;
-			PAR_token();
-			PAR_match(KW_EQUALS);
-			value = parse_ordinal();
-			break;
-
-		case KW_SEMICOLON:
-			sw = set_semi;
-			PAR_token();
-			break;
-
-		case KW_ECHO:
-			sw = set_echo;
-			PAR_token();
-			break;
-
-		case KW_MATCHING_LANGUAGE:
-			sw = set_matching_language;
-			PAR_token();
-			PAR_match(KW_EQUALS);
-			if (value)
-				value = (U_IPTR) parse_literal();
-			break;
-
-		case KW_PASSWORD:
-			sw = set_password;
-			PAR_token();
-			value = (U_IPTR) parse_literal();
-			break;
-
-		case KW_PROMPT:
-			sw = set_prompt;
-			PAR_token();
-			value = (U_IPTR) parse_literal();
-			break;
-
-		case KW_CONT_PROMPT:
-			sw = set_continuation;
-			PAR_token();
-			value = (U_IPTR) parse_literal();
-			break;
-
-		case KW_USER:
-			sw = set_user;
-			PAR_token();
-			value = (U_IPTR) parse_literal();
-			break;
-
-		case KW_COUNT:
-			sw = set_count;
-			PAR_token();
-			break;
-
-		case KW_CHAR:
-			sw = set_charset;
-			PAR_token();
-			PAR_match(KW_SET);
-			if (value)
-			{
-				// allow for NO
-				PAR_match(KW_EQUALS);
-				value = (U_IPTR) parse_name();
-			}
-			break;
-
-		case KW_NAMES:
-			sw = set_charset;
-			PAR_token();
-			if (value) {
-				value = (U_IPTR) parse_name();
-			}
-			break;
-
-#ifdef DEV_BUILD
-		case KW_EXPLAIN:
-			sw = set_explain;
-			PAR_token();
-			break;
-
-		case KW_HEXOUT:
-			sw = set_hex_output;
-			PAR_token();
-			break;
-#endif
-
-		default:
-			ERRQ_syntax(214);	// Msg214 set option
-		}
-		ALLQ_push((blk*) sw, &stack);
-		ALLQ_push((blk*) value, &stack);
-		count++;
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	command_end();
-	qli_syntax* node = make_list(stack);
-	node->syn_count = count;
-	node->syn_type = nod_set;
-
-	return node;
-}
-
-
-static qli_syntax* parse_shell()
-{
-/**************************************
- *
- *	p a r s e _ s h e l l
- *
- **************************************
- *
- * Functional description
- *	Parse SHELL command.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_shell, 1);
-
-	if (!KEYWORD(KW_SEMI))
-		node->syn_arg[0] = (qli_syntax*) parse_literal();
-
-	command_end();
-
-	return node;
-}
-
-
-static qli_syntax* parse_show()
-{
-/**************************************
- *
- *	p a r s e _ s h o w
- *
- **************************************
- *
- * Functional description
- *	Parse a SHOW statement.  The first
- *	group are individual things (one
- *	named relation, field, form, ...)
- *
- *	the second group are sets of things
- *	and can be qualified with a FOR
- *	[DATABASE] <handle>
- *
- **************************************/
-	PAR_token();
-	qli_lls* stack = NULL;
-	USHORT count = 0;
-
-	while (true)
-	{
-		PAR_real();
-		BLK value = NULL;
-		qli_symbol* symbol = QLI_token->tok_symbol;
-		enum show_t sw;
-
-		if (PAR_match(KW_ALL))
-			sw = show_all;
-		else if (PAR_match(KW_MATCHING_LANGUAGE))
-			sw = show_matching_language;
-		else if (PAR_match(KW_VERSION))
-			sw = show_version;
-		else if (PAR_match(KW_RELATION))
-		{
-			if (!(value = (BLK) parse_qualified_relation()))
-				ERRQ_syntax(216);	// Msg216 relation name
-			else
-				sw = show_relation;
-		}
-		else if (PAR_match(KW_FILTER))
-		{
-			sw = show_filter;
-			value = (BLK) parse_qualified_filter();
-		}
-		else if (PAR_match(KW_FUNCTION))
-		{
-			sw = show_function;
-			value = (BLK) parse_qualified_function();
-		}
-		else if ((PAR_match(KW_DATABASES)) || (PAR_match(KW_READY)))
-			sw = show_databases;
-		else if (PAR_match(KW_DATABASE))
-		{
-			sw = show_database;
-			if (value = (BLK) get_dbb(QLI_token->tok_symbol))
-				PAR_token();
-		}
-		else if (PAR_match(KW_FIELD))
-		{
-			sw = show_field;
-			value = (BLK) parse_field_name(0);
-		}
-		else if (PAR_match(KW_PROCEDURE))
-		{
-			sw = show_procedure;
-			value = (BLK) parse_qualified_procedure();
-		}
-		else if (PAR_match(KW_VARIABLE))
-		{
-			sw = show_variable;
-			value = (BLK) parse_name();
-		}
-		else if (PAR_match(KW_VARIABLES))
-			sw = show_variables;
-		else if (PAR_match(KW_FIELDS))
-		{
-			if (PAR_match(KW_FOR))
-			{
-				if (PAR_match(KW_DATABASE))
-				{
-					if (value = (BLK) get_dbb(QLI_token->tok_symbol))
-						PAR_token();
-					else
-						ERRQ_syntax(221);	// Msg221 database name
-					sw = show_db_fields;
-				}
-				else
-				{
-					PAR_match(KW_RELATION);
-					if (!(value = (BLK) parse_qualified_relation()))
-						ERRQ_syntax(218);	// Msg218 relation name
-					else
-						sw = show_relation;
-				}
-			}
-			else
-				sw = show_all;
-		}
-		else if (PAR_match(KW_INDICES))
-		{
-			sw = show_indices;
-			if (PAR_match(KW_FOR))
-				if (PAR_match(KW_DATABASE))
-				{
-					if (value = (BLK) get_dbb(QLI_token->tok_symbol))
-						PAR_token();
-					else
-						ERRQ_syntax(221);	// Msg221 database name
-					sw = show_db_indices;
-				}
-				else if (!(value = (BLK) parse_qualified_relation()))
-					ERRQ_syntax(220);	// Msg220 relation name
-		}
-		else if (PAR_match(KW_SECURITY_CLASS))
-		{
-			sw = show_security_class;
-			value = (BLK) parse_name();
-		}
-		else if (PAR_match(KW_TRIGGERS))
-		{
-			sw = show_triggers;
-			if (PAR_match(KW_FOR))
-			{
-				if (PAR_match(KW_DATABASE))
-				{
-					if (value = (BLK) get_dbb(QLI_token->tok_symbol))
-						PAR_token();
-					else
-						ERRQ_syntax(221);	// Msg221 database name
-				}
-				else
-				{
-					PAR_match(KW_RELATION);
-					if (!(value = (BLK) parse_qualified_relation()))
-						ERRQ_syntax(222);	// Msg222 relation_name
-					sw = show_trigger;
-				}
-			}
-		}
-		else if (PAR_match(KW_RELATIONS))
-			sw = show_relations;
-		else if (PAR_match(KW_VIEWS))
-			sw = show_views;
-		else if (PAR_match(KW_SECURITY_CLASSES))
-			sw = show_security_classes;
-		else if (PAR_match(KW_SYSTEM))
-		{
-			if (PAR_match(KW_TRIGGERS))
-				sw = show_system_triggers;
-			else if (PAR_match(KW_RELATIONS) || QLI_token->tok_type == tok_eol ||
-				KEYWORD(KW_SEMI) || KEYWORD(KW_FOR))
-			{
-				sw = show_system_relations;
-			}
-			else
-				ERRQ_syntax(215);	// Msg215 RELATIONS or TRIGGERS
-		}
-		else if (PAR_match(KW_PROCEDURES))
-			sw = show_procedures;
-		else if (PAR_match(KW_FILTERS))
-			sw = show_filters;
-		else if (PAR_match(KW_FUNCTIONS))
-			sw = show_functions;
-		else if (PAR_match(KW_GLOBAL))
-		{
-			PAR_real();
-			if (PAR_match(KW_FIELD))
-			{
-				sw = show_global_field;
-				value = (BLK) parse_field_name(0);
-			}
-			else if (PAR_match(KW_FIELDS))
-				sw = show_global_fields;
-		}
-		else if (symbol && symbol->sym_type == SYM_relation)
-		{
-			sw = show_relation;
-			value = symbol->sym_object;
-			PAR_token();
-		}
-		else if (value = (BLK) get_dbb(symbol))
-		{
-			sw = show_database;
-			PAR_token();
-			if (PAR_match(KW_DOT))
-			{
-				if (PAR_match(KW_RELATIONS))
-					sw = show_relations;
-				else if (PAR_match(KW_FIELDS))
-					sw = show_db_fields;
-				else if (PAR_match(KW_INDICES))
-					sw = show_db_indices;
-				else if (PAR_match(KW_SECURITY_CLASS))
-					sw = show_security_class;
-				else if (PAR_match(KW_TRIGGERS))
-					sw = show_triggers;
-				else if (PAR_match(KW_VIEWS))
-					sw = show_views;
-				else if (PAR_match(KW_SECURITY_CLASSES))
-					sw = show_security_classes;
-				else if (PAR_match(KW_SYSTEM))
-				{
-					if (PAR_match(KW_TRIGGERS))
-						sw = show_system_triggers;
-					else if (PAR_match(KW_RELATIONS) || QLI_token->tok_type == tok_eol ||
-						KEYWORD(KW_SEMI) || KEYWORD(KW_FOR))
-					{
-						sw = show_system_relations;
-					}
-					else
-						ERRQ_syntax(215);	// Msg215 RELATIONS or TRIGGERS
-				}
-				else if (PAR_match(KW_PROCEDURES))
-					sw = show_procedures;
-				else if (PAR_match(KW_FILTERS))
-					sw = show_filters;
-				else if (PAR_match(KW_FUNCTIONS))
-					sw = show_functions;
-				else if (PAR_match(KW_GLOBAL))
-				{
-					PAR_real();
-					if (PAR_match(KW_FIELD))
-					{
-						sw = show_global_field;
-						value = (BLK) parse_field_name(0);
-					}
-					else if (PAR_match(KW_FIELDS))
-						sw = show_global_fields;
-				}
-				else
-				{
-					qli_rel* relation =
-						resolve_relation(symbol, QLI_token->tok_symbol);
-					if (relation)
-					{
-						sw = show_relation;
-						value = relation->rel_symbol->sym_object;
-						PAR_token();
-					}
-					else
-					{
-						sw = show_procedure;
-						qli_proc* proc = (qli_proc*) ALLOCD(type_qpr);
-						proc->qpr_database = (qli_dbb*) value;
-						proc->qpr_name = parse_name();
-						value = (BLK) proc;
-					}
-				}
-			}
-		}
-		else
-		{
-			sw = show_procedure;
-			value = (BLK) parse_qualified_procedure();
-		}
-
-		ALLQ_push((blk*) sw, &stack);
-		if (!value && (sw == show_relations || sw == show_views ||sw == show_security_classes ||
-			sw == show_system_triggers || sw == show_system_relations || sw == show_procedures ||
-			sw == show_filters || sw == show_functions || sw == show_global_fields))
-		{
-			if (PAR_match(KW_FOR))
-			{
-				PAR_match(KW_DATABASE);
-				if (value = (BLK) get_dbb(QLI_token->tok_symbol))
-					PAR_token();
-				else
-					ERRQ_syntax(221);	// Msg221 database name
-			}
-		}
-		ALLQ_push(value, &stack);
-		count++;
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	command_end();
-	qli_syntax* node = make_list(stack);
-	node->syn_count = count;
-	node->syn_type = nod_show;
-
-	return node;
-}
-
-
-
-static qli_syntax* parse_sort()
-{
-/**************************************
- *
- *	p a r s e _ s o r t
- *
- **************************************
- *
- * Functional description
- *	Parse a sort list.
- *
- **************************************/
-	USHORT direction = 0;
-	bool sensitive = false;
-	qli_lls* stack = NULL;
-
-	while (true)
-	{
-		PAR_real();
-		if (!sql_flag)
-		{
-			if (PAR_match(KW_ASCENDING))
-			{
-				direction = 0;
-				continue;
-			}
-			if (PAR_match(KW_DESCENDING))
-			{
-				direction = 1;
-				continue;
-			}
-			if (PAR_match(KW_EXACTCASE))
-			{
-				sensitive = false;
-				continue;
-			}
-			if (PAR_match(KW_ANYCASE))
-			{
-				sensitive = true;
-				continue;
-			}
-		}
-		qli_syntax* node;
-		if (sql_flag && QLI_token->tok_type == tok_number)
-		{
-			node = syntax_node(nod_position, 1);
-			node->syn_arg[0] = INT_CAST parse_ordinal();
-		}
-		else
-			node = parse_value(0, 0);
-		if (sensitive)
-		{
-			qli_syntax* upcase = syntax_node(nod_upcase, 1);
-			upcase->syn_arg[0] = node;
-			ALLQ_push((blk*) upcase, &stack);
-		}
-		else
-			ALLQ_push((blk*) node, &stack);
-		if (sql_flag)
-			if (PAR_match(KW_ASCENDING))
-				direction = 0;
-			else if (PAR_match(KW_DESCENDING))
-				direction = 1;
-		ALLQ_push((blk*) (IPTR) direction, &stack);
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	return make_list(stack);
-}
-
-
-static qli_syntax* parse_sql_alter()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ a l t e r
- *
- **************************************
- *
- * Functional description
- *	Parse the leading clauses of a SQL ALTER statement.
- *
- **************************************/
-	PAR_real_token();
-
-	if (!PAR_match(KW_TABLE))
-		ERRQ_syntax(407);		// Msg407 TABLE
-
-	qli_syntax* node = syntax_node(nod_sql_al_table, 2);
-	qli_rel* relation = parse_qualified_relation();
-	node->syn_arg[0] = (qli_syntax*) relation;
-
-	for (;;)
-	{
-	    qli_fld* field;
-		if (PAR_match(KW_ADD))
-		{
-			field = parse_sql_field();
-			field->fld_flags |= FLD_add;
-		}
-		else if (PAR_match(KW_DROP))
-		{
-			field = parse_field(false);
-			field->fld_flags |= FLD_drop;
-		}
-		else
-			ERRQ_syntax(405);	// Msg405 ADD or DROP
-
-		field->fld_next = (qli_fld*) node->syn_arg[1];
-		node->syn_arg[1] = (qli_syntax*) field;
-
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	command_end();
-	return node;
-
-}
-
-
-
-static qli_syntax* parse_sql_create()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ c r e a t e
- *
- **************************************
- *
- * Functional description
- *	Parse the leading clauses of a SQL CREATE statement.
- *
- **************************************/
-	PAR_real_token();
-
-	if (KEYWORD(KW_DATABASE))
-		return parse_ready(nod_sql_database);
-
-	if (KEYWORD(KW_UNIQUE) || KEYWORD(KW_ASCENDING) || KEYWORD(KW_DESCENDING) || KEYWORD(KW_INDEX))
-	{
-		bool unique = false, descending = false;
-		while (true)
-		{
-			if (PAR_match(KW_UNIQUE))
-				unique = true;
-			else if (PAR_match(KW_ASCENDING))
-				descending = false;
-			else if (PAR_match(KW_DESCENDING))
-				descending = true;
-			else if (PAR_match(KW_INDEX))
-				return parse_sql_index_create(unique, descending);
-			else
-				ERRQ_syntax(389);	// Msg389 INDEX
-		}
-	}
-
-	if (PAR_match(KW_TABLE))
-		return parse_sql_table_create();
-
-#ifdef NOT_USED_OR_REPLACED
-	//if (PAR_match (KW_VIEW))
-	//	return parse_sql_view_create();
-#endif
-
-	ERRQ_syntax(386);			// Msg386 object type for CREATE
-	return NULL;
-}
-
-
-static int parse_sql_dtype( USHORT* length, USHORT* scale, USHORT* precision, USHORT* sub_type)
-{
-/**************************************
- *
- *	p a r s e _ s q l _ d t y p e
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL datatype clause.
- *
- **************************************/
-	USHORT dtype = dtype_unknown;
-
-	const kwwords keyword = QLI_token->tok_keyword;
-	PAR_token();
-	*scale = 0;
-	*length = 1;
-	*precision = 0;
-	*sub_type = 0;
-
-	switch (keyword)
-	{
-	case KW_DATE:
-		*length = 8;
-		return dtype_timestamp;
-
-	case KW_CHAR:
-		dtype = dtype_text;
-		break;
-
-	case KW_VARCHAR:
-		dtype = dtype_varying;
-		break;
-
-	case KW_SMALLINT:
-		*length = sizeof(SSHORT);
-		return dtype_short;
-
-	case KW_INTEGER:
-		*length = sizeof(SLONG);
-		return dtype_long;
-
-	case KW_BIGINT:
-		*length = sizeof(SINT64);
-		return dtype_int64;
-
-	case KW_REAL:
-	case KW_FLOAT:
-		*length = sizeof(float);
-		dtype = dtype_real;
-		break;
-
-	case KW_LONG:
-		if (!PAR_match(KW_FLOAT))
-			ERRQ_syntax(388);	// Msg388 "FLOAT"
-		*length = sizeof(double);
-		dtype = dtype_double;
-		break;
-
-	case KW_DOUBLE:
-		if (!PAR_match(KW_PRECISION))
-			ERRQ_syntax(509);   // Msg509 "PRECISION"
-		*length = sizeof(double);
-		dtype = dtype_double;
-		break;
-
-	case KW_DECIMAL:
-		*length = sizeof(SLONG);
-		dtype = dtype_long;
-		*sub_type = dsc_num_type_decimal;
-		break;
-
-	case KW_NUMERIC:
-		*length = sizeof(SLONG);
-		dtype = dtype_long;
-		*sub_type = dsc_num_type_numeric;
-		break;
-	}
-
-	// CVC: SQL doesn't accept arbitrary types with scale specification.
-	//if (dtype == dtype_long || dtype == dtype_real || dtype == dtype_double)
-	if (keyword == KW_DECIMAL || keyword == KW_NUMERIC)
-	{
-		if (PAR_match(KW_LEFT_PAREN))
-		{
-			const USHORT logLength = parse_ordinal();
-			if (logLength < 1)
-				ERRQ_syntax(512);  // Msg512 "Field length should be greater than zero"
-			else if (logLength < 5)
-			{
-				*length = sizeof(SSHORT);
-				dtype = dtype_short;
-			}
-			else if (logLength > 18)
-				ERRQ_syntax(511);  // Msg511 "Field length exceeds allowed range"
-			else if (logLength > 9)
-			{
-				*length = sizeof(SINT64);
-				dtype = dtype_int64;
-			}
-
-			if (PAR_match(KW_COMMA))
-			{
-				const bool l = PAR_match(KW_MINUS) ? true : false;
-				*scale = parse_ordinal();
-				if (*scale > logLength)
-					ERRQ_syntax(510);  // Msg510 "Field scale exceeds allowed range"
-
-				if (l || *scale > 0) // We need to have it negative in system tables.
-					*scale = -(*scale);
-			}
-
-			*precision = logLength;
-			parse_matching_paren();
-		}
-	}
-	else if (dtype == dtype_text || dtype == dtype_varying)
-	{
-		if (PAR_match(KW_LEFT_PAREN))
-		{
-			USHORT l = parse_ordinal();
-			if (l > MAX_COLUMN_SIZE)
-				ERRQ_syntax(511);  // Msg511 "Field length exceeds allowed range"
-			if (dtype == dtype_varying)
-			{
-				if (l > MAX_COLUMN_SIZE - sizeof(SSHORT))
-					ERRQ_syntax(511);  // Msg511 "Field length exceeds allowed range"
-				l += sizeof(SSHORT);
-			}
-			*length = l;
-			parse_matching_paren();
-		}
-	}
-
-	return dtype;
-}
-
-
-static qli_fld* parse_sql_field()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Parse a field description.
- *
- **************************************/
-	PAR_real();
-
-    USHORT dtype, length, scale, precision, sub_type;
-	dtype = length = scale = precision = sub_type = 0;
-	qli_symbol* name = parse_symbol();
-
-	PAR_real();
-	switch (QLI_token->tok_keyword)
-	{
-	case KW_DOUBLE:
-		PAR_match(KW_PRECISION);
-	case KW_NUMERIC:
-	case KW_REAL:
-	case KW_DATE:
-	case KW_CHAR:
-	case KW_VARCHAR:
-	case KW_SMALLINT:
-	case KW_INTEGER:
-	case KW_FLOAT:
-	case KW_LONG:
-	case KW_DECIMAL:
-	case KW_BIGINT:
-		dtype = parse_sql_dtype(&length, &scale, &precision, &sub_type);
-		break;
-
-	default:
-		ERRQ_syntax(179);		// Msg179 field definition clause
-		break;
-	}
-
-	qli_fld* field = (qli_fld*) ALLOCDV(type_fld, length);
-	field->fld_name = name;
-	field->fld_dtype = dtype;
-	field->fld_scale = scale;
-	field->fld_length = length;
-	field->fld_precision = precision;
-	field->fld_sub_type = sub_type;
-
-	if (PAR_match(KW_NOT))
-		if (PAR_match(KW_NULL)) {
-			field->fld_flags |= FLD_not_null;
-		}
-		else {
-			ERRQ_syntax(393);	// Msg393 NULL
-		}
-
-	return field;
-}
-
-
-static qli_syntax* parse_sql_grant_revoke(const nod_t type)
-{
-/**************************************
- *
- *	p a r s e _ s q l _ g r a n t _ r e v o k e
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL GRANT/REVOKE statement.
- *
- **************************************/
-	PAR_real_token();
-	qli_syntax* node = syntax_node(type, s_grant_count);
-	qli_lls* stack = NULL;
-	USHORT privileges = 0;
-
-	if (PAR_match(KW_ALL))
-	{
-		PAR_match(KW_PRIVILEGES);
-		privileges |= PRV_all;
-	}
-	else
-	{
-		while (true)
-		{
-			PAR_real();
-			if (PAR_match(KW_SELECT))
-			{
-				privileges |= PRV_select;
-				continue;
-			}
-			if (PAR_match(KW_INSERT))
-			{
-				privileges |= PRV_insert;
-				continue;
-			}
-			if (PAR_match(KW_DELETE))
-			{
-				privileges |= PRV_delete;
-				continue;
-			}
-			if (PAR_match(KW_UPDATE))
-			{
-				privileges |= PRV_update;
-
-				if (PAR_match(KW_COMMA))
-					continue;
-
-				if (KEYWORD(KW_ON))
-					break;
-
-				if (!PAR_match(KW_LEFT_PAREN))
-					ERRQ_syntax(187);	// Msg187 left parenthesis
-
-				do {
-					if (KEYWORD(KW_SELECT) || KEYWORD(KW_INSERT) ||
-						KEYWORD(KW_DELETE) || KEYWORD(KW_UPDATE))
-					{
-						break;
-					}
-					PAR_real();
-					ALLQ_push((blk*) parse_name(), &stack);
-
-				} while (PAR_match(KW_COMMA));
-
-				if (!PAR_match(KW_RIGHT_PAREN))
-					ERRQ_syntax(191);	// Msg191 right parenthesis
-
-				continue;
-			}
-
-			if (!PAR_match(KW_COMMA))
-				break;
-		}
-	}
-
-	node->syn_arg[s_grant_fields] = make_list(stack);
-
-	PAR_real();
-	if (!PAR_match(KW_ON))
-		ERRQ_syntax(397);		// Msg397 ON
-
-	PAR_real();
-	if (!(node->syn_arg[s_grant_relation] = (qli_syntax*) parse_qualified_relation()))
-		ERRQ_syntax(170);		// Msg170 relation name
-
-	if (type == nod_sql_grant)
-	{
-		if (!PAR_match(KW_TO))
-			ERRQ_syntax(404);	// Msg404 TO
-	}
-	else
-	{
-		if (!PAR_match(KW_FROM))
-			ERRQ_syntax(403);	// Msg403 FROM
-	}
-
-	stack = NULL;
-
-	while (true)
-	{
-		PAR_real();
-		ALLQ_push((blk*) parse_name(), &stack);
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	node->syn_arg[s_grant_users] = make_list(stack);
-
-	if (type == nod_sql_grant)
-		if (PAR_match(KW_WITH))
-		{
-			PAR_real();
-			if (!PAR_match(KW_GRANT))
-				ERRQ_syntax(401);	// Msg401 GRANT
-			PAR_match(KW_OPTION);
-			privileges |= PRV_grant_option;
-		}
-
-	node->syn_arg[s_grant_privileges] = INT_CAST privileges;
-
-	return node;
-}
-
-
-static qli_syntax* parse_sql_index_create(const bool unique, const bool descending)
-{
-/**************************************
- *
- *	p a r s e _ s q l _ i n d e x _ c r e a t e
- *
- **************************************
- *
- * Functional description
- *	Parse the SQL CREATE INDEX statement.
- *
- **************************************/
-	PAR_real();
-	qli_syntax* node = syntax_node(nod_def_index, s_dfi_count);
-
-	if (unique)
-		node->syn_flags |= s_dfi_flag_unique;
-	if (descending)
-		node->syn_flags |= s_dfi_flag_descending;
-
-	node->syn_arg[s_dfi_name] = (qli_syntax*) parse_symbol();
-
-	PAR_real();
-	if (!PAR_match(KW_ON))
-		ERRQ_syntax(397);		// Msg397 ON
-
-	if (!(node->syn_arg[s_dfi_relation] = (qli_syntax*) parse_qualified_relation()))
-		ERRQ_syntax(170);		// Msg170 relation name
-
-	PAR_real();
-
-	if (!PAR_match(KW_LEFT_PAREN))
-		ERRQ_syntax(185);		// Msg185 left parenthesis
-
-	qli_lls* stack = NULL;
-
-	for (;;)
-	{
-		ALLQ_push((blk*) parse_name(), &stack);
-		if (PAR_match(KW_RIGHT_PAREN))
-			break;
-		if (!PAR_match(KW_COMMA))
-			ERRQ_syntax(171);	// Msg171 comma between field definitions
-	}
-
-	node->syn_arg[s_dfi_fields] = make_list(stack);
-
-	command_end();
-
-	return node;
-}
-
-
-static qli_syntax* parse_sql_joined_relation() //( qli_syntax* prior_context)
-{
-/**************************************
- *
- *	p a r s e _ s q l _ j o i n e d _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse a join relation clause.
- *
- **************************************/
-	qli_syntax* left;
-
-	if (PAR_match(KW_LEFT_PAREN))
-	{
-		left = parse_sql_joined_relation(); // (0)
-		parse_matching_paren();
-	}
-	else if (!(left = parse_sql_relation()))
-		return NULL;
-
-	return parse_sql_join_clause(left);
-}
-
-
-static qli_syntax* parse_sql_join_clause( qli_syntax* left)
-{
-/**************************************
- *
- *	p a r s e _ s q l _ j o i n _ c l a u s e
- *
- **************************************
- *
- * Functional description
- *	Parse a join relation clause.
- *
- **************************************/
-	const nod_t join_type = parse_join_type();
-	if (join_type == nod_nothing)
-		return left;
-
-	qli_syntax* right = parse_sql_joined_relation(); //(left);
-	if (!right)
-		ERRQ_syntax(490);		// Msg490 joined relation clause
-
-	if (!PAR_match(KW_ON))
-		ERRQ_syntax(492);		// Msg492 ON
-
-	qli_syntax* node = syntax_node(nod_rse, (int) s_rse_count + 2 * 2);
-	node->syn_count = 2;
-	node->syn_arg[s_rse_count] = left;
-	node->syn_arg[s_rse_count + 2] = right;
-	node->syn_arg[s_rse_join_type] = (qli_syntax*) join_type;
-	node->syn_arg[s_rse_boolean] = parse_boolean(0);
-
-	return parse_sql_join_clause(node);
-}
-
-
-static qli_syntax* parse_sql_table_create()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ t a b l e _ c r e a t e
- *
- **************************************
- *
- * Functional description
- *	Parse the SQL CREATE TABLE statement.
- *
- **************************************/
-	PAR_real();
-	qli_syntax* node = syntax_node(nod_sql_cr_table, 1);
-	qli_rel* relation = (qli_rel*) ALLOCD(type_rel);
-	node->syn_arg[0] = (qli_syntax*) relation;
-	relation->rel_database = parse_database();
-	relation->rel_symbol = parse_symbol();
-
-	qli_fld** ptr = &relation->rel_fields;
-
-	if (!PAR_match(KW_LEFT_PAREN))
-		ERRQ_syntax(185);		// Msg185 left parenthesis
-
-	PAR_real();
-
-	for (;;)
-	{
-	    qli_fld* field = parse_sql_field();
-		*ptr = field;
-		ptr = &field->fld_next;
-		if (PAR_match(KW_RIGHT_PAREN))
-			break;
-		if (!PAR_match(KW_COMMA))
-			ERRQ_syntax(171);	// Msg171 comma between field definitions
-	}
-
-	command_end();
-
-	return node;
-}
-
-#ifdef NOT_USED_OR_REPLACED
-static qli_syntax* parse_sql_view_create()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ v i e w _ c r e a t e
- *
- **************************************
- *
- * Functional description
- *	Parse the SQL CREATE VIEW statement.
- *
- **************************************/
-	PAR_real();
-
-	sw_sql_view = true;
-	qli_syntax* node = syntax_node(nod_sql_cr_view, s_crv_count);
-	qli_lls* stack = NULL;
-
-	qli_rel* relation = (qli_rel*) ALLOCD(type_rel);
-	node->syn_arg[s_crv_name] = (qli_syntax*) relation;
-	relation->rel_database = parse_database();
-	relation->rel_symbol = parse_symbol();
-
-	// if field list is present parse it and create corresponding field blocks
-
-	if (PAR_match(KW_LEFT_PAREN))
-	{
-		for (;;)
-		{
-			ALLQ_push(parse_name(), &stack);
-			if (PAR_match(KW_RIGHT_PAREN))
-				break;
-			if (!PAR_match(KW_COMMA))
-				ERRQ_syntax(171);	// Msg171 comma between field definitions
-		}
-	}
-
-	// node->syn_arg [s_crv_fields] = make_list (stack);
-
-	if (!PAR_match(KW_AS))
-		ERRQ_syntax(394);		// Msg394 As
-
-	if (!KEYWORD(KW_SELECT))
-		ERRQ_syntax(395);		// Msg395 Select
-
-	node->syn_arg[s_crv_rse] = parse_select();
-
-	sw_sql_view = false;
-
-	return node;
-}
-#endif
-
-static qli_syntax* parse_sql_relation()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL relation clause.
- *
- **************************************/
-	qli_syntax* node = syntax_node(nod_relation, s_rel_count);
-
-	if (!(node->syn_arg[s_rel_relation] = (qli_syntax*) parse_qualified_relation()))
-		ERRQ_syntax(223);		// Msg223 relation name
-
-	if (!QLI_token->tok_symbol)
-		node->syn_arg[s_rel_context] = (qli_syntax*) parse_symbol();
-
-	return node;
-}
-
-
-static qli_syntax* parse_sql_rse()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ r s e
- *
- **************************************
- *
- * Functional description
- *	Parse the trailing clauses of a SQL SELECT statement.
- *
- **************************************/
-	qli_lls* stack = NULL;
-	USHORT count = 0;
-	PAR_real();
-
-	if (!PAR_match(KW_FROM))
-		ERRQ_syntax(224);		// Msg224 FROM clause
-
-	// Parse FROM list of relations
-
-	while (true)
-	{
-		count++;
-		ALLQ_push((blk*) parse_sql_joined_relation(/*0*/), &stack);
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	// Build a syntax node.  Since SQL doesn't support OVER, only every
-	// other slot will be used in the RSE.
-
-	qli_syntax* node = syntax_node(nod_rse, (int) s_rse_count + 2 * count);
-	node->syn_count = count;
-	qli_syntax** ptr = &node->syn_arg[(int) s_rse_count + 2 * count];
-
-	while (stack)
-	{
-		--ptr;
-		*--ptr = (qli_syntax*) ALLQ_pop(&stack);
-	}
-
-	if (PAR_match(KW_WITH))
-		node->syn_arg[s_rse_boolean] = parse_boolean(0);
-
-	if (PAR_match(KW_GROUP))
-	{
-		if (sw_sql_view)
-			ERRQ_syntax(391);	// Msg391 No group by in view def
-		PAR_real();
-		PAR_match(KW_BY);
-		stack = NULL;
-		while (true)
-		{
-			ALLQ_push((blk*) parse_udf_or_field(), &stack);
-			if (!PAR_match(KW_COMMA))
-				break;
-		}
-		node->syn_arg[s_rse_group_by] = make_list(stack);
-		if (PAR_match(KW_HAVING))
-			node->syn_arg[s_rse_having] = parse_boolean(0);
-	}
-
-	return node;
-}
-
-
-static qli_syntax* parse_sql_singleton_select()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ s i n g l e t o n _ s e l e c t
- *
- **************************************
- *
- * Functional description
- *	Finish parsing an SQL singleton select and
- *	turn it into a FIRST ... FROM --- not exactly
- *	kosher, but a start.
- *
- **************************************/
-	qli_syntax* value = parse_primitive_value(0, 0);
-	PAR_real();
-
-	qli_syntax* node = syntax_node(nod_from, s_stt_count);
-	node->syn_arg[s_stt_value] = value;
-
-	node->syn_arg[s_stt_rse] = parse_sql_rse();
-	--sql_flag; // The increment was done in parse_sql_subquery, the only caller.
-
-	return node;
-}
-
-
-static qli_syntax* parse_sql_subquery()
-{
-/**************************************
- *
- *	p a r s e _ s q l _ s u b q u e r y
- *
- **************************************
- *
- * Functional description
- *	Parse an sql subquery that should
- *	return a single value.
- *
- **************************************/
-	if (sw_sql_view)
-		ERRQ_syntax(392);		// Msg392 No aggregates in view def
-
-	PAR_token();
-
-	const kwwords keyword = next_keyword();
-	++sql_flag;
-
-	const nod_types* ntypes;
-	const nod_types* const endtypes = statisticals + FB_NELEM(statisticals);
-	for (ntypes = statisticals; ntypes < endtypes; ntypes++)
-	{
-		if (ntypes->nod_t_keyword == KW_none)
-			return parse_sql_singleton_select();
-		if (ntypes->nod_t_keyword == keyword)
-			break;
-	}
-
-	fb_assert(ntypes < endtypes);
-	if (ntypes >= endtypes)
-	    return NULL;
-
-	PAR_token();
-	qli_syntax* node = syntax_node(ntypes->nod_t_node, s_stt_count);
-
-	PAR_match(KW_LEFT_PAREN);
-
-	if (node->syn_type != nod_count || !PAR_match(KW_ASTERISK))
-	{
-		if (PAR_match(KW_DISTINCT))
-			node->syn_arg[s_prt_distinct] = INT_CAST TRUE;
-		node->syn_arg[s_stt_value] = parse_value(0, 0);
-	}
-
-	parse_matching_paren();
-
-	node->syn_arg[s_stt_rse] = parse_sql_rse();
-	--sql_flag;
-
-	return node;
-}
-
-
-static qli_syntax* parse_statement()
-{
-/**************************************
- *
- *	p a r s e _ s t a t e m e n t
- *
- **************************************
- *
- * Functional description
- *	Parse a statement.  (Set statement switch
- *	to true here as well as in PARQ_parse to
- *	avoid confusion with linked statements
- *	e.g. THEN conjuncts )
- *
- **************************************/
-	qli_syntax* node;
-
-	PAR_real();
-	sw_statement = true;
-	function_count = 0;
-
-	switch (next_keyword())
-	{
-	case KW_ABORT:
-		node = parse_abort();
-		break;
-
-	case KW_ACCEPT:
-		node = parse_accept();
-		break;
-
-	case KW_COMMIT:
-		node = parse_transaction(nod_commit_retaining);
-		break;
-
-	case KW_DECLARE:
-		node = parse_declare();
-		break;
-
-	case KW_DELETE:
-		PAR_match(KW_DELETE);
-		node = parse_delete();
-		break;
-
-	case KW_ERASE:
-		node = parse_erase();
-		break;
-
-	case KW_FOR:
-		node = parse_for();
-		break;
-
-	case KW_IF:
-		node = parse_if();
-		break;
-
-	case KW_INSERT:
-		node = parse_insert();
-		break;
-
-	case KW_LIST:
-		node = parse_list_fields();
-		break;
-
-	case KW_MODIFY:
-		node = parse_modify();
-		break;
-
-	case KW_PRINT:
-		node = parse_print();
-		break;
-
-	case KW_REPEAT:
-		node = parse_repeat();
-		break;
-
-	case KW_REPORT:
-		node = parse_report();
-		break;
-
-	case KW_SELECT:
-		node = parse_select();
-		break;
-
-	case KW_STORE:
-		node = parse_store();
-		break;
-
-	case KW_UPDATE:
-		node = parse_update();
-		break;
-
-	case KW_BEGIN:
-	    {
-			qli_lls* stack = NULL;
-			PAR_token();
-			while (true)
-			{
-				PAR_real();
-				if (PAR_match(KW_END))
-					break;
-				ALLQ_push((blk*) parse_statement(), &stack);
-				PAR_match(KW_SEMI);
-			}
-			node = make_list(stack);
-		}
-		break;
-
-	default:
-		node = parse_assignment();
-	}
-
-	check_end();
-
-	// Check for the "THEN" connective.  If found, make a list of statements.
-
-	if (QLI_token->tok_type != tok_eol || (QLI_semi && !KEYWORD(KW_SEMI)))
-		PAR_match(KW_SEMI);
-
-	if (!PAR_match(KW_THEN))
-		return node;
-
-	qli_lls* stack = NULL;
-	ALLQ_push((blk*) node, &stack);
-	ALLQ_push((blk*) parse_statement(), &stack);
-
-	return make_list(stack);
-}
-
-
-static qli_syntax* parse_statistical()
-{
-/**************************************
- *
- *	p a r s e _ s t a t i s t i c a l
- *
- **************************************
- *
- * Functional description
- *	Parse statistical expression.
- *
- **************************************/
-	const kwwords keyword = next_keyword();
-	PAR_token();
-
-	const nod_types* ntypes;
-	const nod_types* const endtypes = statisticals + FB_NELEM(statisticals);
-	for (ntypes = statisticals; ntypes < endtypes; ntypes++)
-		if (ntypes->nod_t_keyword == keyword)
-			break;
-
-	fb_assert(ntypes < endtypes);
-	if (ntypes >= endtypes)
-	    return NULL;
-
-	// Handle SQL statisticals a little differently
-
-	if (sql_flag)
-	{
-		qli_syntax* anode = syntax_node(ntypes->nod_t_sql_node, s_stt_count);
-		if (!PAR_match(KW_LEFT_PAREN))
-			ERRQ_syntax(227);	// Msg227 left parenthesis
-		if (anode->syn_type != nod_agg_count || !PAR_match(KW_ASTERISK))
-		{
-			if (PAR_match(KW_DISTINCT))
-				anode->syn_arg[s_prt_distinct] = INT_CAST TRUE;
-			anode->syn_arg[s_stt_value] = parse_value(0, 0);
-		}
-		parse_matching_paren();
-		return anode;
-	}
-
-	// Handle GDML statisticals
-
-	qli_syntax* node = syntax_node(ntypes->nod_t_node, s_stt_count);
-
-	if (node->syn_type != nod_count)
-		node->syn_arg[s_stt_value] = parse_value(0, 0);
-
-	if (!PAR_match(KW_OF))
-	{
-		if (sw_report)
-		{
-			if (function_count > 0)
-				IBERROR(487);	// Msg487 Invalid argument for UDF
-			node->syn_type = ntypes->nod_t_rpt_node;
-			return node;
-		}
-		PAR_real();
-		if (!PAR_match(KW_OF))
-			ERRQ_syntax(228);	// Msg 228 OF
-	}
-
-	node->syn_arg[s_stt_rse] = parse_rse();
-
-	return node;
-}
-
-
-static qli_syntax* parse_store()
-{
-/**************************************
- *
- *	p a r s e _ s t o r e
- *
- **************************************
- *
- * Functional description
- *	Parse a STORE statement.
- *
- **************************************/
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_store, s_sto_count);
-	node->syn_arg[s_sto_relation] = parse_relation();
-
-	if (test_end())
-		return node;
-
-	PAR_match(KW_USING);
-
-	node->syn_arg[s_sto_statement] = parse_statement();
-
-	return node;
-}
-
-
-static TEXT* parse_string()
-{
-/**************************************
- *
- *	p a r s e _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Save the current token as a string, advance to the next
- *	token, and return a pointer to the string.
- *
- **************************************/
-	TEXT* string = make_string(QLI_token->tok_string, QLI_token->tok_length);
-	PAR_token();
-
-	return string;
-}
-
-
-static qli_symbol* parse_symbol()
-{
-/**************************************
- *
- *	p a r s e _ s y m b o l
- *
- **************************************
- *
- * Functional description
- *	Parse the next token as a context symbol.
- *
- **************************************/
-	USHORT l = QLI_token->tok_length;
-	qli_symbol* context = (qli_symbol*) ALLOCDV(type_sym, l);
-	context->sym_type = SYM_context;
-	context->sym_length = l;
-	const TEXT* q = QLI_token->tok_string;
-	context->sym_string = context->sym_name;
-	TEXT* p = context->sym_name;
-
-	if (l)
-		do {
-			const TEXT c = *q++;
-			*p++ = UPPER(c);
-		} while (--l);
-
-	PAR_token();
-
-	return context;
-}
-
-
-static void parse_terminating_parens( USHORT * paren_count, USHORT * local_count)
-{
-/**************************************
- *
- *	p a r s e _ t e r m i n a t i n g _ p a r e n s
- *
- **************************************
- *
- * Functional description
- *	Check for balancing parenthesis.  If missing, barf.
- *
- **************************************/
-
-	if (*paren_count && paren_count == local_count)
-		do {
-			parse_matching_paren();
-		} while (--(*paren_count));
-}
-
-
-static qli_syntax* parse_transaction( nod_t node_type)
-{
-/**************************************
- *
- *	p a r s e _ t r a n s a c t i o n
- *
- **************************************
- *
- * Functional description
- *	Parse the FINISH, COMMIT, ROLLBACK,
- *	and PREPARE commands and the COMMIT statement.
- *
- **************************************/
-	qli_lls* stack = NULL;
-	PAR_token();
-
-	if (!KEYWORD(KW_SEMI))
-		while (true)
-		{
-		    qli_symbol* symbol;
-			for (symbol = QLI_token->tok_symbol; symbol; symbol = symbol->sym_homonym)
-			{
-				if (symbol->sym_type == SYM_database)
-					break;
-			}
-			if (!symbol)
-				ERRQ_syntax(229);	// Msg229 database name
-			ALLQ_push(symbol->sym_object, &stack);
-			PAR_token();
-			if (!PAR_match(KW_COMMA))
-				break;
-		}
-
-	command_end();
-	qli_syntax* node = make_list(stack);
-	node->syn_type = node_type;
-
-	return node;
-}
-
-
-static qli_syntax* parse_udf_or_field()
-{
-/**************************************
- *
- *	p a r s e _ u d f _ o r _ f i e l d
- *
- **************************************
- *
- * Functional description
- *	Parse a function or field reference.
- *
- **************************************/
-	const qli_symbol* symbol = QLI_token->tok_symbol;
-
-	if (symbol && symbol->sym_type == SYM_function)
-		return parse_function();
-
-	return parse_field_name(0);
-}
-
-
-static qli_syntax* parse_update()
-{
-/**************************************
- *
- *	p a r s e _ u p d a t e
- *
- **************************************
- *
- * Functional description
- *	Parse a SQL UPDATE statement.
- *
- **************************************/
-	++sql_flag;
-	PAR_token();
-	qli_syntax* node = syntax_node(nod_modify, s_mod_count);
-	qli_syntax* rse = syntax_node(nod_rse, (int) s_rse_count + 2);
-	node->syn_arg[s_mod_rse] = rse;
-	rse->syn_count = 1;
-	rse->syn_arg[s_rse_count] = parse_sql_relation();
-
-	if (!PAR_match(KW_SET))
-		ERRQ_syntax(230);		// Msg230 SET
-
-	// Pick up assignments
-
-	qli_lls* stack = NULL;
-
-	while (true)
-	{
-		ALLQ_push((blk*) parse_assignment(), &stack);
-		if (!PAR_match(KW_COMMA))
-			break;
-	}
-
-	// Pick up boolean, if present
-
-	if (PAR_match(KW_WITH))
-		rse->syn_arg[s_rse_boolean] = parse_boolean(0);
-
-	node->syn_arg[s_mod_statement] = make_list(stack);
-	--sql_flag;
-
-	return node;
-}
-
-
-static qli_syntax* parse_value( USHORT* paren_count, bool* bool_flag)
-{
-/**************************************
- *
- *	p a r s e _ v a l u e
- *
- **************************************
- *
- * Functional description
- *	Parse a general value expression.  In practice, this means parse the
- *	lowest precedence operator CONCATENATE.
- *
- **************************************/
-	USHORT local_count;
-
-	if (!paren_count)
-	{
-		local_count = 0;
-		paren_count = &local_count;
-	}
-
-	bool local_flag;
-	if (!bool_flag)
-	{
-		local_flag = false;
-		bool_flag = &local_flag;
-	}
-
-	qli_syntax* node = parse_add(paren_count, bool_flag);
-
-	while (true)
-	{
-		if (!PAR_match(KW_BAR))
-		{
-			parse_terminating_parens(paren_count, &local_count);
-			return node;
-		}
-		qli_syntax* arg = node;
-		node = syntax_node(nod_concatenate, 2);
-		node->syn_arg[0] = arg;
-		node->syn_arg[1] = parse_add(paren_count, bool_flag);
-	}
-}
-
-
-static bool potential_rse()
-{
-/**************************************
- *
- *	p o t e n t i a l _ r s e
- *
- **************************************
- *
- * Functional description
- *	Test to see if the current token is likely (sic!) to be part of
- *	a record selection expression.
- *
- **************************************/
-	for (const qli_symbol* symbol = QLI_token->tok_symbol; symbol; symbol = symbol->sym_homonym)
-	{
-		if ((symbol->sym_type == SYM_keyword && symbol->sym_keyword == KW_FIRST) ||
-			symbol->sym_type == SYM_relation || symbol->sym_type == SYM_database)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-static qli_rel* resolve_relation( const qli_symbol* db_symbol, qli_symbol* relation_symbol)
-{
-/**************************************
- *
- *	r e s o l v e _ r e l a t i o n
- *
- **************************************
- *
- * Functional description
- *	Given symbols for a database and a relation (either may be null),
- *	resolve the relation.  If the relation can't be resolved, return
- *	NULL (don't error!).
- *
- **************************************/
-
-	// If we don't recognize the relation, punt.
-
-	if (!relation_symbol)
-		return NULL;
-
-	// If a database symbol is present, resolve the relation against the
-	// the given database.
-
-	if (db_symbol)			// && db_symbol->sym_type == SYM_database ?
-	{
-		for (; db_symbol; db_symbol = db_symbol->sym_homonym)
-		{
-			for (qli_symbol* temp = relation_symbol; temp; temp = temp->sym_homonym)
-				if (temp->sym_type == SYM_relation)
-				{
-					qli_rel* relation = (qli_rel*) temp->sym_object;
-					if (relation->rel_database == (qli_dbb*) db_symbol->sym_object)
-						return relation;
-				}
-		}
-		return NULL;
-	}
-
-	// No database qualifier, so search all databases.
-
-	for (qli_dbb* dbb = QLI_databases; dbb; dbb = dbb->dbb_next)
-	{
-		for (qli_symbol* temp = relation_symbol; temp; temp = temp->sym_homonym)
-			if (temp->sym_type == SYM_relation)
-			{
-				qli_rel* relation = (qli_rel*) temp->sym_object;
-				if (relation->rel_database == dbb)
-					return relation;
-			}
-	}
-
-	return NULL;
-}
-
-
-static qli_syntax* syntax_node( nod_t type, USHORT count)
-{
-/**************************************
- *
- *	s y n t a x _ n o d e
- *
- **************************************
- *
- * Functional description
- *	Allocate and initialize a syntax node of given type.
- *
- **************************************/
-	qli_syntax* node = (qli_syntax*) ALLOCDV(type_syn, count);
-	node->syn_type = type;
-	node->syn_count = count;
-
-	return node;
-}
-
-
-static bool test_end()
-{
-/**************************************
- *
- *	t e s t _ e n d
- *
- **************************************
- *
- * Functional description
- *	Test for end of a statement.  In specific, test for one of
- *	THEN, ELSE, ON, or a semi-colon.
- *
- **************************************/
-
-	if (KEYWORD(KW_THEN) || KEYWORD(KW_ON) || KEYWORD(KW_ELSE) || KEYWORD(KW_SEMI))
-	{
-		return true;
-	}
-
-	return false;
-}
diff --git a/src/qli/parse.h b/src/qli/parse.h
deleted file mode 100644
index 495a518a7f..0000000000
--- a/src/qli/parse.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		par.h
- *	DESCRIPTION:	Parser definitions
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_PARSE_H
-#define QLI_PARSE_H
-
-#include <stdio.h>
-
-const int MAXSYMLEN	= 256;
-
-// Keywords
-
-enum kwwords {
-    KW_none = 0,
-#include "../qli/symbols.h"
-    KW_continuation
-};
-
-// Token block, used to hold a lexical token.
-
-enum tok_t {
-    tok_ident,
-    tok_number,
-    tok_quoted,
-    tok_punct,
-    tok_eol,
-    tok_eof
-};
-
-struct qli_tok
-{
-    blk			tok_header;
-    tok_t		tok_type;		// type of token
-    qli_symbol*	tok_symbol;		// hash block if recognized
-    kwwords		tok_keyword;	// keyword number, if recognized
-    SLONG		tok_position;	// byte number in input stream
-    USHORT		tok_length;
-    //qli_tok*	tok_next;
-    //qli_tok*	tok_prior;
-    TEXT		tok_string [2];
-};
-
-// Input line control
-
-enum line_t {
-    line_stdin,
-    line_blob,
-    line_file,
-    line_string
-    //, line_edit
-};
-
-struct qli_line
-{
-    blk			line_header;
-    qli_line*	line_next;
-    qli_dbb*	line_database;
-    USHORT		line_size;
-    USHORT		line_length;
-    TEXT*		line_ptr;
-    SLONG		line_position;
-    FB_API_HANDLE line_source_blob;			// Blob handle
-	FILE*		line_source_file;			// File handle
-	line_t		line_type;
-    TEXT		line_data[256];
-    TEXT		line_source_name[2];
-};
-
-#endif // QLI_PARSE_H
-
diff --git a/src/qli/parse_proto.h b/src/qli/parse_proto.h
deleted file mode 100644
index 6c6a32c327..0000000000
--- a/src/qli/parse_proto.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		parse_proto.h
- *	DESCRIPTION:	Prototype header file for parse.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_PARSE_PROTO_H
-#define QLI_PARSE_PROTO_H
-
-qli_syntax*	PARQ_parse();
-bool	PAR_match (kwwords);
-void	PAR_real ();
-void	PAR_real_token ();
-void	PAR_token ();
-
-#endif // QLI_PARSE_PROTO_H
-
diff --git a/src/qli/picst_proto.h b/src/qli/picst_proto.h
deleted file mode 100644
index 82ba330f67..0000000000
--- a/src/qli/picst_proto.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		picst_proto.h
- *	DESCRIPTION:	Prototype header file for picstr.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_PICST_PROTO_H
-#define QLI_PICST_PROTO_H
-
-pics*	PIC_analyze(const TEXT*, const dsc*);
-void	PIC_edit(const dsc*, pics*, TEXT**, USHORT);
-void	PIC_missing(qli_const*, pics*);
-
-#endif // QLI_PICST_PROTO_H
-
diff --git a/src/qli/picstr.cpp b/src/qli/picstr.cpp
deleted file mode 100644
index da15f20ba6..0000000000
--- a/src/qli/picstr.cpp
+++ /dev/null
@@ -1,1204 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		picstr.cpp
- *	DESCRIPTION:	Picture String Handler
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <cmath>
-#include <stdio.h>
-#include <string.h>
-
-#include "../qli/dtr.h"
-#include "../qli/exe.h"
-#include "../qli/format.h"
-#include "../qli/all_proto.h"
-#include "../qli/err_proto.h"
-#include "../qli/picst_proto.h"
-#include "../qli/mov_proto.h"
-#include "../common/classes/timestamp.h"
-#include "../common/classes/VaryStr.h"
-#include "../yvalve/gds_proto.h"
-#include "../common/classes/FpeControl.h"
-
-const int PRECISION	= 10000;
-
-static TEXT* cvt_to_ascii(SLONG, TEXT*, int);
-static const TEXT* default_edit_string(const dsc*, TEXT*);
-static void edit_alpha(const dsc*, pics*, TEXT**, USHORT);
-static void edit_date(const dsc*, pics*, TEXT**);
-static void edit_float(const dsc*, pics*, TEXT**);
-static void edit_numeric(const dsc*, pics*, TEXT**);
-static int generate(pics*);
-static void literal(pics*, TEXT, TEXT**);
-
-static const TEXT* alpha_weekdays[] =
-{
-	"Sunday",
-	"Monday",
-	"Tuesday",
-	"Wednesday",
-	"Thursday",
-	"Friday",
-	"Saturday"
-};
-
-static const TEXT* alpha_months[] =
-{
-	"January",
-	"February",
-	"March",
-	"April",
-	"May",
-    "June",
-	"July",
-	"August",
-	"September",
-	"October",
-	"November",
-	"December"
-};
-
-
-pics* PIC_analyze(const TEXT* string, const dsc* desc)
-{
-/**************************************
- *
- *	P I C _ a n a l y z e
- *
- **************************************
- *
- * Functional description
- *	Analyze a picture in preparation for formatting.
- *
- **************************************/
-	if (!string)
-	{
-		if (!desc)
-			return NULL;
-
-		string = default_edit_string(desc, NULL);
-	}
-
-	pics* picture = (pics*) ALLOCD(type_pic);
-	picture->pic_string = picture->pic_pointer = string;
-
-	// Make a first pass just counting characters
-
-	bool debit = false;
-	TEXT c;
-	while ((c = generate(picture)) && c != '?')
-	{
-
-		c = UPPER(c);
-		switch (c)
-		{
-		case 'X':
-		case 'A':
-			++picture->pic_chars;
-			break;
-
-		case '9':
-		case 'Z':
-		case '*':
-			// Count all digits;
-			// count them as fractions only after a decimal pt and
-			// before an E
-			++picture->pic_digits;
-			if (picture->pic_decimals && !picture->pic_exponents)
-				++picture->pic_fractions;
-			break;
-
-		case 'H':
-			++picture->pic_hex_digits;
-			break;
-
-		case '.':
-			++picture->pic_decimals;
-			break;
-
-		case '-':
-		case '+':
-			picture->pic_flags |= PIC_signed;
-		case '$':
-			if (picture->pic_chars || picture->pic_exponents)
-				++picture->pic_literals;
-			else if (picture->pic_floats)
-				++picture->pic_digits;
-			else
-				++picture->pic_floats;
-			break;
-
-		case 'M':
-			++picture->pic_months;
-			break;
-
-		case 'D':
-			// DB is ambiguous, could be Day Blank or DeBit...
-			if (UPPER(*picture->pic_pointer) == 'B')
-			{
-				++picture->pic_pointer;
-				++picture->pic_literals;
-				debit = true;
-			}
-			++picture->pic_days;
-			break;
-
-		case 'Y':
-			++picture->pic_years;
-			break;
-
-		case 'J':
-			++picture->pic_julians;
-			break;
-
-		case 'W':
-			++picture->pic_weekdays;
-			break;
-
-		case 'N':
-			++picture->pic_nmonths;
-			break;
-
-		case 'E':
-			++picture->pic_exponents;
-			break;
-
-		case 'G':
-			++picture->pic_float_digits;
-			break;
-
-		case '(':
-		case ')':
-			picture->pic_flags |= PIC_signed;
-			++picture->pic_brackets;
-			break;
-
-		case '\'':
-		case '"':
-			picture->pic_flags |= PIC_literal;
-			{
-				TEXT d;
-				// Shouldn't UPPER be used on d before comparing with c?
-				while ((d = generate(picture)) && d != c)
-					++picture->pic_literals;
-			}
-			picture->pic_flags &= ~PIC_literal;
-			break;
-
-		case '\\':
-			++picture->pic_literals;
-			picture->pic_flags |= PIC_literal;
-			generate(picture);
-			picture->pic_flags &= ~PIC_literal;
-			break;
-
-		case 'C':
-		case 'R':
-			picture->pic_flags |= PIC_signed;
-			++picture->pic_brackets;
-			if (generate(picture))
-				++picture->pic_brackets;
-			else
-				++picture->pic_count;
-			break;
-
-		case 'P':
-			++picture->pic_meridian;
-			break;
-
-		case 'T':
-			if (picture->pic_hours < 2)
-				++picture->pic_hours;
-			else if (picture->pic_minutes < 2)
-				++picture->pic_minutes;
-			else
-				++picture->pic_seconds;
-			break;
-
-		case 'B':
-		case '%':
-		case ',':
-		case '/':
-		default:
-			++picture->pic_literals;
-			break;
-		}
-	}
-
-	if (c == '?')
-		picture->pic_missing = PIC_analyze(picture->pic_pointer, 0);
-
-	// if a DB showed up, and the string is numeric, treat the DB as DeBit
-
-	if (debit && (picture->pic_digits || picture->pic_hex_digits))
-	{
-		--picture->pic_days;
-		--picture->pic_literals;
-		picture->pic_flags |= PIC_signed;
-		++picture->pic_brackets;
-		++picture->pic_brackets;
-	}
-
-	picture->pic_print_length =
-		picture->pic_digits +
-		picture->pic_hex_digits +
-		picture->pic_chars +
-		picture->pic_floats +
-		picture->pic_literals +
-		picture->pic_decimals +
-		picture->pic_months + picture->pic_days + picture->pic_weekdays + picture->pic_years +
-		picture->pic_nmonths + picture->pic_julians +
-		picture->pic_brackets +
-		picture->pic_exponents +
-		picture->pic_float_digits +
-		picture->pic_hours + picture->pic_minutes + picture->pic_seconds +
-		picture->pic_meridian;
-
-
-	if (picture->pic_missing)
-	{
-		picture->pic_length = MAX(picture->pic_print_length, picture->pic_missing->pic_print_length);
-		picture->pic_missing->pic_length = picture->pic_length;
-	}
-	else
-		picture->pic_length = picture->pic_print_length;
-
-	if (picture->pic_days || picture->pic_weekdays || picture->pic_months || picture->pic_nmonths ||
-		picture->pic_years || picture->pic_hours || picture->pic_julians)
-	{
-		picture->pic_type = pic_date;
-	}
-	else if (picture->pic_exponents || picture->pic_float_digits)
-		picture->pic_type = pic_float;
-	else if (picture->pic_digits || picture->pic_hex_digits)
-		picture->pic_type = pic_numeric;
-	else
-		picture->pic_type = pic_alpha;
-
-	return picture;
-}
-
-
-void PIC_edit(const dsc* desc, pics* picture, TEXT** output, USHORT max_length)
-{
-/**************************************
- *
- *	P I C _ e d i t
- *
- **************************************
- *
- * Functional description
- *	Edit data from a descriptor through an edit string to a running
- *	output pointer.  For text strings, check that we don't overflow
- *	the output buffer.
- *
- **************************************/
-
-	switch (picture->pic_type)
-	{
-	case pic_alpha:
-		edit_alpha(desc, picture, output, max_length);
-		return;
-	case pic_numeric:
-		edit_numeric(desc, picture, output);
-		return;
-	case pic_date:
-		edit_date(desc, picture, output);
-		return;
-	case pic_float:
-		edit_float(desc, picture, output);
-		return;
-	default:
-		ERRQ_bugcheck(68);			// Msg 68 PIC_edit: class not yet implemented
-	}
-}
-
-
-void PIC_missing( qli_const* constant, pics* picture)
-{
-/**************************************
- *
- *	P I C _ m i s s i n g
- *
- **************************************
- *
- * Functional description
- *	Create a literal picture string from
- *	a descriptor for a missing value so
- *	we can print the missing value
- *
- **************************************/
-
-	const dsc* desc = &constant->con_desc;
-
-	const int l = MAX(desc->dsc_length, picture->pic_length);
-
-	qli_str* scratch = (qli_str*) ALLOCDV(type_str, l + 3);
-	TEXT* p = scratch->str_data;
-	*p++ = '\"';
-
-	PIC_edit(desc, picture, &p, l);
-	*p++ = '\"';
-	*p = 0;
-
-    pics* missing_picture = PIC_analyze(scratch->str_data, desc);
-	picture->pic_missing = missing_picture;
-	picture->pic_length = MAX(picture->pic_print_length, missing_picture->pic_print_length);
-	missing_picture->pic_length = picture->pic_length;
-}
-
-
-static TEXT* cvt_to_ascii( SLONG number, TEXT* pointer, int length)
-{
-/**************************************
- *
- *	c v t _ t o _ a s c i i
- *
- **************************************
- *
- * Functional description
- *	Convert a number to a number of ascii digits (plus terminating
- *	null), updating pointer.
- *
- **************************************/
-	pointer += length + 1;
-	TEXT* p = pointer;
-	*--p = 0;
-
-	while (--length >= 0)
-	{
-		*--p = (number % 10) + '0';
-		number /= 10;
-	}
-
-	return pointer;
-}
-
-
-static const TEXT* default_edit_string(const dsc* desc, TEXT* buff)
-{
-/**************************************
- *
- *	d e f a u l t _ e d i t _ s t r i n g
- *
- **************************************
- *
- * Functional description
- *	Given a skeletal descriptor, generate a default edit string.
- *
- **************************************/
-	TEXT buffer[32];
-
-	if (!buff)
-		buff = buffer;
-
-	const SSHORT scale = desc->dsc_scale;
-
-	switch (desc->dsc_dtype)
-	{
-	case dtype_text:
-		sprintf(buff, "X(%d)", desc->dsc_length);
-		break;
-
-	case dtype_cstring:
-		sprintf(buff, "X(%d)", desc->dsc_length - 1);
-		break;
-
-	case dtype_varying:
-		sprintf(buff, "X(%d)", desc->dsc_length - 2);
-		break;
-
-	case dtype_short:
-		if (!scale)
-			return "-(5)9";
-		if (scale < 0 && scale > -5)
-			sprintf(buff, "-(%d).9(%d)", 6 + scale, -scale);
-		else if (scale < 0)
-			sprintf(buff, "-.9(%d)", -scale);
-		else
-			sprintf(buff, "-(%d)9", 5 + scale);
-		break;
-
-	case dtype_long:
-		if (!scale)
-			return "-(10)9";
-		if (scale < 0 && scale > -10)
-			sprintf(buff, "-(%d).9(%d)", 10 + scale, -scale);
-		else if (scale < 0)
-			sprintf(buff, "-.9(%d)", -scale);
-		else
-			sprintf(buff, "-(%d)9", 11 + scale);
-		break;
-
-	case dtype_int64:
-        // replace 16 with 20 later
-		// (as soon as I have sorted out the rounding issues)
-		// FSG
-		if (!scale)
-			return "-(16)9";
-		if (scale < 0 && scale > -16)
-			sprintf(buff, "-(%d).9(%d)", 16 + scale, -scale);
-		else if (scale < 0)
-			sprintf(buff, "-.9(%d)", -scale);
-		else
-			sprintf(buff, "-(%d)9", 17 + scale);
-		break;
-
-	case dtype_sql_date:
-	case dtype_timestamp:
-		return "DD-MMM-YYYY";
-
-	case dtype_sql_time:
-		return "TT:TT:TT.TTTT";
-
-	case dtype_real:
-		return "G(8)";
-
-	case dtype_double:
-		return "G(16)";
-
-	default:
-		return "X(11)";
-	}
-
-	if (buff == buffer)
-	{
-		qli_str* string = (qli_str*) ALLOCDV(type_str, static_cast<int>(strlen(buff)));
-		strcpy(string->str_data, buff);
-		buff = string->str_data;
-	}
-
-	return buff;
-}
-
-
-static void edit_alpha(const dsc* desc,
-					   pics* picture, TEXT** output, USHORT max_length)
-{
-/**************************************
- *
- *	e d i t _ a l p h a
- *
- **************************************
- *
- * Functional description
- *	Edit data from a descriptor through an edit string to a running
- *	output pointer.
- *
- **************************************/
-	Firebird::VaryStr<512> temp;
-
-	const TEXT* p = NULL;
-	const USHORT l = MOVQ_get_string(desc, &p, &temp, sizeof(temp));
-	const TEXT* const end = p + l;
-	picture->pic_pointer = picture->pic_string;
-	picture->pic_count = 0;
-	TEXT* out = *output;
-
-	while (p < end)
-	{
-		if ((out - *output) >= max_length)
-			break;
-		TEXT c = generate(picture);
-		if (!c || c == '?')
-			break;
-
-		c = UPPER(c);
-
-		switch (c)
-		{
-		case 'X':
-
-			*out++ = *p++;
-			break;
-
-		case 'A':
-			if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z'))
-				*out++ = *p++;
-			else
-				IBERROR(69);	// Msg 69 conversion error
-			break;
-
-		case 'B':
-			*out++ = ' ';
-			break;
-
-		case '"':
-		case '\'':
-		case '\\':
-			literal(picture, c, &out);
-			break;
-
-		default:
-			*out++ = c;
-			break;
-		}
-	}
-
-	*output = out;
-}
-
-
-static void edit_date( const dsc* desc, pics* picture, TEXT** output)
-{
-/**************************************
- *
- *	e d i t _ d a t e
- *
- **************************************
- *
- * Functional description
- *	Edit data from a descriptor through an edit string to a running
- *	output pointer.
- *
- **************************************/
-	SLONG date[2];
-	DSC temp_desc;
-	TEXT d, temp[256];
-
-	temp_desc.dsc_dtype = dtype_timestamp;
-	temp_desc.dsc_scale = 0;
-	temp_desc.dsc_sub_type = 0;
-	temp_desc.dsc_length = sizeof(date);
-	temp_desc.dsc_address = (UCHAR*) date;
-	QLI_validate_desc(temp_desc);
-	MOVQ_move(desc, &temp_desc);
-
-    tm times;
-	isc_decode_date((ISC_QUAD*) date, &times);
-	TEXT* p = temp;
-
-	const TEXT* nmonth = p;
-	p = cvt_to_ascii((SLONG) times.tm_mon + 1, p, picture->pic_nmonths);
-
-	const TEXT* day = p;
-	p = cvt_to_ascii((SLONG) times.tm_mday, p, picture->pic_days);
-
-	const TEXT* year = p;
-	p = cvt_to_ascii((SLONG) times.tm_year + 1900, p, picture->pic_years);
-
-	const TEXT* julians = p;
-	p = cvt_to_ascii((SLONG) times.tm_yday + 1, p, picture->pic_julians);
-
-	const TEXT* meridian = "";
-	if (picture->pic_meridian)
-	{
-		if (times.tm_hour >= 12)
-		{
-			meridian = "PM";
-			if (times.tm_hour > 12)
-				times.tm_hour -= 12;
-		}
-		else
-			meridian = "AM";
-	}
-
-	const SLONG seconds = date[1] % (60 * PRECISION);
-
-	TEXT* hours = p;
-	p = cvt_to_ascii((SLONG) times.tm_hour, p, picture->pic_hours);
-	p = cvt_to_ascii((SLONG) times.tm_min, --p, picture->pic_minutes);
-	p = cvt_to_ascii((SLONG) seconds, --p, 6);
-
-	if (*hours == '0')
-		*hours = ' ';
-
-	SLONG rel_day = (date[0] + 3) % 7;
-	if (rel_day < 0)
-		rel_day += 7;
-	const TEXT* weekday = alpha_weekdays[rel_day];
-	const TEXT* month = alpha_months[times.tm_mon];
-
-	picture->pic_pointer = picture->pic_string;
-	picture->pic_count = 0;
-	TEXT* out = *output;
-
-	bool sig_day = false;
-	bool blank = true;
-
-	for (;;)
-	{
-		TEXT c = generate(picture);
-		if (!c || c == '?')
-			break;
-		c = UPPER(c);
-
-		switch (c)
-		{
-		case 'Y':
-			*out++ = *year++;
-			break;
-
-		case 'M':
-			if (*month)
-				*out++ = *month++;
-			break;
-
-		case 'N':
-			*out++ = *nmonth++;
-			break;
-
-		case 'D':
-			d = *day++;
-			if (!sig_day && d == '0' && blank)
-				*out++ = ' ';
-			else
-			{
-				sig_day = true;
-				*out++ = d;
-			}
-			break;
-
-		case 'J':
-			if (*julians)
-				*out++ = *julians++;
-			break;
-
-		case 'W':
-			if (*weekday)
-				*out++ = *weekday++;
-			break;
-
-		case 'B':
-			*out++ = ' ';
-			break;
-
-		case 'P':
-			if (*meridian)
-				*out++ = *meridian++;
-			break;
-
-		case 'T':
-			if (*hours)
-				*out++ = *hours++;
-			break;
-
-		case '"':
-		case '\'':
-		case '\\':
-			literal(picture, c, &out);
-			break;
-
-		default:
-			*out++ = c;
-			break;
-		}
-		if (c != 'B')
-			blank = false;
-	}
-
-	*output = out;
-}
-
-
-static void edit_float( const dsc* desc, pics* picture, TEXT** output)
-{
-/**************************************
- *
- *	e d i t _ f l o a t
- *
- **************************************
- *
- * Functional description
- *	Edit data from a descriptor through an edit string to a running
- *	output pointer.
- *
- **************************************/
-	TEXT temp[512];
-	USHORT l, width, decimal_digits, w_digits, f_digits;
-
-	double number = MOVQ_get_double(desc);
-	const bool negative = (number < 0);
-	if (negative)
-		number = -number;
-
-	// If exponents are explicitly requested (E-format edit_string), generate them.
-	// Otherwise, the rules are: if the number in f-format will fit into the allotted
-	// space, print it in f-format; otherwise print it in e-format.
-	// (G-format is untrustworthy.)
-
-	if (std::isnan(number))
-		sprintf(temp, "NaN");
-	else if (std::isinf(number))
-		sprintf(temp, "Infinity");
-	else if (picture->pic_exponents)
-	{
-		width = picture->pic_print_length - picture->pic_floats - picture->pic_literals;
-		decimal_digits = picture->pic_fractions;
-		sprintf(temp, "%*.*e", width, decimal_digits, number);
-	}
-	else if (number == 0)
-		sprintf(temp, "%.0f", number);
-	else
-	{
-		width = picture->pic_float_digits - 1 + picture->pic_floats;
-		f_digits = (width > 2) ? width - 2 : 0;
-		sprintf(temp, "%.*f", f_digits, number);
-		w_digits = static_cast<USHORT>(strlen(temp));
-		if (f_digits)
-		{
-			TEXT* p = temp + w_digits;	// find the end
-			w_digits = w_digits - (f_digits + 1);
-			while (*--p == '0')
-				--f_digits;
-			if (*p != '.')
-				++p;
-			*p = 0;				// move the end
-		}
-		if ((w_digits > width) || (!f_digits && w_digits == 1 && temp[0] == '0'))
-		{
-			// if the number doesn't fit in the default window, revert
-			// to exponential notation; displaying the maximum number of
-			// mantissa digits.
-
-			if (number < 1e100)
-				decimal_digits = (width > 6) ? width - 6 : 0;
-			else
-				decimal_digits = (width > 7) ? width - 7 : 0;
-			sprintf(temp, "%.*e", decimal_digits, number);
-		}
-	}
-
-	TEXT* p = temp;
-	picture->pic_pointer = picture->pic_string;
-	picture->pic_count = 0;
-	TEXT* out = *output;
-
-	for (l = picture->pic_length - picture->pic_print_length; l > 0; --l)
-		*out++ = ' ';
-
-	bool is_signed = false;
-
-	for (;;)
-	{
-		const TEXT e = generate(picture);
-		TEXT c = e;
-		if (!c || c == '?')
-			break;
-		c = UPPER(c);
-
-		switch (c)
-		{
-		case 'G':
-			if (!is_signed)
-			{
-				if (negative)
-					*out++ = '-';
-				else
-					*out++ = ' ';
-				is_signed = true;
-			}
-			else if (*p)
-				*out++ = *p++;
-			break;
-
-		case 'B':
-			*out++ = ' ';
-			break;
-
-		case '"':
-		case '\'':
-		case '\\':
-			literal(picture, c, &out);
-			break;
-
-		case '9':
-		case 'Z':
-			{
-				if (!(*p) || *p > '9' || *p < '0')
-					break;
-				TEXT d = *p++;
-				if (c == '9' && d == ' ')
-					d = '0';
-				else if (c == 'Z' && d == '0')
-					d = ' ';
-				*out++ = d;
-			}
-			break;
-
-		case '.':
-			*out++ = (*p == c) ? *p++ : c;
-			break;
-
-		case 'E':
-			if (!*p)
-				break;
-			*out++ = e;
-			if (UPPER(*p) == c)
-				++p;
-			break;
-
-		case '+':
-		case '-':
-			if (!*p)
-				break;
-			if (*p != '+' && *p != '-')
-			{
-				if (is_signed)
-					*out++ = c;
-				else if (c == '-' && !negative)
-					*out++ = ' ';
-				else if (c == '+' && negative)
-					*out++ = '-';
-				else
-					*out++ = c;
-				is_signed = true;
-			}
-			else if (*p == '-' || c == '+')
-				*out++ = *p++;
-			else
-			{
-				*out++ = ' ';
-				p++;
-			}
-			break;
-
-		default:
-			*out++ = c;
-			break;
-		}
-	}
-
-	*output = out;
-}
-
-
-static void edit_numeric(const dsc* desc, pics* picture, TEXT** output)
-{
-/**************************************
- *
- *	e d i t _ n u m e r i c
- *
- **************************************
- *
- * Functional description
- *	Edit data from a descriptor through an edit string to a running
- *	output pointer.
- *
- **************************************/
-	bool overflow = false;
-
-	TEXT* out = *output;
-
-	double number = MOVQ_get_double(desc);
-	const bool negative = (number < 0);
-	if (negative)
-	{
-		number = -number;
-		if (!(picture->pic_flags & PIC_signed))
-			overflow = true;
-	}
-
-    SSHORT scale = picture->pic_fractions;
-	if (scale)
-	{
-		if (scale < 0)
-		{
-			do {
-				number /= 10.;
-			} while (++scale);
-		}
-		else if (scale > 0)
-		{
-			do {
-				number *= 10.;
-			} while (--scale);
-		}
-	}
-
-	TEXT temp[512];
-	TEXT* p = temp;
-	TEXT* digits = p;
-
-	double check;
-	USHORT power;
-	if (picture->pic_digits && !overflow)
-	{
-		for (check = number, power = picture->pic_digits; power; --power)
-			check /= 10.0;
-		if (check >= 1)
-			overflow = true;
-		else
-		{
-			sprintf(digits, "%0*.0f", picture->pic_digits, number);
-			p = digits + strlen(digits);
-		}
-	}
-
-	picture->pic_pointer = picture->pic_string;
-	bool hex_overflow = false;
-	const TEXT* hex = 0;
-	if (picture->pic_hex_digits)
-	{
-		hex = p;
-		p += picture->pic_hex_digits;
-		for (check = number, power = picture->pic_hex_digits; power; --power)
-			check /= 16.0;
-		if (check >= 1)
-			hex_overflow = true;
-		else
-		{
-			SLONG nh = static_cast<SLONG>(number);
-			while (p-- > hex)
-			{
-				*p = "0123456789abcdef"[nh & 15];
-				nh >>= 4;
-			}
-		}
-	}
-
-	for (USHORT l = picture->pic_length - picture->pic_print_length; l-- > 0;)
-		*out++ = ' ';
-
-	const SLONG n = (number + 0.5 < 1) ? 0 : 1;
-
-	TEXT* float_ptr = NULL;
-	TEXT float_char;
-	TEXT d;
-	bool signif = false;
-
-	for (;;)
-	{
-		TEXT c = generate(picture);
-		if (!c || c == '?')
-			break;
-
-		c = UPPER(c);
-		if (overflow && c != 'H')
-		{
-			*out++ = '*';
-			continue;
-		}
-
-		switch (c)
-		{
-		case '9':
-			signif = true;
-			*out++ = *digits++;
-			break;
-
-		case 'H':
-			if (hex_overflow)
-			{
-				*out++ = '*';
-				continue;
-			}
-		case '*':
-		case 'Z':
-			d = (c == 'H') ? *hex++ : *digits++;
-			if (signif || d != '0')
-			{
-				*out++ = d;
-				signif = true;
-			}
-			else
-				*out++ = (c == '*') ? '*' : ' ';
-			break;
-
-		case '+':
-		case '-':
-		case '$':
-			if (c == '+' && negative)
-				c = '-';
-			else if (c == '-' && !negative)
-				c = ' ';
-			float_char = c;
-			if (!float_ptr)
-			{
-				float_ptr = out;
-				*out++ = n ? c : ' ';
-				break;
-			}
-			d = *digits++;
-			if (signif || d != '0')
-			{
-				*out++ = d;
-				signif = true;
-				break;
-			}
-			*float_ptr = ' ';
-			float_ptr = out;
-			*out++ = n ? c : ' ';
-			break;
-
-		case '(':
-		case ')':
-			*out++ = negative ? c : ' ';
-			break;
-
-		case 'C':
-		case 'D':
-			d = generate(picture);
-			if (negative)
-			{
-				*out++ = c;
-				*out++ = UPPER(d);
-			}
-			else if (d)
-			{
-				*out++ = ' ';
-				*out++ = ' ';
-			}
-			break;
-
-		case '.':
-			signif = true;
-			*out++ = c;
-			break;
-
-		case 'B':
-			*out++ = ' ';
-			break;
-
-		case '"':
-		case '\'':
-		case '\\':
-			literal(picture, c, &out);
-			break;
-
-		case ',':
-			if (signif)
-				*out++ = c;
-			else if (float_ptr)
-			{
-				*float_ptr = ' ';
-				float_ptr = out;
-				*out++ = float_char;
-			}
-			else
-				*out++ = ' ';
-			break;
-
-		default:
-			*out++ = c;
-			break;
-		}
-		if ((picture->pic_flags & PIC_suppress_blanks) && out[-1] == ' ')
-			--out;
-	}
-
-	*output = out;
-}
-
-
-static int generate( pics* picture)
-{
-/**************************************
- *
- *	g e n e r a t e
- *
- **************************************
- *
- * Functional description
- *	Generate the next character from a picture string.
- *
- **************************************/
-	TEXT c;
-
-	for (;;)
-	{
-		// If we're in a repeat, pass it back
-
-		if (picture->pic_count > 0)
-		{
-			--picture->pic_count;
-			return picture->pic_character;
-		}
-
-		// Get the next character.  If null, we're done
-
-		c = *picture->pic_pointer++;
-
-		// If we're in literal mode, just return the character
-
-		if (picture->pic_flags & PIC_literal)
-			break;
-
-		// If the next character is also a paren, it is a debit indicating
-		// bracket.  If so, swallow the second.
-
-		if ((c == ')' || c == '(') && *picture->pic_pointer == c)
-		{
-			picture->pic_pointer++;
-			return (picture->pic_character = c);
-		}
-
-		// If the character is null and not a repeat count, we're done
-
-		if (!c || c != '(')
-			break;
-
-		// We're got a potential repeat count.  If real, extract it.
-
-		const TEXT* p = picture->pic_pointer;
-		while (*p >= '0' && *p <= '9')
-			picture->pic_count = picture->pic_count * 10 + *p++ - '0';
-
-		if (p == picture->pic_pointer)
-		{
-			c = '(';
-			break;
-		}
-
-		if (*p == ')')
-			++p;
-
-		picture->pic_pointer = p;
-
-		// Someone may have done something very stupid, like specify a repeat
-		// count of zero.  It's too late, as we've already gen'd one instance
-		// of the edit character -- but let's not access violate, shall we?
-
-		if (picture->pic_count)
-			--picture->pic_count;
-	}
-
-	return (picture->pic_character = c);
-}
-
-
-static void literal( pics* picture, TEXT c, TEXT** ptr)
-{
-/**************************************
- *
- *	l i t e r a l
- *
- **************************************
- *
- * Functional description
- *	Handle a literal string in a picture string.
- *
- **************************************/
-	TEXT* p = *ptr;
-	picture->pic_flags |= PIC_literal;
-
-	TEXT d;
-	if (c == '\\')
-		*p++ = generate(picture);
-	else
-		while ((d = generate(picture)) && d != c)
-			*p++ = d;
-
-	*ptr = p;
-	picture->pic_flags &= ~PIC_literal;
-}
-
-
diff --git a/src/qli/proc_ddl.h b/src/qli/proc_ddl.h
deleted file mode 100644
index 4bfa803b5f..0000000000
--- a/src/qli/proc_ddl.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-1, 2, 9, 14, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', 'S', 55, 2, 0, 2, 0, 3, 6, 18, 0, 'Q', 'L',
-'I', '$', 'P', 'R', 'O', 'C', 'E', 'D', 'U', 'R', 'E', '_', 'N',
-'A', 'M', 'E', 55, 2, 0, 2, 0, 'F', 2, 0, 14, 0, 'G', 2, 0, 31,
-0, 3, 7, 18, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', '_', 'N', 'A', 'M', 'E', 50, 14, 0, 'Q',
-'L', 'I', '$', 'P', 'R', 'O', 'C', 'E', 'D', 'U', 'R', 'E', 'S',
-55, 2, 0, 2, 0, 92, 2, 0, 0, 0, 3, 6, 13, 0, 'Q', 'L', 'I', '$',
-'P', 'R', 'O', 'C', 'E', 'D', 'U', 'R', 'E', 55, 2, 0, 2, 0,
-'F', 2, 0, 5, 1, 'I', 2, 0, 1, 0, 'J', 2, 0, 'P', 0, 3, 7, 13,
-0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E', 'D', 'U', 'R',
-'E', 50, 14, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', 'S', 55, 2, 0, 2, 0, 92, 2, 0, 1, 0, 3, 3,
-255,
diff --git a/src/qli/proc_proto.h b/src/qli/proc_proto.h
deleted file mode 100644
index f06d0ca3d6..0000000000
--- a/src/qli/proc_proto.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		proc_proto.h
- *	DESCRIPTION:	Prototype header file for proc.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_PROC_PROTO_H
-#define QLI_PROC_PROTO_H
-
-void	PRO_close(qli_dbb*, FB_API_HANDLE);
-void	PRO_commit(qli_dbb*);
-void	PRO_copy_procedure(qli_dbb*, const TEXT*, qli_dbb*, const TEXT*);
-void	PRO_create(qli_dbb*, const TEXT*);
-int		PRO_delete_procedure(qli_dbb*, const TEXT*);
-void	PRO_edit_procedure(qli_dbb*, const TEXT*);
-FB_API_HANDLE	PRO_fetch_procedure(qli_dbb*, const TEXT*);
-bool	PRO_get_line (FB_API_HANDLE, TEXT*, USHORT);
-void	PRO_invoke(qli_dbb*, const TEXT*);
-FB_API_HANDLE	PRO_open_blob(qli_dbb*, ISC_QUAD&);
-int		PRO_rename_procedure(qli_dbb*, const TEXT*, const TEXT*);
-void	PRO_rollback(qli_dbb*);
-
-typedef void (*extract_fn_t)(void* file, const TEXT* name,
-							  USHORT length, qli_dbb* database, ISC_QUAD& blob_id);
-void	PRO_scan(qli_dbb*, extract_fn_t, void*);
-
-void	PRO_setup(qli_dbb*);
-FB_API_HANDLE	PRO_transaction(qli_dbb*, bool);
-
-#endif // QLI_PROC_PROTO_H
-
diff --git a/src/qli/procddl1.h b/src/qli/procddl1.h
deleted file mode 100644
index dafeffbef3..0000000000
--- a/src/qli/procddl1.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-1, 2, 6, 18, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', '_', 'N', 'A', 'M', 'E', 55, 2, 0, 2, 0,
-'F', 2, 0, 14, 0, 'G', 2, 0, 31, 0, 3, 3, 255,
diff --git a/src/qli/procddl2.h b/src/qli/procddl2.h
deleted file mode 100644
index 314338ea5f..0000000000
--- a/src/qli/procddl2.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-1, 2, 6, 13, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', 55, 2, 0, 2, 0, 'F', 2, 0, 5, 1, 'I', 2,
-0, 1, 0, 'J', 2, 0, 'P', 0, 3, 3, 255,
diff --git a/src/qli/procddl3.h b/src/qli/procddl3.h
deleted file mode 100644
index 878488c1a7..0000000000
--- a/src/qli/procddl3.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-1, 2, 9, 14, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', 'S', 55, 2, 0, 2, 0, 3, 7, 18, 0, 'Q', 'L',
-'I', '$', 'P', 'R', 'O', 'C', 'E', 'D', 'U', 'R', 'E', '_', 'N',
-'A', 'M', 'E', 50, 14, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O',
-'C', 'E', 'D', 'U', 'R', 'E', 'S', 55, 2, 0, 2, 0, 92, 2, 0,
-0, 0, 3, 7, 13, 0, 'Q', 'L', 'I', '$', 'P', 'R', 'O', 'C', 'E',
-'D', 'U', 'R', 'E', 50, 14, 0, 'Q', 'L', 'I', '$', 'P', 'R',
-'O', 'C', 'E', 'D', 'U', 'R', 'E', 'S', 55, 2, 0, 2, 0, 92, 2,
-0, 1, 0, 3, 3, 255,
diff --git a/src/qli/procddl4.h b/src/qli/procddl4.h
deleted file mode 100644
index d0c6933bab..0000000000
--- a/src/qli/procddl4.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-    isc_dyn_version_1,
-       isc_dyn_begin,
-          isc_dyn_def_idx, 19,0, 'Q','L','I','$','P','R','O','C','E','D','U','R','E','S','_','I','D','X','1',
-             isc_dyn_rel_name, 14,0, 'Q','L','I','$','P','R','O','C','E','D','U','R','E','S',
-             isc_dyn_idx_unique, 2,0, 1,0,
-             isc_dyn_idx_inactive, 2,0, 0,0,
-             isc_dyn_fld_name, 18,0, 'Q','L','I','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E',
-             isc_dyn_end,
-          isc_dyn_end,
-    isc_dyn_eoc
diff --git a/src/qli/qliswi.h b/src/qli/qliswi.h
deleted file mode 100644
index 59d928c849..0000000000
--- a/src/qli/qliswi.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- *  The contents of this file are subject to the Initial
- *  Developer's Public License Version 1.0 (the "License");
- *  you may not use this file except in compliance with the
- *  License. You may obtain a copy of the License at
- *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.
- *
- *  Software distributed under the License is distributed AS IS,
- *  WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *  See the License for the specific language governing rights
- *  and limitations under the License.
- *
- *  The Original Code was created by Claudio Valderrama on 15-Jul-2009
- *  for the Firebird Open Source RDBMS project.
- *
- *  Copyright (c) 2009 Claudio Valderrama
- *  and all contributors signed below.
- *
- *  All Rights Reserved.
- *  Contributor(s): ______________________________________.
- *
- */
-
-
-#ifndef QLI_QLISWI_H
-#define QLI_QLISWI_H
-
-#include "ibase.h"
-#include "../jrd/constants.h"
-
-enum qli_switches
-{
-	IN_SW_QLI_0					= 0,
-	IN_SW_QLI_APP_SCRIPT		= 1,
-	IN_SW_QLI_BUFFERS			= 2,
-	IN_SW_QLI_FETCH_PASSWORD	= 3,
-	IN_SW_QLI_INITIAL_SCRIPT	= 4,
-	IN_SW_QLI_NOBANNER			= 5,
-	IN_SW_QLI_PASSWORD			= 6,
-	IN_SW_QLI_TRACE				= 7,
-#ifdef TRUSTED_AUTH
-	IN_SW_QLI_TRUSTED_AUTH		= 8,
-#endif
-	IN_SW_QLI_USER				= 9,
-	IN_SW_QLI_VERIFY			= 10,
-	IN_SW_QLI_X					= 11,	// Internal switch: do not present in help
-	IN_SW_QLI_Y					= 12,	// Internal switch: do not present in help
-	IN_SW_QLI_Z					= 13,
-	IN_SW_QLI_HELP				= 14,
-	IN_SW_QLI_NODBTRIGGERS		= 15,
-	IN_SW_QLI_EXIT				= 16
-};
-
-
-static const Switches::in_sw_tab_t qli_in_sw_table[] =
-{
-	{IN_SW_QLI_APP_SCRIPT		, 0, "APPSCRIPT"		, 0, 0, 0, false, false, 0,	1, NULL},
-	{IN_SW_QLI_APP_SCRIPT		, 0, "APP_SCRIPT"		, 0, 0, 0, false, false, 516,	1, NULL},
-	{IN_SW_QLI_BUFFERS			, 0, "BUFFERS"			, 0, 0, 0, false, false, 517,	1, NULL},
-	{IN_SW_QLI_EXIT				, 0, "EXIT"				, 0, 0, 0, false, false, 532,	1, NULL},
-	{IN_SW_QLI_FETCH_PASSWORD	, 0, "FETCH_PASSWORD"	, 0, 0, 0, false, false, 518,	1, NULL},
-	{IN_SW_QLI_INITIAL_SCRIPT	, 0, "INITSCRIPT"		, 0, 0, 0, false, false, 0,	1, NULL},
-	{IN_SW_QLI_INITIAL_SCRIPT	, 0, "INIT_SCRIPT"		, 0, 0, 0, false, false, 519,	1, NULL},
-	{IN_SW_QLI_NODBTRIGGERS		, 0, "NODBTRIGGERS"		, 0, 0, 0, false, false, 531,	3, NULL},
-	{IN_SW_QLI_NOBANNER			, 0, "NOBANNER"			, 0, 0, 0, false, false, 0,	1, NULL},
-	{IN_SW_QLI_NOBANNER			, 0, "NO_BANNER"		, 0, 0, 0, false, false, 520,	1, NULL},
-	{IN_SW_QLI_PASSWORD			, 0, "PASSWORD"			, 0, 0, 0, false, false, 521,	1, NULL},
-	{IN_SW_QLI_TRACE			, 0, "TRACE"			, 0, 0, 0, false, false, 522,	3, NULL},
-#ifdef TRUSTED_AUTH
-	{IN_SW_QLI_TRUSTED_AUTH		, 0, "TRUSTED_AUTH"		, 0, 0, 0, false, false, 523,	3, NULL},
-#endif
-	{IN_SW_QLI_USER				, 0, "USER"				, 0, 0, 0, false, false, 524,	1, NULL},
-	{IN_SW_QLI_VERIFY			, 0, "VERIFY"			, 0, 0, 0, false, false, 525,	1, NULL},
-	{IN_SW_QLI_X				, 0, "X"				, 0, 0, 0, false, false, 0,	1, NULL},
-	{IN_SW_QLI_Y				, 0, "Y"				, 0, 0, 0, false, false, 0,	1, NULL},
-	{IN_SW_QLI_Z				, 0, "Z"				, 0, 0, 0, false, false, 526,	1, NULL},
-	{IN_SW_QLI_HELP				, 0, "?"				, 0, 0, 0, false, false, 0,	1, NULL},
-	{IN_SW_QLI_0				, 0, NULL				, 0, 0, 0, false, false, 0,	0, NULL}
-};
-
-#endif // QLI_QLISWI_H
diff --git a/src/qli/repor_proto.h b/src/qli/repor_proto.h
deleted file mode 100644
index 26cc602c09..0000000000
--- a/src/qli/repor_proto.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		repor_proto.h
- *	DESCRIPTION:	Prototype header file for report.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_REPOR_PROTO_H
-#define QLI_REPOR_PROTO_H
-
-void	RPT_report(qli_nod*);
-
-#endif // QLI_REPOR_PROTO_H
-
diff --git a/src/qli/report.cpp b/src/qli/report.cpp
deleted file mode 100644
index 56b6223429..0000000000
--- a/src/qli/report.cpp
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		report.cpp
- *	DESCRIPTION:	Report writer runtime control
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#include "firebird.h"
-#include <stdio.h>
-#include "../qli/dtr.h"
-#include "../qli/exe.h"
-#include "../qli/compile.h"
-#include "../qli/report.h"
-#include "../qli/all_proto.h"
-#include "../qli/eval_proto.h"
-#include "../qli/exe_proto.h"
-#include "../qli/forma_proto.h"
-#include "../qli/mov_proto.h"
-#include "../qli/repor_proto.h"
-
-static void bottom_break(qli_brk*, qli_prt*);
-static void increment_break(qli_brk*);
-static void initialize_break(qli_brk*);
-static bool test_break(qli_brk*, qli_rpt*, qli_msg*);
-static void top_break(qli_brk*, qli_prt*);
-static void top_of_page(qli_prt*, bool);
-
-//#define SWAP(a, b)	{temp = a; a = b; b = temp;}
-inline void swap_uchar(UCHAR*& a, UCHAR*& b)
-{
-	UCHAR* temp = a;
-	a = b;
-	b = temp;
-}
-
-
-void RPT_report( qli_nod* loop)
-{
-/**************************************
- *
- *	R P T _ r e p o r t
- *
- **************************************
- *
- * Functional description
- *	Execute a FOR loop.  This may require that a request get
- *	started, a message sent, and a message received for each
- *	record.  At the other end of the spectrum, there may be
- *	absolutely nothing to do.
- *
- **************************************/
-
-	// Get to actual report node
-
-	qli_nod* node = loop->nod_arg[e_for_statement];
-	qli_rpt* report = (qli_rpt*) node->nod_arg[e_prt_list];
-	qli_prt* print = (qli_prt*) node->nod_arg[e_prt_output];
-	print->prt_new_page = top_of_page;
-	print->prt_page_number = 0;
-
-	// Get to actual report node
-
-	// If there is a request associated  with the loop, start it and possibly
-	// send a message slong with it.
-
-	qli_msg* message;
-	qli_req* request = (qli_req*) loop->nod_arg[e_for_request];
-	if (request)
-		EXEC_start_request(request, (qli_msg*) loop->nod_arg[e_for_send]);
-	else if (message = (qli_msg*) loop->nod_arg[e_for_send])
-		EXEC_send(message);
-
-	// Receive messages in a loop until the end of file field comes up true.
-
-	message = (qli_msg*) loop->nod_arg[e_for_receive];
-
-	// Get the first record of the record.  If there isn't anything,
-	// don't worry about anything.
-
-	const dsc* desc = EXEC_receive(message, (qli_par*) loop->nod_arg[e_for_eof]);
-	if (*(USHORT*) desc->dsc_address)
-		return;
-
-	if (!report->rpt_buffer)
-	{
-		qli_str* string = (qli_str*) ALLOCDV(type_str, message->msg_length);
-		report->rpt_buffer = (UCHAR*) string->str_data;
-	}
-
-	memcpy(report->rpt_buffer, message->msg_buffer, (SLONG) message->msg_length);
-
-	qli_brk* control;
-	if (control = report->rpt_top_rpt)
-		FMT_print((qli_nod*) control->brk_line, print);
-
-	top_of_page(print, true);
-
-	initialize_break(report->rpt_bottom_breaks);
-	initialize_break(report->rpt_bottom_page);
-	initialize_break(report->rpt_bottom_rpt);
-
-	// Force TOP breaks for all fields
-
-	for (control = report->rpt_top_breaks; control; control = control->brk_next)
-		FMT_print((qli_nod*) control->brk_line, print);
-
-	for (;;)
-	{
-		// Check for bottom breaks.  If we find one, force all lower breaks.
-
-		for (control = report->rpt_bottom_breaks; control; control = control->brk_next)
-		{
-			if (test_break(control, report, message))
-			{
-				swap_uchar(message->msg_buffer, report->rpt_buffer);
-				bottom_break(control, print);
-				swap_uchar(message->msg_buffer, report->rpt_buffer);
-				initialize_break(control);
-				break;
-			}
-		}
-
-		if (print->prt_lines_remaining <= 0)
-			top_of_page(print, false);
-
-		// Now check for top breaks.
-
-		for (control = report->rpt_top_breaks; control; control = control->brk_next)
-		{
-			if (test_break(control, report, message))
-			{
-				top_break(control, print);
-				break;
-			}
-		}
-
-		// Increment statisticals and print detail line, if any
-
-		increment_break(report->rpt_bottom_breaks);
-		increment_break(report->rpt_bottom_page);
-		increment_break(report->rpt_bottom_rpt);
-
-		if (node = report->rpt_detail_line)
-			FMT_print(node, print);
-
-		// Get the next record.  If we're at end, we're almost done.
-
-		swap_uchar(message->msg_buffer, report->rpt_buffer);
-		desc = EXEC_receive(message, (qli_par*) loop->nod_arg[e_for_eof]);
-		if (*(USHORT *) desc->dsc_address)
-			break;
-	}
-
-	// Force BOTTOM breaks for all fields
-
-	swap_uchar(message->msg_buffer, report->rpt_buffer);
-	bottom_break(report->rpt_bottom_breaks, print);
-	bottom_break(report->rpt_bottom_rpt, print);
-
-	if (control = report->rpt_bottom_page)
-		FMT_print((qli_nod*) control->brk_line, print);
-}
-
-
-static void bottom_break( qli_brk* control, qli_prt* print)
-{
-/**************************************
- *
- *	b o t t o m  _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Force all lower breaks then take break.
- *
- **************************************/
-	if (!control)
-		return;
-
-	if (control->brk_next)
-		bottom_break(control->brk_next, print);
-
-	for (qli_lls* stack = control->brk_statisticals; stack; stack = stack->lls_next)
-		EVAL_break_compute((qli_nod*) stack->lls_object);
-
-	FMT_print((qli_nod*) control->brk_line, print);
-}
-
-
-static void increment_break( qli_brk* control)
-{
-/**************************************
- *
- *	i n c r e m e n t _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Toss another record into running computations.
- *
- **************************************/
-	for (; control; control = control->brk_next)
-	{
-		for (qli_lls* stack = control->brk_statisticals; stack; stack = stack->lls_next)
-			EVAL_break_increment((qli_nod*) stack->lls_object);
-	}
-}
-
-
-static void initialize_break( qli_brk* control)
-{
-/**************************************
- *
- *	i n i t i a l i z e _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Execute a control break.
- *
- **************************************/
-	for (; control; control = control->brk_next)
-	{
-		for (qli_lls* stack = control->brk_statisticals; stack; stack = stack->lls_next)
-			EVAL_break_init((qli_nod*) stack->lls_object);
-	}
-}
-
-
-static bool test_break(qli_brk* control, qli_rpt* report, qli_msg* message)
-{
-/**************************************
- *
- *	t e s t _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Check to see if there has been a control break for an expression.
- *
- **************************************/
-	DSC desc1, desc2;
-
-	// Evaluate the two versions of the expression
-
-	dsc* ptr1 = EVAL_value((qli_nod*) control->brk_field);
-	if (ptr1)
-		desc1 = *ptr1;
-
-	UCHAR* const buf = message->msg_buffer;
-	message->msg_buffer = report->rpt_buffer;
-
-	dsc* ptr2 = EVAL_value((qli_nod*) control->brk_field);
-	if (ptr2)
-		desc2 = *ptr2;
-
-	// An error in EVAL_value will prevent msg_buffer from being restored to its old value.
-	message->msg_buffer = buf;
-
-	// Check for consistently missing
-
-	if (!ptr1 || !ptr2)
-		return (ptr1 != ptr2);
-
-	// Both fields are present.  Check values.  Luckily, there's no need
-	// to worry about datatypes.
-
-	const UCHAR* p1 = desc1.dsc_address;
-	const UCHAR* p2 = desc2.dsc_address;
-	USHORT l = desc1.dsc_length;
-
-	if (desc1.dsc_dtype == dtype_varying)
-		l = 2 + *(USHORT*) p1;
-
-	if (l)
-		return memcmp(p1, p2, l) != 0;
-
-	return false;
-}
-
-
-static void top_break( qli_brk* control, qli_prt* print)
-{
-/**************************************
- *
- *	 t o p _ b r e a k
- *
- **************************************
- *
- * Functional description
- *	Execute a control break.
- *
- **************************************/
-	for (; control; control = control->brk_next)
-	{
-		for (qli_lls* stack = control->brk_statisticals; stack; stack = stack->lls_next)
-		{
-			EVAL_break_compute((qli_nod*) stack->lls_object);
-		}
-		FMT_print((qli_nod*) control->brk_line, print);
-	}
-}
-
-
-static void top_of_page(qli_prt* print, bool first_flag)
-{
-/**************************************
- *
- *	t o p _ o f _ p a g e
- *
- **************************************
- *
- * Functional description
- *	Handle top of page condition.
- *
- **************************************/
-	qli_brk* control;
-
-	++print->prt_page_number;
-	qli_rpt* report = print->prt_report;
-
-	if (!first_flag)
-	{
-		if (control = report->rpt_bottom_page)
-			FMT_print((qli_nod*) control->brk_line, print);
-		FMT_put("\f", print);
-	}
-
-	print->prt_lines_remaining = print->prt_lines_per_page;
-
-	if (control = report->rpt_top_page)
-		FMT_print((qli_nod*) control->brk_line, print);
-	else if (report->rpt_column_header)
-	{
-		if (report->rpt_header)
-			FMT_put(report->rpt_header, print);
-		if (report->rpt_column_header)
-			FMT_put(report->rpt_column_header, print);
-	}
-
-	if (report->rpt_bottom_page)
-		initialize_break(report->rpt_bottom_page);
-}
diff --git a/src/qli/report.h b/src/qli/report.h
deleted file mode 100644
index 47a1ac51df..0000000000
--- a/src/qli/report.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		report.h
- *	DESCRIPTION:	Report writer definitions
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_REPORT_H
-#define QLI_REPORT_H
-
-// Control break block
-
-struct qli_brk
-{
-    blk			brk_header;
-    qli_brk*	brk_next;			// Next break
-    qli_syntax*		brk_field;		// Field expression for break
-    qli_syntax*		brk_line;		// Print line
-    qli_lls*	brk_statisticals;	// Statistical expressions
-};
-
-// Report block
-
-struct qli_rpt
-{
-    blk			rpt_hdr;
-    qli_nod*	rpt_detail_line;	// Detail line print list
-    qli_brk*	rpt_top_page;		// Top of page print list
-    qli_brk*	rpt_bottom_page;	// Bottom of page print list
-    qli_brk*	rpt_top_rpt;		// Top of report print list
-    qli_brk*	rpt_bottom_rpt;		// Bottom of report print list
-    qli_brk*	rpt_top_breaks;		// Top of <field> break list
-    qli_brk*	rpt_bottom_breaks;	// Bottom of <field> break list
-    const TEXT*	rpt_column_header;
-    const TEXT*	rpt_name;			// Parsed report name
-    const TEXT*	rpt_header;			// Expanded report header
-    UCHAR*		rpt_buffer;			// Data buffer
-    USHORT		rpt_columns;		// Columns per page
-    USHORT		rpt_lines;			// Lines per page
-};
-
-#endif // QLI_REPORT_H
-
diff --git a/src/qli/reqs.h b/src/qli/reqs.h
deleted file mode 100644
index d9e62b4905..0000000000
--- a/src/qli/reqs.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *	PROGRAM:	Interactive Query Language Interpreter
- *	MODULE:		reqs.h
- *	DESCRIPTION:	Internal request number definitions.
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_REQS_H
-#define QLI_REQS_H
-
-const int REQ_relation_def		= 0;
-const int REQ_store_relation	= 1;
-const int REQ_relation_id		= 2;
-const int REQ_rfr_def			= 3;
-const int REQ_field_def			= 4;
-const int REQ_store_field		= 5;
-const int REQ_store_rfr			= 6;
-const int REQ_modify_fld		= 7;
-const int REQ_update_fld		= 8;
-const int REQ_modify_rel		= 9;
-const int REQ_show_indices		= 10;
-const int REQ_show_index		= 11;
-const int REQ_check_fld			= 12;
-const int REQ_erase_fld			= 13;
-const int REQ_erase_index		= 14;
-const int REQ_erase_segments	= 15;
-//const int REQ_erase_relation	= 16;
-//const int REQ_erase_rfr			= 17;
-//const int REQ_erase_view		= 18;
-const int REQ_show_files		= 19;
-const int REQ_show_view			= 20;
-const int REQ_show_field		= 21;
-const int REQ_show_view_field	= 22;
-const int REQ_show_dbb			= 23;
-const int REQ_show_rel_detail	= 24;
-const int REQ_show_global_field	= 25;
-const int REQ_show_field_instance	= 26;
-const int REQ_show_global_fields	= 27;
-//const int REQ_show_trigger		= 28;
-//const int REQ_show_triggers		= 29;
-const int REQ_show_rel_secur	= 30;
-const int REQ_show_rel_extern	= 31;
-const int REQ_def_index1		= 32;
-const int REQ_def_index2		= 33;
-const int REQ_def_index3		= 34;
-const int REQ_mdf_index			= 35;
-const int REQ_mdf_rfr			= 36;
-//const int REQ_show_forms1		= 37;
-//const int REQ_show_forms2		= 38;
-// const int REQ_trig_exists		= 39;	OBSOLETE
-const int REQ_show_views		= 40;
-const int REQ_show_view_rel		= 41;
-const int REQ_show_secur_class	= 42;
-const int REQ_show_secur		= 43;
-const int REQ_scan_index		= 44;
-const int REQ_show_new_trigger	= 45;
-const int REQ_show_new_triggers	= 46;
-const int REQ_show_sys_triggers	= 47;
-const int REQ_new_trig_exists	= 48;
-//const int REQ_sql_grant			= 49;
-//const int REQ_sql_revoke		= 51;
-//const int REQ_sql_cr_view		= 52;
-//const int REQ_sql_alt_table		= 53;
-//const int REQ_fld_positions		= 54;
-const int REQ_fld_subtype		= 55;
-const int REQ_show_functions	= 56;
-const int REQ_show_func_detail	= 57;
-const int REQ_show_func_args	= 58;
-const int REQ_fld_dimensions	= 59;
-const int REQ_show_filters		= 60;
-const int REQ_show_filter_detail	= 61;
-const int REQ_show_index_type	= 62;
-const int REQ_show_trig_message	= 63;
-const int REQ_show_dimensions	= 64;
-const int REQ_max				= 65;
-
-#endif // QLI_REQS_H
-
diff --git a/src/qli/show_proto.h b/src/qli/show_proto.h
deleted file mode 100644
index 5851eb286b..0000000000
--- a/src/qli/show_proto.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- *	PROGRAM:	JRD Command Oriented Query Language
- *	MODULE:		show_proto.h
- *	DESCRIPTION:	Prototype header file for show.cpp
- *
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-
-#ifndef QLI_SHOW_PROTO_H
-#define QLI_SHOW_PROTO_H
-
-void	SHOW_stuff(qli_syntax*);
-
-#endif // QLI_SHOW_PROTO_H
-
diff --git a/src/qli/symbols.h b/src/qli/symbols.h
deleted file mode 100644
index 00c54aa997..0000000000
--- a/src/qli/symbols.h
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-KW_ABORT,
-KW_ACCEPT,
-KW_ACTIVE,
-KW_ADD,
-KW_ALL,
-KW_ALTER,
-KW_AND,
-KW_ANY,
-KW_ANYCASE,
-KW_AS,
-KW_ASCENDING,
-KW_ASTERISK,
-KW_AT,
-KW_AVERAGE,
-KW_BAR,
-KW_BASED,
-KW_BEGIN,
-KW_BETWEEN,
-KW_BIGINT,
-KW_BLOB,
-KW_BLR,
-KW_BOTTOM,
-KW_BY,
-KW_CHAR,
-//KW_CHOICE,
-//KW_CLOSE,
-//KW_COLLECTION,
-//KW_COLLECTIONS,
-KW_COLON,
-KW_COLUMN,
-KW_COLUMNS,
-KW_COLUMN_HEADER,
-KW_COMMA,
-KW_COMMIT,
-//KW_COMPUTED,
-KW_CONTAINING,
-KW_CONT_PROMPT,
-KW_COPY,
-KW_COUNT,
-KW_CREATE,
-KW_CROSS,
-//KW_CURSOR,
-KW_DATABASE,
-KW_DATABASES,
-KW_DATE,
-KW_DECIMAL,
-KW_DECLARE,
-KW_DEFINE,
-KW_DELETE,
-KW_DESCENDING,
-KW_DISTINCT,
-KW_DOT,
-KW_DOUBLE,
-KW_DROP,
-KW_DUPLICATE,
-KW_ECHO,
-KW_EDIT,
-KW_EDIT_STRING,
-KW_ELSE,
-KW_END,
-//KW_END_CHOICE,
-//KW_END_FOR,
-//KW_END_MODIFY,
-KW_END_PROCEDURE,
-KW_END_REPORT,
-//KW_END_STORE,
-//KW_END_STREAM,
-//KW_ENTREE,
-KW_EQ,
-KW_EQUALS,
-KW_ERASE,
-KW_ESCAPE,
-//KW_EUC_JUSTIFY,
-KW_EXACTCASE,
-//KW_EXEC,
-KW_EXISTS,
-KW_EXIT,
-#ifdef DEV_BUILD
-KW_EXPLAIN,
-#endif
-KW_EXTRACT,
-KW_FIELD,
-KW_FIELDS,
-KW_FILTER,
-KW_FILTERS,
-KW_FINISH,
-KW_FIRST,
-KW_FIXED,
-KW_FLOAT,
-KW_FOR,
-KW_FORMAT,
-KW_FROM,
-KW_FULL,
-KW_FUNCTION,
-KW_FUNCTIONS,
-KW_GE,
-KW_GLOBAL,
-KW_GRANT,
-KW_GROUP,
-//KW_GROUPED,
-KW_GT,
-KW_HAVING,
-KW_HELP,
-#ifdef DEV_BUILD
-KW_HEXOUT,
-#endif
-KW_IF,
-KW_IN,
-KW_INACTIVE,
-KW_INDEX,
-KW_INDICES,
-KW_INNER,
-KW_INSERT,
-KW_INTEGER,
-KW_INTO,
-KW_IS,
-KW_JOIN,
-//KW_LABEL,
-KW_LE,
-//KW_LEAVE,
-KW_LEFT,
-KW_LEFT_PAREN,
-KW_LIKE,
-KW_LINES,
-KW_LIST,
-KW_LONG,
-KW_LT,
-//KW_L_BRACE,
-KW_L_BRCKET,
-KW_MATCHES,
-KW_MATCHING_LANGUAGE,
-KW_MAX,
-//KW_MEN,
-//KW_MENU,
-KW_MIN,
-KW_MINUS,
-KW_MISSING,
-KW_MODIFY,
-KW_NAMES,
-KW_NE,
-KW_NEW_PAGE,
-KW_NO,
-KW_NOT,
-KW_NULL,
-KW_NUMERIC,
-KW_OF,
-KW_ON,
-//KW_OPEN,
-KW_OPTION,
-KW_OR,
-KW_ORDER,
-KW_OUTER,
-KW_OVER,
-KW_PAGE,
-KW_PAGESIZE,
-KW_PASSWORD,
-KW_PLUS,
-KW_PRECISION,
-KW_PREPARE,
-KW_PRINT,
-KW_PRIVILEGES,
-KW_PROCEDURE,
-KW_PROCEDURES,
-KW_PROMPT,
-KW_QUERY_HEADER,
-KW_QUERY_NAME,
-KW_QUIT,
-KW_READY,
-KW_REAL,
-KW_REDUCED,
-KW_RELATION,
-KW_RELATIONS,
-KW_RENAME,
-KW_REPEAT,
-KW_REPORT,
-KW_REPORT_HEADER,
-KW_REPORT_NAME,
-KW_REVOKE,
-KW_RIGHT,
-KW_RIGHT_PAREN,
-KW_ROLLBACK,
-KW_RUNNING,
-//KW_R_BRACE,
-KW_R_BRCKET,
-KW_SCALE,
-KW_SECURITY_CLASS,
-KW_SECURITY_CLASSES,
-KW_SELECT,
-KW_SEMI,
-KW_SEMICOLON,
-KW_SET,
-KW_SHELL,
-KW_SHORT,
-KW_SHOW,
-KW_SINGULAR,
-KW_SKIP,
-KW_SLASH,
-KW_SMALLINT,
-KW_SORTED,
-KW_SPACE,
-KW_STARTS,
-KW_STATISTICS,
-KW_STORE,
-KW_SUB_TYPE,
-KW_SYSTEM,
-KW_TAB,
-KW_TABLE,
-KW_TEXT,
-KW_THEN,
-KW_TO,
-KW_TOP,
-KW_TOTAL,
-//KW_TRIGGER,
-KW_TRIGGERS,
-//KW_UNION,
-KW_UNIQUE,
-KW_UPDATE,
-//KW_UPPERCASE,
-KW_USER,
-KW_USER_NAME,
-KW_USING,
-//KW_VALID,
-KW_VALUES,
-KW_VARCHAR,
-KW_VARIABLE,
-KW_VARIABLES,
-KW_VARYING,
-KW_VERSION,
-KW_VIEW,
-KW_VIEWS,
-KW_WITH,
diff --git a/src/qli/words.h b/src/qli/words.h
deleted file mode 100644
index 1082dbb30e..0000000000
--- a/src/qli/words.h
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
- * The contents of this file are subject to the Interbase Public
- * License Version 1.0 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy
- * of the License at http://www.Inprise.com/IPL.html
- *
- * Software distributed under the License is distributed on an
- * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
- * or implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code was created by Inprise Corporation
- * and its predecessors. Portions created by Inprise Corporation are
- * Copyright (C) Inprise Corporation.
- *
- * All Rights Reserved.
- * Contributor(s): ______________________________________.
- */
-{KW_ABORT,				"ABORT"},
-{KW_ACCEPT,				"ACCEPT"},
-{KW_ACTIVE,				"ACTIVE"},
-{KW_ADD,				"ADD"},
-{KW_ALL,				"ALL"},
-{KW_ALTER,				"ALTER"},
-{KW_AND,				"&&"},
-{KW_AND,				"AND"},
-{KW_ANY,				"ANY"},
-{KW_ANY,				"SOME"},
-{KW_ANYCASE,			"ANYCASE"},
-{KW_AS,					"AS"},
-{KW_ASCENDING,			"ASC"},
-{KW_ASCENDING,			"ASCENDING"},
-{KW_ASTERISK,			"*"},
-{KW_AT,					"AT"},
-{KW_AVERAGE,			"AVERAGE"},
-{KW_AVERAGE,			"AVG"},
-{KW_BAR,				"|"},
-{KW_BASED,				"BASED"},
-{KW_BASED,				"BASED_ON"},
-{KW_BEGIN,				"BEGIN"},
-{KW_BETWEEN,			"BETWEEN"},
-{KW_BETWEEN,			"BT"},
-{KW_BIGINT,				"BIGINT"},
-{KW_BLOB,				"BLOB"},
-{KW_BLR,				"BLR"},
-{KW_BOTTOM,				"BOTTOM"},
-{KW_BY,					"BY"},
-{KW_CHAR,				"CHAR"},
-{KW_CHAR,				"CHARACTER"},
-//{KW_CHOICE,			"CHOICE"},
-//{KW_CLOSE,			"CLOSE"},
-//{KW_COLLECTION,		"COLLECTION"},
-//{KW_COLLECTIONS,		"COLLECTIONS"},
-{KW_COLON,				":"},
-{KW_COLUMN,				"COL"},
-{KW_COLUMNS,			"COLUMNS"},
-{KW_COLUMN_HEADER,		"COLUMN_HEADER"},
-{KW_COMMA,				","},
-{KW_COMMIT,				"COMMIT"},
-//{KW_COMPUTED,			"COMPUTED"},
-{KW_CONTAINING,			"CONT"},
-{KW_CONTAINING,			"CONTAINING"},
-{KW_CONTAINING,			"CT"},
-{KW_CONT_PROMPT,		"CONTINUATION"},
-{KW_COPY,				"COPY"},
-{KW_COUNT,				"COUNT"},
-{KW_CREATE,				"CREATE"},
-{KW_CROSS,				"CROSS"},
-//{KW_CURSOR,			"CURSOR"},
-{KW_DATABASE,			"DATABASE"},
-{KW_DATABASES,			"DATABASES"},
-{KW_DATE,				"DATE"},
-{KW_DECIMAL,			"DECIMAL"},
-{KW_DECIMAL,			"DEC"},
-{KW_DECLARE,			"DECLARE"},
-{KW_DEFINE,				"DEFINE"},
-{KW_DELETE,				"DELETE"},
-{KW_DESCENDING,			"DESC"},
-{KW_DESCENDING,			"DESCENDING"},
-{KW_DISTINCT,			"DISTINCT"},
-{KW_DOT,				"."},
-{KW_DOUBLE,				"DOUBLE"},
-{KW_DROP,				"DROP"},
-{KW_DUPLICATE,			"DUPLICATE"},
-{KW_DUPLICATE,			"DUPLICATES"},
-{KW_ECHO,				"ECHO"},
-{KW_EDIT,				"EDIT"},
-{KW_EDIT_STRING,		"EDIT_STRING"},
-{KW_ELSE,				"ELSE"},
-{KW_END,				"END"},
-//{KW_END_CHOICE,		"END_CHOICE"},
-//{KW_END_FOR,			"END_FOR"},
-//{KW_END_MODIFY,		"END_MODIFY"},
-{KW_END_PROCEDURE,		"END_PROCEDURE"},
-{KW_END_REPORT,			"END_REPORT"},
-//{KW_END_STORE,		"END_STORE"},
-//{KW_END_STREAM,		"END_STREAM"},
-//{KW_ENTREE,			"ENTREE"},
-{KW_EQ,					"=="},
-{KW_EQ,					"EQ"},
-{KW_EQUALS,				"="},
-{KW_ERASE,				"ERASE"},
-{KW_ESCAPE,				"ESCAPE"},
-//{KW_EUC_JUSTIFY,		"EUC_JUSTIFY"},
-{KW_EXACTCASE,			"EXACTCASE"},
-//{KW_EXEC,				"EXEC"},
-{KW_EXISTS,				"EXISTS"},
-{KW_EXIT,				"EXIT"},
-#ifdef	DEV_BUILD
-{KW_EXPLAIN,			"EXPLAIN"},
-#endif
-{KW_EXTRACT,			"EXTRACT"},
-{KW_FIELD,				"FIELD"},
-{KW_FIELDS,				"FIELDS"},
-{KW_FILTER,				"FILTER"},
-{KW_FILTERS,			"FILTERS"},
-{KW_FINISH,				"FINISH"},
-{KW_FIRST,				"FIRST"},
-{KW_FIXED,				"FIXED"},
-{KW_FLOAT,				"FLOAT"},
-{KW_FOR,				"FOR"},
-{KW_FORMAT,				"FORMAT"},
-{KW_FROM,				"FROM"},
-{KW_FULL,				"FULL"},
-{KW_FUNCTION,			"FUNCTION"},
-{KW_FUNCTIONS,			"FUNCTIONS"},
-{KW_GE,					">="},
-{KW_GE,					"GE"},
-{KW_GE,					"^<"},
-{KW_GLOBAL,				"GLOBAL"},
-{KW_GRANT,				"GRANT"},
-{KW_GROUP,				"GROUP"},
-//{KW_GROUPED,			"GROUPED"},
-{KW_GT,					">"},
-{KW_GT,					"GT"},
-{KW_HAVING,				"HAVING"},
-{KW_HELP,				"HELP"},
-#ifdef	DEV_BUILD
-{KW_HEXOUT,				"HEX_OUTPUT"},
-#endif
-{KW_IF,					"IF"},
-{KW_IN,					"IN"},
-{KW_INACTIVE,			"INACTIVE"},
-{KW_INDEX,				"INDEX"},
-{KW_INDICES,			"INDEXES"},
-{KW_INDICES,			"INDICES"},
-{KW_INNER,				"INNER"},
-{KW_INSERT,				"INSERT"},
-{KW_INTEGER,			"INTEGER"},
-{KW_INTEGER,			"INT"},
-{KW_INTO,				"INTO"},
-{KW_IS,					"IS"},
-{KW_JOIN,				"JOIN"},
-//{KW_LABEL,			"LABEL"},
-{KW_LE,					"<="},
-{KW_LE,					"LE"},
-{KW_LE,					"^>"},
-//{KW_LEAVE,			"LEAVE"},
-{KW_LEFT,				"LEFT"},
-{KW_LEFT_PAREN,			"("},
-{KW_LIKE,				"LIKE"},
-{KW_LINES,				"LINES"},
-{KW_LIST,				"LIST"},
-{KW_LONG,				"LONG"},
-{KW_LT,					"<"},
-{KW_LT,					"LT"},
-//{KW_L_BRACE,			"{"},
-{KW_L_BRCKET,			"["},
-{KW_MATCHES,			"MATCHES"},
-{KW_MATCHES,			"MATCHING"},
-{KW_MATCHING_LANGUAGE,	"MATCHING_LANGUAGE"},
-{KW_MAX,				"MAX"},
-//{KW_MEN,				"MANU"},
-//{KW_MENU,				"MENU"},
-{KW_MIN,				"MIN"},
-{KW_MINUS,				"-"},
-{KW_MISSING,			"MISSING"},
-{KW_MODIFY,				"MODIFY"},
-{KW_NAMES,				"NAMES"},
-{KW_NE,					"!="},
-{KW_NE,					"NE"},
-{KW_NE,					"<>"},
-{KW_NE,					"^="},
-{KW_NE,					"~="},
-{KW_NEW_PAGE,			"NEW_PAGE"},
-{KW_NO,					"NO"},
-{KW_NOT,				"NOT"},
-{KW_NULL,				"NULL"},
-{KW_NUMERIC,			"NUMERIC"},
-{KW_OF,					"OF"},
-{KW_ON,					"ON"},
-//{KW_OPEN,				"OPEN"},
-{KW_OPTION,				"OPTION"},
-{KW_OR,					"OR"},
-{KW_OR,					"||"},
-{KW_ORDER,				"ORDER"},
-{KW_OUTER,				"OUTER"},
-{KW_OVER,				"OVER"},
-{KW_PAGE,				"PAGE"},
-{KW_PAGESIZE,			"PAGESIZE"},
-{KW_PASSWORD,			"PASSWORD"},
-{KW_PLUS,				"+"},
-{KW_PRECISION,			"PRECISION"},
-{KW_PREPARE,			"PREPARE"},
-{KW_PRINT,				"PRINT"},
-{KW_PRIVILEGES,			"PRIVILEGES"},
-{KW_PROCEDURE,			"PROCEDURE"},
-{KW_PROCEDURES,			"PROCEDURES"},
-{KW_PROMPT,				"PROMPT"},
-{KW_QUERY_HEADER,		"QUERY_HEADER"},
-{KW_QUERY_NAME,			"QUERY_NAME"},
-{KW_QUIT,				"QUIT"},
-{KW_READY,				"READY"},
-{KW_REAL,				"REAL"},
-{KW_REDUCED,			"REDUCED"},
-{KW_RELATION,			"RELATION"},
-{KW_RELATIONS,			"RELATIONS"},
-{KW_RELATIONS,			"TABLES"},
-{KW_RENAME,				"RENAME"},
-{KW_REPEAT,				"REPEAT"},
-{KW_REPORT,				"REPORT"},
-{KW_REPORT_HEADER,		"REPORT_HEADER"},
-{KW_REPORT_NAME,		"REPORT_NAME"},
-{KW_REVOKE,				"REVOKE"},
-{KW_RIGHT,				"RIGHT"},
-{KW_RIGHT_PAREN,		")"},
-{KW_ROLLBACK,			"ROLLBACK"},
-{KW_RUNNING,			"RUNNING"},
-//{KW_R_BRACE,			"}"},
-{KW_R_BRCKET,			"]"},
-{KW_SCALE,				"SCALE"},
-{KW_SECURITY_CLASS,		"SECURITY_CLASS"},
-{KW_SECURITY_CLASSES,	"SECURITY_CLASSES"},
-{KW_SELECT,				"SELECT"},
-{KW_SEMI,				";"},
-{KW_SEMI,				"\n"},
-{KW_SEMI,				"end	of	line"},
-{KW_SEMICOLON,			"SEMI"},
-{KW_SEMICOLON,			"SEMICOLON"},
-{KW_SET,				"SET"},
-{KW_SHELL,				"SHELL"},
-{KW_SHELL,				"SPAWN"},
-{KW_SHORT,				"SHORT"},
-{KW_SHOW,				"SHOW"},
-{KW_SINGULAR,			"SINGULAR"},
-{KW_SKIP,				"SKIP"},
-{KW_SLASH,				"/"},
-{KW_SMALLINT,			"SMALLINT"},
-{KW_SORTED,				"SORTED"},
-{KW_SPACE,				"SPACE"},
-{KW_STARTS,				"ST"},
-{KW_STARTS,				"STARTING"},
-{KW_STARTS,				"STARTS"},
-{KW_STATISTICS,			"STATISTICS"},
-{KW_STORE,				"STORE"},
-{KW_SUB_TYPE,			"SUB_TYPE"},
-{KW_SYSTEM,				"SYSTEM"},
-{KW_TAB,				"TAB"},
-{KW_TABLE,				"TABLE"},
-{KW_TEXT,				"TEXT"},
-{KW_THEN,				"THEN"},
-{KW_TO,					"TO"},
-{KW_TOP,				"TOP"},
-{KW_TOTAL,				"SUM"},
-{KW_TOTAL,				"TOTAL"},
-//{KW_TRIGGER,			"TRIGGER"},
-{KW_TRIGGERS,			"TRIGGERS"},
-//{KW_UNION,			"UNION"},
-{KW_UNIQUE,				"UNIQUE"},
-{KW_UPDATE,				"UPDATE"},
-//{KW_UPPERCASE,		"UPPERCASE"},
-{KW_USER,				"USER"},
-{KW_USER_NAME,			"RDB$USER_NAME"},
-{KW_USING,				"USING"},
-//{KW_VALID,			"VALID"},
-{KW_VALUES,				"VALUES"},
-{KW_VARCHAR,			"VARCHAR"},
-{KW_VARIABLE,			"VARIABLE"},
-{KW_VARIABLES,			"VARIABLES"},
-{KW_VARYING,			"VARYING"},
-{KW_VERSION,			"VERSION"},
-{KW_VIEW,				"VIEW"},
-{KW_VIEWS,				"VIEWS"},
-{KW_WITH,				"WHERE"},
-{KW_WITH,				"WITH"},
